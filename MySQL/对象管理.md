# 对象信息查询

~~~sql
#列出 MySQL 数据库管理系统的数据库列表。
SHOW DATABASES;
#显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。
SHOW TABLES;
#显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。
SHOW COLUMNS FROM 数据表;
#显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW INDEX FROM 数据表;
#显示表结构
desc 数据表;


#获得当前数据库(catalog)和schema
select current_database();
select current_schema();
#查询表上的索引信息（mysql8.0的innodb表）
select t1.NAME as table_name,t2.name as index_name
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name <> 'GEN_CLUST_INDEX';


#将查询结果导出到指定文件
#需要注意只能把文件导出到secure_file_priv参数的路径下
mysql> show variables like 'secure%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv | /tmp/ |
+------------------+-------+
1 row in set (0.00 sec)

select concat('drop index ',name,' on sbtest', mid(name,3,3),';') FROM information_schema.INNODB_INDEXES where name like  'k%' into outfile '/tmp/drop_index1.sql';
#执行sql文件命令
mysql -uroot -prootroot -Dsysbenchdb < /tmp/drop_index1.sql &



#查schema下有什么表
--查询当前schema下有什么表（方法一）
select * from pg_tables where schemaname=current_schema();
-- 查询当前schema下有什么表（方法二）
SELECT *
FROM information_schema.tables
WHERE table_catalog=current_database() and table_schema = current_schema();
-- 判断表是否存在(方法一)
select tablename from pg_tables where schemaname=current_schema() and tablename='communication'
-- 判断表是否存在(方法二)
SELECT table_name
FROM information_schema.tables
WHERE table_catalog=current_database() and table_schema=current_schema() and table_name='communication'

#查表有什么字段
-- 查询表有什么列（字段信息，含类型等等）
SELECT *
FROM information_schema.columns
WHERE table_catalog=current_database() and table_schema = current_schema() and table_name = 'communication';
-- 判断某列是否存在
SELECT column_name
FROM information_schema.columns
WHERE table_catalog=current_database() and table_schema = current_schema() and table_name = 'communication'and column_name='dr';



#查看数据库下有哪些表和视图
select table_schema,table_name,table_type from information_schema.tables where table_schema='sakila';
#查看数据库下有哪些视图
select table_schema,table_name from information_schema.views where table_schema='sakila';
#查看数据库下有哪些函数和存储过程
select routine_schema,routine_name from information_schema.routines where routine_schema='sakila';
#查看数据库下有哪些触发器
select trigger_schema,trigger_name from information_schema.triggers where trigger_schema='sakila';
#查看约束信息
select constraint_schema,constraint_name,table_schema,table_name,constraint_type from information_schema.table_constraints where constraint_schema = 'sakila';



#查表有什么索引
--查询表有什么索引
SELECT *
FROM pg_indexes
WHERE schemaname = current_schema() AND tablename = 'communication';
--判断索引是否存在
SELECT indexname
FROM pg_indexes
WHERE schemaname = current_schema() AND tablename = 'communication' AND
indexname = 'idx_table_name';


#查主键的名字（含是否存在主键）
--判断主键名字是什么，查无记录表示无主键（改一下relname的值，contype不需要改，p表示主键）
SELECT
    pg_constraint.conname AS pk_name
FROM
    pg_constraint
INNER JOIN pg_class ON pg_constraint.conrelid = pg_class.oid
WHERE
    pg_class.relname = 'my_table'
AND pg_constraint.contype = 'p';


#分区表查询
select distinct TABLE_NAME
from information_schema.PARTITIONS
where TABLE_SCHEMA=SCHEMA() and partition_name is not null;



-- 查看某个数据库多大
select concat(round(sum(data_length/1024/1024),2),'MB') as data from information_schema .tables where table_schema='source_testdb';

 
-- 数据库 mysql 库表以及索引大小查询
 
-- 查看指定库的大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS DATA  FROM TABLES WHERE table_schema='testschema';
-- 查看指定库的指定表的大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS DATA  FROM TABLES WHERE table_schema='testschema' AND table_name='t_syt_keyword_off_rep';
-- 查看指定库的索引大小
SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), ' MB') AS 'Total Index Size' FROM TABLES  WHERE table_schema = 'testschema'; 
-- 查看指定库的指定表的索引大小
SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), ' MB') AS 'Total Index Size' FROM TABLES  WHERE table_schema = 'testschema' AND table_name='tab_user'; 
 
 
-- 1.查看指定库数据和索引大小总和
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS total_data FROM information_schema.TABLES WHERE table_schema = 'testschema';
 
-- 2.查看所有库数据和索引大小总和
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS total_data FROM information_schema.TABLES;
 
-- 3.查看指定数据库的某个表
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS DATA FROM TABLES WHERE table_schema='testschema' AND table_name='tab_user';
 
-- 4.查询一个库中每个表的数据大小，索引大小和总大小
SELECT
CONCAT(a.table_schema,'.',a.table_name),
CONCAT(ROUND(table_rows/1000,4),'KB') AS 'Number of Rows',
CONCAT(ROUND(data_length/(1024*1024),4),',') AS 'data_size',
CONCAT(ROUND(index_length/(1024*1024),4),'M') AS 'index_size',
CONCAT(ROUND((data_length+index_length)/(1024*1024),4),'M') AS'Total'
FROM
information_schema. TABLES a
WHERE
a.table_schema = 'testschema';
~~~

# 数据库的创建与管理

## 数据库命名规范

- 数据库名不能超过30个字符,推荐使用下划线命名方式。
- 数据库命名必须为项目英文名称或有意义的简写。
- 数据库创建时必须添加默认字符集和校对规则子句。
- 命名应使用小写。

## 字符集的选择

- 自开发系统的数据库Utf8作为字符集的惟一选择,默认字符集为UTF8,

  建议：统一使用utf8字符集和utf8_general_ci字符排序规则,按需对表级设置utf8mb4

- 外购系统的字符集按照开发和业务要求选择,需申请例外。

- 使用工具导出的数据脚本文件,必须在导出工具中,显式选择utf8作为导出格式。

- 在恢复前需要编辑,必须使用纯文本方式打开,编辑和保存,防止隐含控制字符(如^M)添加进脚本。在Linux环境,可以通过"cat-A脚本文件名"方式确认和检查是否携带了隐含控制字符。

**备注：**

> utf_general_ci不区分大小写，utf_general_cs区分大小写，utf8_bin二进制
> Unicode 万国码/统一码/单一码：ucs2，utf16，utf16le，utf8，utf8mb4，utf32
> utf8：1字符占用1~3个字节：升级老系统推荐使用
> utf8mb4：1字符占用1~4个字节：新系统使用

## 数据库设计规范

- 控制单实例表个数控制在3w以内
- 控制单库表个数，建议单库不超过4096个表
- 创建数据库的语句必须包含字符集子句和校对规则子句。如：

~~~shell
create database testdb [if not exists] default character set UTF8 default collate utf_general_ci;
~~~



# 用户管理

## 用户创建

~~~sql
-- 5.7授权即创建
-- root可以用户从任何主机（%）访问所有数据库（第一个*）的所有对象（第二个*），同时可以把权限授予给其他用户
grant all privileges on *.* to 'root'@'%' identified by 'rootroot' with grant option;
flush privileges;

-- 创建用户
CREATE USER 'root'@'%' IDENTIFIED BY 'rootroot';
~~~

## 修改用户密码

~~~sql
-- 使用修改参数方式修改密码
set password=password('rootroot');


use mysql
-- 直接更新系统表
update user set authentication_string=password("root") where user="root";
flush privileges;

-- 使用命令修改
ALTER USER 'root'@'localhost' IDENTIFIED BY 'rootroot';
~~~



## 授权用户远程登录

~~~sql
#MySQL5.7.X
use mysql
select host,user from user where user='root';
grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;
flush privileges;
select host,user from user where user='root';



#MySQL8.0.X
use mysql
select host,user from user where user='root';
CREATE USER 'root'@'%' IDENTIFIED BY 'rootroot';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;
select host,user from user where user='root';

https://blog.csdn.net/JineD/article/details/106990089
~~~

## 密码过期处理

~~~shell
#1、添加参数skip-grant-tables（跳过权限表）
cat >> /mysql/data/3306/my.cnf << "EOF"
skip-grant-tables
EOF
#2、重启mysql
service mysql stop
service mysql start
#3、连接数据库（不用输入密码），修改密码为不过期
mysql -uroot -p
use mysql
select host,user, password_expired from mysql.user where user='root';
update user set password_expired='N' where user='root';
flush privileges;
ALTER USER 'root'@'localhost' IDENTIFIED BY 'rootroot';
#4、改回配置删除参数skip-grant-tables
sed -i '/^skip-grant-tables/d' /mysql/data/3306/my.cnf
#5、重启mysql
service mysql stop
service mysql start
~~~











# 权限管理





# 表

## 普通表

创建表

~~~sql
CREATE TABLE dept (
	deptno INT auto_increment PRIMARY KEY,
	dname VARCHAR ( 15 ),
loc VARCHAR ( 50 ) 
) engine = INNODB;
insert into dept values (1,'it','bj');
insert into dept values (2,'cw','sh');
insert into dept values (3,'hr','sz');
commit;
select * from dept;
~~~



## 分区表

### 范围分区

~~~sql
CREATE TABLE members (
 firstname VARCHAR(25) NOT NULL,
 lastname VARCHAR(25) NOT NULL,
 username VARCHAR(16) NOT NULL,
 email VARCHAR(35),
 joined DATE NOT NULL
)
PARTITION BY RANGE( YEAR(joined) ) (
 PARTITION p0 VALUES LESS THAN (1960),
 PARTITION p1 VALUES LESS THAN (1970),
 PARTITION p2 VALUES LESS THAN (1980),
 PARTITION p3 VALUES LESS THAN (1990),
 PARTITION p4 VALUES LESS THAN MAXVALUE
);
~~~



# 常用命令

~~~sql
--环境IP
192.168.0.127
--启停
service mysql start
service mysql stop

--启动
mysqld_safe --defaults-file=/data/yaokang/mysql/data/3306/my.cnf --user=mysql
--停止
mysqladmin -uroot -p shutdown -S /data/yaokang/mysql/data/3306/mysql.sock
OR
mysqladmin -uroot -prootroot shutdown -S /data/yaokang/mysql/data/3306/mysql.sock


--外部执行命令
mysql -uhr -phr -h 192.168.1.64 hr -e 'select * from employees;'

--root用户连接
mysql -uroot -prootroot
--报错处理
ERROR 2002 (HY000): Can not connect to local MySQL server through socket '/tmp/mysql.sock' (2)
ln -s /data/yaokang/mysql/data/3306/mysql.sock /tmp
OR
mysql -uroot -p -S /data/yaokang/mysql/data/3306/mysql.sock



--在线迁移的数据库和用户
create database source_testdb;
use source_testdb
create user 'usr_replica'@'%' identified by 'Test_123';
grant all on *.* to 'usr_replica'@'%' identified by 'Test_123';
grant reload on *.* to 'usr_replica';
grant replication client on *.* to 'usr_replica';
grant replication slave on *.* to 'usr_replica';
flush privileges;

set global init_connect="set autocommit=1";
SHOW GLOBAL VARIABLES LIKE 'init_connect';
SHOW VARIABLES LIKE '%log_bin%';



--枚举类型表
CREATE TABLE IF NOT EXISTS `enum_set_test` (
`user_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户 ID',
`real_name` varchar(20) CHARACTER SET utf8 DEFAULT NULL COMMENT '姓名',
`sex` enum('none','male','female') CHARACTER SET utf8 DEFAULT 'none' COMMENT '性别',
`my_fruit` set('apple','banana','pear','orange','peach','lemon') CHARACTER SET utf8 DEFAULT '' COMMENT '喜欢的水果',
PRIMARY KEY (`user_id`)

)  COMMENT='MYSQL enum set 字段演示';

-- 正在导出表 num_set_test 的数据：14 rows

INSERT INTO `enum_set_test` (`user_id`, `real_name`, `sex`, `my_fruit`) VALUES
(1, '张三', 'none', ''),
(2, '李四', 'male', 'apple,banana'),
(3, '王五', 'male', 'banana,pear,orange'),
(4, '赵六', 'male', 'orange,peach,lemon'),
(5, '程七', 'male', 'banana,orange,lemon'),
(6, '孙九', 'male', 'apple,pear,orange,peach'),
(7, '陈十', 'none', 'apple,pear,peach'),
(8, '张三一', 'none', 'banana,orange,lemon'),
(9, '李四一', 'female', 'apple,banana,pear'),
(10, '王五一', 'female', 'orange,peach,lemon'),
(11, '赵六一', 'female', ''),
(12, '程七一', 'female', 'banana'),
(13, '孙九一', 'female', 'orange'),
(14, '陈十一', 'none', 'apple,banana,pear');

2、enum(枚举类型)查询和更新

可以通过序号方式查询，也可以通过值。# 通过序号查询 姓别

SELECT * from enum_set_test where `sex` = 1; # 对应值 none
SELECT * from enum_set_test where `sex` = 2; # 对应值 male
SELECT * from enum_set_test where `sex` = 3; # 对应值 female

# 通过值查询 姓别

SELECT * from enum_set_test where `sex` = 'none'; # 对应序号 1
SELECT * from enum_set_test where `sex` = 'male'; # 对应序号 2
SELECT * from enum_set_test where `sex` = 'female'; # 对应序号 3
~~~



# 对象创建

~~~shell
#建表、删表 DDL（含自动创建sequence）
--建表（幂等）【不指定主键的名字】
--【主键默认是 "表名_pkey"，即 my_table_pkey】
--【serial或者serial8分别表示int4和int8的，这种写法会自动建sequence，且名字是 "表名_id_seq"，删除表的时候会级联删除该序列】
CREATE TABLE IF NOT EXISTS "my_table"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  PRIMARY KEY ("id")
);
--建表（幂等）【指定主键的名字】
CREATE TABLE IF NOT EXISTS "my_table2"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  CONSTRAINT "custom_name_of_my_table2" PRIMARY KEY ("id")
);


CREATE TABLE `name_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(12) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `year` int(12) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `cs` (`name`,`year`)
);


--删表（幂等）
drop table if exists "data_oss_upload";







#列（增删改列）
--新增列（无法重复执行，无法判断是否已经存在）
alter table "communication" add COLUMN table_name varchar(512);
--删除列（无法重复执行，无法判断字段是否已存在）
alter table "communication" drop column dr;
--修改列类型和精度（可重复执行，只能修改列类型）
alter table "communication" alter column table_name type varchar(500);
--修改列名（不可重复执行，修改列名要用这个）
alter table "communication" rename column table_name to table_name2;
--列名和类型一起修改，结合用上面2句即可，貌似没一句话干两样的



#注释
--对表注释(可重复执行，但需要表存在)
COMMENT ON TABLE "communication" IS '通信表';
--对列注释（可重复执行，但需要表、列存在）
COMMENT ON COLUMN "communication"."id" IS '自增主键';



#索引
--建普通索引（幂等）
CREATE INDEX IF NOT EXISTS "idx_table_name" ON "communication" USING btree (
  "table_name" COLLATE "pg_catalog"."default" "pg_catalog"."bpchar_ops" ASC NULLS LAST
);
--建唯一索引（幂等）
create unique index IF NOT EXISTS data_app_api_app_id_api_no on data_app_api (app_id,api_no);
--删除索引（幂等）
drop INDEX IF EXISTS "idx_table_name";
--修改索引：先删后增即可



#约束（注意别把 CONSTRAINT 写成复数），感觉有部分的约束其实是可以使用index来表示的，使用index以便实现幂等
--新增唯一约束（应该就是唯一索引的另外一种写法）
ALTER TABLE "communication" ADD CONSTRAINT "idx_communication_only" UNIQUE ("ds_id", "table_name", "tenant_id");
--貌似等价于
create unique index IF NOT EXISTS "idx_communication_only" on "communication" ("ds_id", "table_name", "tenant_id");
--新增普通约束（非唯一，也相当于索引）
ALTER TABLE "communication" ADD CONSTRAINT "idx_communication_only"("ds_id", "table_name", "tenant_id");



#主键，表已经建好了，如何新增、修改、删除主键
--新增主键。不指定主键的名字，默认是"表名_pkey"，即 my_table_pkey 【不指定主键名字】
ALTER TABLE "my_table" ADD PRIMARY KEY(id,minute);
--新增主键。指定主键的名字（注意不要写错 ADD CONSTRAINTS）【指定主键名字】
ALTER TABLE "my_table" ADD CONSTRAINT custom_name_of_my_table6666 PRIMARY KEY (id);



--新建表的时候顺带建主键
--创建表的顺带创建主键【不指定主键的名字，默认是 "表名_pkey"，即 my_table_pkey】
CREATE TABLE IF NOT EXISTS "my_table"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  PRIMARY KEY ("id")
);
--创建表的顺带创建主键  【指定主键的名字】
CREATE TABLE IF NOT EXISTS "my_table2"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  CONSTRAINT "custom_name_of_my_table2" PRIMARY KEY ("id")
);

--删除主键（不知道主键名删不了）
--删除主键【知道名字的情况下】
ALTER TABLE "my_table" DROP CONSTRAINT IF EXISTS my_cons;
--主键名的情况下似乎删不了（可以查主键叫什么名）



#创建序列（sequence）
--创建序列（幂等）【指定从某个值开始】
CREATE SEQUENCE IF NOT EXISTS api_no START 10000;

#创建用户
create user 'test_u'@'%' identified by 'test@123';


#分区表
https://blog.csdn.net/frostlulu/article/details/122304238
https://cloud.tencent.com/developer/article/1408996?from=15425
~~~

# 事件定时器

~~~sql
show variables like 'event_scheduler';
~~~



https://cloud.tencent.com/developer/article/1888329 
https://www.cnblogs.com/zhuminghui/p/12808024.html 
https://zhuanlan.zhihu.com/p/450454992

# 应用

## 字段拼接

~~~shell
#单行数据多字段拼接
concat

#多行数据同一个字段的拼接
group_concat

#group_concat函数
create table aa(id int,name varchar(100));
insert into aa values(1,10);
insert into aa values(1,20);
insert into aa values(1,20);
insert into aa values(2,20);
insert into aa values(3,200);
insert into aa values(3,500);

mysql> select id,group_concat(name) from aa group by id;
+------+--------------------+
| id   | group_concat(name) |
+------+--------------------+
|    1 | 10,20,20           |
|    2 | 20                 |
|    3 | 200,500            |
+------+--------------------+

mysql> select id,group_concat(name separator ';') from aa group by id;
+------+----------------------------------+
| id   | group_concat(name separator ';') |
+------+----------------------------------+
|    1 | 10;20;20                         |
|    2 | 20                               |
|    3 | 200;500                          |
+------+----------------------------------+

mysql> select id,group_concat(distinct name) from aa group by id;
+------+-----------------------------+
| id   | group_concat(distinct name) |
+------+-----------------------------+
|    1 | 10,20                       |
|    2 | 20                          |
|    3 | 200,500                     |
+------+-----------------------------+

mysql> select id,group_concat(distinct name order by name desc) from aa group by id;
+------+------------------------------------------------+
| id   | group_concat(distinct name order by name desc) |
+------+------------------------------------------------+
|    1 | 20,10                                          |
|    2 | 20                                             |
|    3 | 500,200                                        |
+------+------------------------------------------------+
~~~

## 字符串截取

~~~shell
#根据指定分隔符截取字符串
SUBSTRING_INDEX
mysql> select SUBSTRING_INDEX('haha,hehe,heihei',',',-1);
+--------------------------------------------+
| SUBSTRING_INDEX('haha,hehe,heihei',',',-1) |
+--------------------------------------------+
| heihei                                     |
+--------------------------------------------+
1 row in set (0.00 sec)

https://blog.csdn.net/crack6677/article/details/120334606
~~~

## 字符串转换成时间戳

**使用STR_TO_DATE函数将字符串转换成日期**

~~~shell
STR_TO_DATE(str, format)
~~~

其中，str 是要转换的字符串，format 是日期的格式。下面是一些常用的日期格式：

| 格式 | 说明                 |
| ---- | -------------------- |
| %Y   | 四位数的年份         |
| %m   | 月份                 |
| %d   | 日期                 |
| %H   | 小时                 |
| %i   | 分钟                 |
| %s   | 秒                   |
| %p   | PM或AM               |
| %r   | HH:mm:ss PM形式时间  |
| %W   | 周，周名，如 Tuesday |

~~~sql
SET @str = '2022-01-01 12:00:00';
SET @format = '%Y-%m-%d %H:%i:%s';
SET @date = STR_TO_DATE(@str, @format);

mysql> select @date;
+---------------------+
| @date               |
+---------------------+
| 2022-01-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
~~~

**使用UNIX_TIMESTAMP函数将日期转换成时间戳**

在MySQL中，我们可以使用UNIX_TIMESTAMP函数将日期转换成时间戳。该函数的语法如下：

~~~shell
UNIX_TIMESTAMP(date)
~~~

其中，date 是要转换的日期。下面是一些常用的日期表示形式：

- 'YYYY-MM-DD HH:MM:SS'：年-月-日 时:分:秒
- 'YYYYMMDDHHMMSS'：年月日时分秒

具体操作时，我们可以使用以下代码将日期转换成时间戳：

~~~sql
SET @timestamp = UNIX_TIMESTAMP(@date);
~~~

上述代码中，我们将日期 @date 转换成时间戳，并将其赋值给变量 @timestamp。

## 常用的日期时间函数

### 获取当前时间和日期

~~~sql
-- 1、日期(date)函数
返回当前日期：
mysql> select CURDATE(),CURRENT_DATE(),CURRENT_DATE;
+------------+----------------+--------------+
| CURDATE()  | CURRENT_DATE() | CURRENT_DATE |
+------------+----------------+--------------+
| 2023-08-28 | 2023-08-28     | 2023-08-28   |
+------------+----------------+--------------+
1 row in set (0.01 sec)

-- 2、时间(time)函数
mysql> select CURTIME(),CURRENT_TIME(),CURRENT_TIME;
+-----------+----------------+--------------+
| CURTIME() | CURRENT_TIME() | CURRENT_TIME |
+-----------+----------------+--------------+
| 21:24:50  | 21:24:50       | 21:24:50     |
+-----------+----------------+--------------+
1 row in set (0.00 sec)

-- 3、日期和时间函数
mysql> select CURRENT_TIMESTAMP(),CURRENT_TIMESTAMP,LOCALTIME(),LOCALTIME,LOCALTIMESTAMP(),LOCALTIMESTAMP,NOW(),SYSDATE()\G
*************************** 1. row ***************************
CURRENT_TIMESTAMP(): 2023-08-28 21:26:11
  CURRENT_TIMESTAMP: 2023-08-28 21:26:11
        LOCALTIME(): 2023-08-28 21:26:11
          LOCALTIME: 2023-08-28 21:26:11
   LOCALTIMESTAMP(): 2023-08-28 21:26:11
     LOCALTIMESTAMP: 2023-08-28 21:26:11
              NOW(): 2023-08-28 21:26:11
          SYSDATE(): 2023-08-28 21:26:11
1 row in set (0.00 sec)
~~~



### NOW(), SYSDATE()的区别

~~~sql
-- NOW()返回执行当前SQL语句的时间：
mysql> select now(),sleep(2),now();
+---------------------+----------+---------------------+
| now()               | sleep(2) | now()               |
+---------------------+----------+---------------------+
| 2023-08-28 21:28:18 |        0 | 2023-08-28 21:28:18 |
+---------------------+----------+---------------------+
1 row in set (2.00 sec)

-- SYSDATE()返回执行当前函数的时间：
mysql> select sysdate(),sleep(2),sysdate();
+---------------------+----------+---------------------+
| sysdate()           | sleep(2) | sysdate()           |
+---------------------+----------+---------------------+
| 2023-08-28 21:29:17 |        0 | 2023-08-28 21:29:19 |
+---------------------+----------+---------------------+
1 row in set (2.00 sec)

-- SYSDATE()可以传入一个参数:fsp 表示是否包括小数秒精度（0~6位）
mysql> select sysdate(),sysdate(6);
+---------------------+----------------------------+
| sysdate()           | sysdate(6)                 |
+---------------------+----------------------------+
| 2023-08-28 21:31:27 | 2023-08-28 21:31:27.087888 |
+---------------------+----------------------------+
1 row in set (0.00 sec)
~~~

### 日期和时间比较

Mysql中可以直接用字符串进行比较时间大小， 只要你的日期格式是合法的就行

~~~sql
mysql> select '2023-08-28 21:31:27' > '2023-08-29 21:31:27';
+-----------------------------------------------+
| '2023-08-28 21:31:27' > '2023-08-29 21:31:27' |
+-----------------------------------------------+
|                                             0 |
+-----------------------------------------------+
1 row in set (0.01 sec)

mysql> select '2023-08-28 21:31:27' < '2023-08-29 21:31:27';
+-----------------------------------------------+
| '2023-08-28 21:31:27' < '2023-08-29 21:31:27' |
+-----------------------------------------------+
|                                             1 |
+-----------------------------------------------+
1 row in set (0.00 sec)


mysql> select '21:31:27' > '22:31:27';
+-------------------------+
| '21:31:27' > '22:31:27' |
+-------------------------+
|                       0 |
+-------------------------+
1 row in set (0.00 sec)

mysql> select '21:31:27' < '22:31:27';
+-------------------------+
| '21:31:27' < '22:31:27' |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)
~~~



### 日期和时间运算

~~~sql
-- DATE_ADD()函数：日期时间增加减少
select now(),DATE_ADD(now(),INTERVAL 1 year);
select now(),DATE_ADD(now(),INTERVAL -1 year);
select now(),DATE_ADD(now(),INTERVAL 1 quarter);
select now(),DATE_ADD(now(),INTERVAL 1 month);
select now(),DATE_ADD(now(),INTERVAL 1 week);
select now(),DATE_ADD(now(),INTERVAL 1 day);
select now(),DATE_ADD(now(),INTERVAL 1 hour);
select now(),DATE_ADD(now(),INTERVAL 1 minute);
select now(),DATE_ADD(now(),INTERVAL 1 second);
select now(),DATE_ADD(now(),INTERVAL 1 microsecond);

-- DATEDIFF()函数：计算两个日期差 
mysql> select DATEDIFF(now(),DATE_ADD(now(),INTERVAL 1 year));
+-------------------------------------------------+
| DATEDIFF(now(),DATE_ADD(now(),INTERVAL 1 year)) |
+-------------------------------------------------+
|                                            -366 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select DATEDIFF(DATE_ADD(now(),INTERVAL 1 year),now());
+-------------------------------------------------+
| DATEDIFF(DATE_ADD(now(),INTERVAL 1 year),now()) |
+-------------------------------------------------+
|                                             366 |
+-------------------------------------------------+
1 row in set (0.00 sec)


-- TIMEDIFF()函数：计算两个时间差
mysql> select TIMEDIFF(now(),DATE_ADD(now(),INTERVAL 1 minute));
+---------------------------------------------------+
| TIMEDIFF(now(),DATE_ADD(now(),INTERVAL 1 minute)) |
+---------------------------------------------------+
| -00:01:00                                         |
+---------------------------------------------------+
1 row in set (0.00 sec)

mysql> select TIMEDIFF(DATE_ADD(now(),INTERVAL 1 minute),now());
+---------------------------------------------------+
| TIMEDIFF(DATE_ADD(now(),INTERVAL 1 minute),now()) |
+---------------------------------------------------+
| 00:01:00                                          |
+---------------------------------------------------+
1 row in set (0.01 sec)
~~~

### 日期和时间的格式化

~~~sql
-- DATE_FORMAT(date,format)函数

DATE_FORMAT(SYSDATE(),'%Y-%m-%d %H:%i:%s')
~~~

常用格式

| 格式 | 说明                                     |
| ---- | ---------------------------------------- |
| %Y   | 四位数的年份                             |
| %m   | 月份                                     |
| %d   | 日期                                     |
| %H   | 小时                                     |
| %i   | 分钟                                     |
| %s   | 秒                                       |
| %p   | PM或AM                                   |
| %r   | HH:mm:ss PM形式时间                      |
| %w   | 周，0-6, 0为周日                         |
| %W   | 周，周名，如 Tuesday                     |
| %j   | 当前日期所在一年中的天数，3位（001-366） |

~~~sql
-- DATE_FORMAT(date,format) 函数
将数据库中的date数据格式化为String类型


-- STR_TO_DATE(str,format) 函数：
将指定的时间格式的字符串按照格式转换为DATETIME类型的值。str要与format的格式保持一致，否则会报错。
~~~

### YEAR()函数

取日期时间的年份

~~~sql
mysql> select year(now());
+-------------+
| year(now()) |
+-------------+
|        2023 |
+-------------+
1 row in set (0.00 sec)
~~~







## 动态SQL拼接

https://www.shuzhiduo.com/A/kvJ3g0RAJg/
https://blog.csdn.net/weixin_35020039/article/details/113656384

## 拼接sql删除索引和自增主键

~~~shell
--删除普通索引
select concat('drop index ',t2.name,' on ',SUBSTRING_INDEX(t1.NAME,'/',-1),';') 
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name not in('GEN_CLUST_INDEX', 'PRIMARY');

--删除自增属性
select concat('alter table ',TABLE_NAME,' modify ',COLUMN_NAME,' ',DATA_TYPE,';') from information_schema.COLUMNS 
where TABLE_SCHEMA='sysbenchdb' and TABLE_NAME regexp 'sbtest' and EXTRA regexp 'auto_increment';

--删除主键
select concat('alter table ',SUBSTRING_INDEX(t1.NAME,'/',-1),' drop primary key;') from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name = 'PRIMARY';


--将查询导出为sql文件
select concat('drop index ',t2.name,' on ',SUBSTRING_INDEX(t1.NAME,'/',-1),';') 
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name not in('GEN_CLUST_INDEX', 'PRIMARY') into outfile '/tmp/drop_index1.sql';

--执行SQL文件
mysql -uroot -prootroot -Dsysbenchdb < /tmp/drop_index1.sql &
~~~

## 解决Navicat设置自动提交无效处理

~~~shell
--解决Navicat设置自动提交无效处理
set global init_connect="set autocommit=1";
set global autocommit="on";
~~~

# 性能优化

SQL优化最干货总结 - MySQL（2020最新版）
https://blog.csdn.net/qq_39390545/article/details/107020686

MySQL的limit分页查询进行优化

http://hz.itheima.com/news/20230508/152151.html

MySQL优化原理分析及优化方案总结

https://zhuanlan.zhihu.com/p/603279860?utm_id=0



# 数据库初始化

~~~shell
#Windows
mysqld --defaults-file=d:\mysql\data\my.ini --initialize --basedir=d:\mysql\mysql57 --datadir=d:\mysql\data\data
#把MySQL服务安装到Windows系统里面去
mysqld -install mysql57 --defaults="d:\mysql\data\my.ini"
#删除添加的mysql服务
mysqld -remove mysql57
#服务启停
net start/stop mysql57
~~~

# 插件安装

在MySQL中，您可以通过INSTALL PLUGIN语句来安装插件。但在安装插件之前，您通常需要确保有相关的插件共享库文件，并确保MySQL的plugin_dir系统变量正确指向共享库文件所在的目录。
以下是一个简化的步骤来安装MySQL插件：
1.获取插件:
2.首先，您需要从合适的来源下载或编译您所需的插件。这通常是一个.so（在Unix-like系统上）或.dll（在Windows上）的共享库文件。
3.放置共享库文件:
4.将该共享库文件复制到MySQL的插件目录中。您可以通过执行以下命令查找此目录：

~~~shell
SHOW VARIABLES LIKE 'plugin_dir';
~~~

5.安装插件:
使用INSTALL PLUGIN语句。例如，如果您要安装名为myplugin的插件，则可以执行：

~~~shell
INSTALL PLUGIN myplugin SONAME 'myplugin.so';
~~~

注意: 在Windows上，您将使用.dll后缀而不是.so。
6.验证插件已安装:
可以查询information_schema.plugins表来确认：

~~~shell
SELECT * FROM information_schema.plugins WHERE plugin_name = 'myplugin';
~~~

7.如果需要，配置插件:
根据插件的文档，可能需要进行进一步的配置或初始化步骤。
8.卸载插件:
如果您需要在以后卸载插件，可以使用：

~~~shell
UNINSTALL PLUGIN myplugin;
~~~

注意：
9.在安装任何插件之前，请确保从可靠的来源获取它，并确保它与您的MySQL版本兼容。
10.有些插件可能需要特定的MySQL配置或系统库。务必阅读并遵循插件的文档。
11.在生产环境中安装插件之前，建议在开发或测试环境中首先进行测试。
