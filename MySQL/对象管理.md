# 对象信息查询

~~~sql
#列出 MySQL 数据库管理系统的数据库列表。
SHOW DATABASES;
#显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。
SHOW TABLES;
#显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。
SHOW COLUMNS FROM 数据表;
#显示数据表的详细索引信息，包括PRIMARY KEY（主键）
SHOW INDEX FROM 数据表;
#显示表结构
desc 数据表;


#获得当前数据库(catalog)和schema
select current_database();
select current_schema();
#查询表上的索引信息（mysql8.0的innodb表）
select t1.NAME as table_name,t2.name as index_name
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name <> 'GEN_CLUST_INDEX';


#将查询结果导出到指定文件
#需要注意只能把文件导出到secure_file_priv参数的路径下
mysql> show variables like 'secure%';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv | /tmp/ |
+------------------+-------+
1 row in set (0.00 sec)

select concat('drop index ',name,' on sbtest', mid(name,3,3),';') FROM information_schema.INNODB_INDEXES where name like  'k%' into outfile '/tmp/drop_index1.sql';
#执行sql文件命令
mysql -uroot -prootroot -Dsysbenchdb < /tmp/drop_index1.sql &



#查schema下有什么表
--查询当前schema下有什么表（方法一）
select * from pg_tables where schemaname=current_schema();
-- 查询当前schema下有什么表（方法二）
SELECT *
FROM information_schema.tables
WHERE table_catalog=current_database() and table_schema = current_schema();
-- 判断表是否存在(方法一)
select tablename from pg_tables where schemaname=current_schema() and tablename='communication'
-- 判断表是否存在(方法二)
SELECT table_name
FROM information_schema.tables
WHERE table_catalog=current_database() and table_schema=current_schema() and table_name='communication'

#查表有什么字段
-- 查询表有什么列（字段信息，含类型等等）
SELECT *
FROM information_schema.columns
WHERE table_catalog=current_database() and table_schema = current_schema() and table_name = 'communication';
-- 判断某列是否存在
SELECT column_name
FROM information_schema.columns
WHERE table_catalog=current_database() and table_schema = current_schema() and table_name = 'communication'and column_name='dr';



#查看数据库下有哪些表和视图
select table_schema,table_name,table_type from information_schema.tables where table_schema='sakila';
#查看数据库下有哪些视图
select table_schema,table_name from information_schema.views where table_schema='sakila';
#查看数据库下有哪些函数和存储过程
select routine_schema,routine_name from information_schema.routines where routine_schema='sakila';
#查看数据库下有哪些触发器
select trigger_schema,trigger_name from information_schema.triggers where trigger_schema='sakila';
#查看约束信息
select constraint_schema,constraint_name,table_schema,table_name,constraint_type from information_schema.table_constraints where constraint_schema = 'sakila';



#查表有什么索引
--查询表有什么索引
SELECT *
FROM pg_indexes
WHERE schemaname = current_schema() AND tablename = 'communication';
--判断索引是否存在
SELECT indexname
FROM pg_indexes
WHERE schemaname = current_schema() AND tablename = 'communication' AND
indexname = 'idx_table_name';


#查主键的名字（含是否存在主键）
--判断主键名字是什么，查无记录表示无主键（改一下relname的值，contype不需要改，p表示主键）
SELECT
    pg_constraint.conname AS pk_name
FROM
    pg_constraint
INNER JOIN pg_class ON pg_constraint.conrelid = pg_class.oid
WHERE
    pg_class.relname = 'my_table'
AND pg_constraint.contype = 'p';


#分区表查询
select distinct TABLE_NAME
from information_schema.PARTITIONS
where TABLE_SCHEMA=SCHEMA() and partition_name is not null;



-- 查看某个数据库多大
select concat(round(sum(data_length/1024/1024),2),'MB') as data from information_schema .tables where table_schema='source_testdb';

 
-- 数据库 mysql 库表以及索引大小查询
 
-- 查看指定库的大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS DATA  FROM TABLES WHERE table_schema='testschema';
-- 查看指定库的指定表的大小
SELECT CONCAT(ROUND(SUM(DATA_LENGTH/1024/1024),2),'MB') AS DATA  FROM TABLES WHERE table_schema='testschema' AND table_name='t_syt_keyword_off_rep';
-- 查看指定库的索引大小
SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), ' MB') AS 'Total Index Size' FROM TABLES  WHERE table_schema = 'testschema'; 
-- 查看指定库的指定表的索引大小
SELECT CONCAT(ROUND(SUM(index_length)/(1024*1024), 2), ' MB') AS 'Total Index Size' FROM TABLES  WHERE table_schema = 'testschema' AND table_name='tab_user'; 
 
 
-- 1.查看指定库数据和索引大小总和
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS total_data FROM information_schema.TABLES WHERE table_schema = 'testschema';
 
-- 2.查看所有库数据和索引大小总和
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS total_data FROM information_schema.TABLES;
 
-- 3.查看指定数据库的某个表
SELECT CONCAT(ROUND(SUM((data_length+index_length)/1024/1024),2),'MB') AS DATA FROM TABLES WHERE table_schema='testschema' AND table_name='tab_user';
 
-- 4.查询一个库中每个表的数据大小，索引大小和总大小
SELECT
CONCAT(a.table_schema,'.',a.table_name),
CONCAT(ROUND(table_rows/1000,4),'KB') AS 'Number of Rows',
CONCAT(ROUND(data_length/(1024*1024),4),',') AS 'data_size',
CONCAT(ROUND(index_length/(1024*1024),4),'M') AS 'index_size',
CONCAT(ROUND((data_length+index_length)/(1024*1024),4),'M') AS'Total'
FROM
information_schema. TABLES a
WHERE
a.table_schema = 'testschema';
~~~

# 数据库的创建与管理

## 数据库命名规范

- 数据库名不能超过30个字符,推荐使用下划线命名方式。
- 数据库命名必须为项目英文名称或有意义的简写。
- 数据库创建时必须添加默认字符集和校对规则子句。
- 命名应使用小写。

## 字符集的选择

- 自开发系统的数据库Utf8作为字符集的惟一选择,默认字符集为UTF8,

  建议：统一使用utf8字符集和utf8_general_ci字符排序规则,按需对表级设置utf8mb4

- 外购系统的字符集按照开发和业务要求选择,需申请例外。

- 使用工具导出的数据脚本文件,必须在导出工具中,显式选择utf8作为导出格式。

- 在恢复前需要编辑,必须使用纯文本方式打开,编辑和保存,防止隐含控制字符(如^M)添加进脚本。在Linux环境,可以通过"cat-A脚本文件名"方式确认和检查是否携带了隐含控制字符。

**备注：**

> utf_general_ci不区分大小写，utf_general_cs区分大小写，utf8_bin二进制
> Unicode 万国码/统一码/单一码：ucs2，utf16，utf16le，utf8，utf8mb4，utf32
> utf8：1字符占用1~3个字节：升级老系统推荐使用
> utf8mb4：1字符占用1~4个字节：新系统使用

## 数据库设计规范

- 控制单实例表个数控制在3w以内
- 控制单库表个数，建议单库不超过4096个表
- 创建数据库的语句必须包含字符集子句和校对规则子句。如：

~~~shell
create database testdb [if not exists] default character set UTF8 default collate utf8_general_ci;
~~~



# 用户管理

## 用户创建

~~~sql
-- 5.7授权即创建
-- root可以用户从任何主机（%）访问所有数据库（第一个*）的所有对象（第二个*），同时可以把权限授予给其他用户
grant all privileges on *.* to 'root'@'%' identified by 'rootroot' with grant option;
flush privileges;

-- 创建用户
CREATE USER 'root'@'%' IDENTIFIED BY 'rootroot';
~~~

## 修改用户密码

~~~sql
-- 使用修改参数方式修改密码
set password=password('rootroot');


use mysql
-- 直接更新系统表
update user set authentication_string=password("root") where user="root";
flush privileges;

-- 使用命令修改
ALTER USER 'root'@'localhost' IDENTIFIED BY 'rootroot';
~~~



## 授权用户远程登录

~~~sql
#MySQL5.7.X
use mysql
select host,user from user where user='root';
grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;
flush privileges;
select host,user from user where user='root';



#MySQL8.0.X
use mysql
select host,user from user where user='root';
CREATE USER 'root'@'%' IDENTIFIED BY 'rootroot';
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;
select host,user from user where user='root';

https://blog.csdn.net/JineD/article/details/106990089
~~~

## 密码过期处理

~~~shell
#1、添加参数skip-grant-tables（跳过权限表）
cat >> /mysql/data/3306/my.cnf << "EOF"
skip-grant-tables
EOF
#2、重启mysql
service mysql stop
service mysql start
#3、连接数据库（不用输入密码），修改密码为不过期
mysql -uroot -p
use mysql
select host,user, password_expired from mysql.user where user='root';
update user set password_expired='N' where user='root';
flush privileges;
ALTER USER 'root'@'localhost' IDENTIFIED BY 'rootroot';
#4、改回配置删除参数skip-grant-tables
sed -i '/^skip-grant-tables/d' /mysql/data/3306/my.cnf
#5、重启mysql
service mysql stop
service mysql start
~~~











# 权限管理



# 表

## 普通表

### 创建表

~~~sql
CREATE TABLE dept (
	deptno INT auto_increment PRIMARY KEY,
	dname VARCHAR ( 15 ),
loc VARCHAR ( 50 ) 
) engine = INNODB;
insert into dept values (1,'it','bj');
insert into dept values (2,'cw','sh');
insert into dept values (3,'hr','sz');
commit;
select * from dept;
~~~

### 生成列

**前言**

- 索引（index） 在SQL中可以大大提高 查询效率。
- SQL索引列中，如果使用了运算和函数，索引将无法生效。
- 如果索引列的数据量大且稳定，可以使用 生成列 来固定对索引列的计算和函数运算，并对该生成列添加索引提高查询效率。

**如何创建生成列**

CREATE TABLE支持生成列的规范。根据列定义中包含的表达式计算生成列的值。

NDB从MySQL NDB Cluster 7.5.3开始，存储引擎 支持生成列 。

```sql
-- 通过sidea和sideb列中直角三角形的边的长度 ，并计算下斜边的长度 sidec（其他边的平方和的平方根）：
CREATE TABLE triangle (
  sidea DOUBLE,
  sideb DOUBLE,
  sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb))
);
INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8);

mysql> select * from triangle;
+-------+-------+--------------------+
| sidea | sideb | sidec              |
+-------+-------+--------------------+
|     1 |     1 | 1.4142135623730951 |
|     3 |     4 |                  5 |
|     6 |     8 |                 10 |
+-------+-------+--------------------+
3 rows in set (0.00 sec)
```

使用该triangle表的任何应用程序都可以访问斜边值，而无需指定计算它们的表达式，减少了了表达式计算过程中资源消耗。

**生成列定义**

```sql
col_name data_type [GENERATED ALWAYS] AS (expr)
  [VIRTUAL | STORED] [NOT NULL | NULL]
  [UNIQUE [KEY]] [[PRIMARY] KEY]
  [COMMENT 'string']
```

AS (expr) 表示已生成列，并定义了用于计算列值的表达式。

AS 可以在前面GENERATED ALWAYS使列的生成的性质更明确。

**VIRTUAL 或 STORED 关键字**

表示列的值的存储方式，其具有用于使用列含义：

1. VIRTUAL：不存储列值，但在任何BEFORE触发器之后立即读取行时对其进行求值 。虚拟列不占用任何存储空间。

   InnoDB支持虚拟列上的二级索引。

2. STORED：插入或更新行时，将评估并存储列值。存储的列确实需要存储空间，并且可以建立索引。

3. 默认值是VIRTUAL如果未指定任何关键字。

4. 它允许混合VIRTUAL和 STORED表中的列。

5. 可以赋予其他属性以指示该列是索引还是可以为NULL，或提供注释

**生成列表达式必须遵守以下规则**

1. 如果表达式包含不允许的构造，则会发生错误：

   允许使用文字，确定性内置函数和运算符。如果给定表中的数据相同，且独立于所连接的用户(?)，如果多次调用产生相同的结果，则该函数为确定性函数。如果是不确定性函数则会创建失败，例如：CONNECTION_ID()， CURRENT_USER()， NOW()。
   不允许使用存储函数和用户自定义函数。
   不允许使用存储过程和函数参数。
   不允许使用变量（系统变量，用户定义的变量和存储的程序局部变量）。
   不允许子查询。
   生成列定义可以引用其他生成列，但只能引用表定义中较早出现的列。生成列定义可以引用表中的任何基础（未生成）列，无论其定义是更早还是更晚。
   该AUTO_INCREMENT属性不能在生成列定义中使用。
   一个AUTO_INCREMENT列不能用作在生成列定义的基础列。
   从MySQL 5.7.10开始，如果表达式求值导致截断或向函数提供错误的输入，则该 CREATE TABLE语句将以错误终止并拒绝DDL操作。

2. 如果表达式求值的数据类型不同于声明的列类型，则根据通常的MySQL类型转换规则，对声明的类型进行隐式强制转换。

   <font color = 'red' > 如果表达式的任何部分取决于SQL模式，则表的不同用法可能会产生不同的结果，除非在所有用法中SQL模式都相同。 </font>

3. 对于CREATE TABLE ... LIKE，目标表保留从原始表生成列信息。

4. 对于CREATE TABLE ... SELECT，目标表不会保留有关selected-from表中的列是否是生成列的信息。SELECT语句不能为目标表中的生成列分配值。

5. 允许按生成列进行分区

6. 在存储生成列外键约束不能使用 CASCADE，SET NULL或 SET DEFAULT作为ON UPDATE 参照动作，也不能使用SET NULL 或SET DEFAULT作为ON DELETE参照动作。

7. 在存储生成列的基本列外键约束不能使用CASCADE， SET NULL或SET DEFAULT 作为ON UPDATE或ON DELETE 引用操作。

8. 外键约束不能引用虚拟生成列

9. 触发器不能使用 或用于 引用生成列。 NEW.col_nameOLD.col_name

10. 对于INSERT， REPLACE和 UPDATE，如果将生成列显式插入，替换或显式更新，则唯一允许的值为DEFAULT

11. 视图中的生成列被认为是可更新的，因为可以对其进行分配。但是，如果明确更新了该列，则唯一允许的值为 DEFAULT



**生成列用例**

例如：

1. 虚拟生成列可以用作简化和统一查询的方法。可以将复杂条件定义为生成列，并从表上的多个查询中引用该条件，以确保所有条件都使用完全相同的条件。
2. 存储的生成列可用作复杂条件的物化缓存，这些条件需要快速计算。
3. 生成列可以模拟功能索引：使用生成列定义功能表达式并为其编制索引。这对于处理无法直接索引的类型的列（例如，JSON列）很有用 。
4. 对于存储的生成列，此方法的缺点是值存储两次。一次作为生成列的值，一次作为索引。
5. 如果为生成列建立索引，则优化器将识别与列定义匹配的查询表达式，并在查询执行期间适当地使用该列中的索引，即使查询未按名称直接引用该列也是如此。

```sql
-- MySQL支持在生成列上建立索引
CREATE TABLE t1 (f1 INT, gc INT AS (f1 + 1) STORED, INDEX (gc));
```



**alter 生成列**

ALTER TABLE允许生成列操作是ADD， MODIFY，和CHANGE。

```sql
-- 1.可以添加生成列。
CREATE TABLE t1 (c1 INT);
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;

-- 2.可以修改生成列的数据类型和表达式。
CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 TINYINT GENERATED ALWAYS AS (c1 + 5) STORED;

-- 3.如果没有其他列引用生成列，则可以重命名或删除它们。
CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 CHANGE c2 c3 INT GENERATED ALWAYS AS (c1 + 1) STORED;
ALTER TABLE t1 DROP COLUMN c3;

-- 4.虚拟生成列不能更改为存储的生成列，
-- 反之亦然。要解决此问题，请删除该列，然后添加新定义。
CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) VIRTUAL);
ALTER TABLE t1 DROP COLUMN c2;
ALTER TABLE t1 ADD COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;

-- 5.可以将未生成列更改为存储的，但不能更改为虚拟生成列。
CREATE TABLE t1 (c1 INT, c2 INT);
ALTER TABLE t1 MODIFY COLUMN c2 INT GENERATED ALWAYS AS (c1 + 1) STORED;

-- 6.可以将已存储但不是虚拟生成列更改为未生成列。 存储的生成的值成为非生成列的值。
CREATE TABLE t1 (c1 INT, c2 INT GENERATED ALWAYS AS (c1 + 1) STORED);
ALTER TABLE t1 MODIFY COLUMN c2 INT;

-- 7.ADD COLUMN不是对存储的列的就地操作
（无需使用临时表即可完成），因为表达式必须由服务器评估。对于存储的列，索引更改已就位，而表达式更改未就位。列注释的更改已就位。

-- 8、对于非分区表，ADD COLUMN 和DROP COLUMN是虚拟列的就地操作。
但是，添加或删除虚拟列不能与其他ALTER TABLE操作结合使用。

-- 9.对于分区表，ADD COLUMN和 DROP COLUMN没有对虚拟列就地操作。

-- 10.InnoDB支持虚拟生成列上的二级索引。在虚拟生成列上添加或删除二级索引是就地操作。

-- 11.当将VIRTUAL生成列添加到表中或对其进行修改时，不能确保生成列表达式所计算的数据不会超出该列的范围。这可能导致返回不一致的数据以及意外失败的语句。为了允许控制是否对此类列，ALTER TABLE支持 WITHOUT VALIDATION和WITH VALIDATION子句进行验证：

使用WITHOUT VALIDATION（如果未指定任何子句，则为默认值），将执行就地操作（如果可能），不检查数据完整性，并且语句执行更快。但是，如果值超出范围，以后从表中读取数据可能会报告该列的警告或错误。
使用WITH VALIDATION，ALTER TABLE复制表。如果发生超出范围的错误或任何其他错误，该语句将失败。因为执行了表复制，所以语句花费的时间更长。
WITHOUT VALIDATION并且WITH VALIDATION只有被允许ADD COLUMN，CHANGE COLUMN和 MODIFY COLUMN操作。否则，将 ER_WRONG_USAGE发生错误。


-- 12.从MySQL 5.7.10开始，如果表达式求值导致截断或向函数提供错误的输入，则该 ALTER TABLE语句将以错误终止并拒绝DDL操作。

ALTER TABLE更改列的默认值 的语句也 col_name可能会更改使用引用该列的生成列表达式的值 。
因此，从MySQL 5.7.13开始， 如果任何生成列表达式使用，则更改列定义的操作将导致表重建 。
```





### 复制表

**非同库实现方案**

在目标数据库中创建一个与源表结构相同的新表：

~~~sql
CREATE TABLE 目标库名.新表名 LIKE 源库名.原表名;
~~~

这将在目标数据库中创建一个名为 “新表名” 的新表，其结构与源数据库中的 “原表名” 相同。

将源表的数据插入到目标表中：

~~~sql
INSERT INTO 目标库名.新表名 SELECT * FROM 源库名.原表名;
~~~

这将从源表中选择所有数据，并将其插入到目标表中。



**同库复制表**

~~~sql
CREATE TABLE 新表名 LIKE 原表名;
INSERT INTO 新表名 SELECT * FROM 原表名;
~~~

## 分区表

[MySQL分区表.md](./MySQL分区表.md)

# 索引

创建索引

~~~sql
ALTER TABLE users ADD INDEX index_age(age);
-- 或
create index index_age on users(age);
~~~



表的索引信息查询

~~~sql
show index from user;
~~~



# 约束

## 外键

```sql
-- 创建外键
alter table tpl_aclentry_t add constraint tpl_aclentry_t_fk foreign key(role_id) references tpl_role_t(role_id)
on delete no action on update no action;
-- 删除外键
alter table 表名 drop foreign key 外键名;
```



# 数据类型

## json

**创建测试表**

~~~sql
-- 新建表
DROP TABLE IF EXISTS my_json_test;
CREATE TABLE my_json_test(
	json_id INT NOT NULL COMMENT '对象id',
	json_content JSON NULL COMMENT '对象名称',
	UNIQUE(json_id)
)
ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = 'json测试表' ROW_FORMAT = Dynamic;


-- 插入两条测试数据, 不保证顺序
INSERT INTO my_json_test(json_id, json_content) VALUES(1, '{"id": 10001, "name": "测试1", "remark": "测试备注1"}');
INSERT INTO my_json_test(json_id, json_content) VALUES(2, '{"id": 10002, "name": "测试2", "remark": "测试备注2"}');

mysql> SELECT * FROM my_json_test;
+---------+-------------------------------------------------------------+
| json_id | json_content                                                |
+---------+-------------------------------------------------------------+
|       1 | {"id": 10001, "name": "测试1", "remark": "测试备注1"}       |
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}       |
+---------+-------------------------------------------------------------+
2 rows in set (0.00 sec)
~~~

**增删改**

~~~sql
-- 新增: 给JSON中添加属性
UPDATE my_json_test SET json_content = JSON_INSERT(json_content,'$.passwd','333') WHERE json_id = 1;

mysql> SELECT * FROM my_json_test;
+---------+------------------------------------------------------------------------------+
| json_id | json_content                                                                 |
+---------+------------------------------------------------------------------------------+
|       1 | {"id": 10001, "name": "测试1", "passwd": "333", "remark": "测试备注1"}       |
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}                        |
+---------+------------------------------------------------------------------------------+
2 rows in set (0.00 sec)


-- 删除: 删除JSON中的属性, 可连续删除多个
UPDATE my_json_test SET json_content = JSON_REMOVE(json_content,'$.passwd') WHERE json_id = 1;

mysql> SELECT * FROM my_json_test;
+---------+-------------------------------------------------------------+
| json_id | json_content                                                |
+---------+-------------------------------------------------------------+
|       1 | {"id": 10001, "name": "测试1", "remark": "测试备注1"}       |
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}       |
+---------+-------------------------------------------------------------+
2 rows in set (0.00 sec)

-- 更新 JSON字段的属性值, 使用 JSON_SET(JSON类型的属性名称, JSON里要修改的属性名, 要修改成的值)
UPDATE my_json_test SET json_content = JSON_SET(json_content,'$.passwd', "444") WHERE json_extract(json_content,'$.id') = 10001;

mysql> SELECT * FROM my_json_test;
+---------+------------------------------------------------------------------------------+
| json_id | json_content                                                                 |
+---------+------------------------------------------------------------------------------+
|       1 | {"id": 10001, "name": "测试1", "passwd": "444", "remark": "测试备注1"}       |
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}                        |
+---------+------------------------------------------------------------------------------+
2 rows in set (0.00 sec)
~~~



**查询**

~~~sql
-- 使用 字段 '$.json属性' 进行查询条件
mysql> SELECT * FROM my_json_test WHERE json_content->'$.id' = 10002;
+---------+-------------------------------------------------------------+
| json_id | json_content                                                |
+---------+-------------------------------------------------------------+
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}       |
+---------+-------------------------------------------------------------+
1 row in set (0.00 sec)


-- 用json_extract函数查询，json_extract(字段, '$.json属性') 查询
mysql> SELECT * FROM my_json_test WHERE JSON_EXTRACT(json_content,'$.name') = '测试1';
+---------+------------------------------------------------------------------------------+
| json_id | json_content                                                                 |
+---------+------------------------------------------------------------------------------+
|       1 | {"id": 10001, "name": "测试1", "passwd": "444", "remark": "测试备注1"}       |
+---------+------------------------------------------------------------------------------+
1 row in set (0.00 sec)


-- 模糊查询
mysql> SELECT * FROM my_json_test WHERE  json_content->'$.name' LIKE '%2%'; 
+---------+-------------------------------------------------------------+
| json_id | json_content                                                |
+---------+-------------------------------------------------------------+
|       2 | {"id": 10002, "name": "测试2", "remark": "测试备注2"}       |
+---------+-------------------------------------------------------------+
1 row in set (0.00 sec)


-- 投影、映射 查询指定JSON字段
mysql> SELECT json_content->'$.id' AS id,json_content->'$.name' AS `name` FROM my_json_test WHERE json_content->'$.id' = 10002;
+-------+-----------+
| id    | name      |
+-------+-----------+
| 10002 | "测试2"   |
+-------+-----------+
1 row in set (0.00 sec)


-- 注意: 这里查询有个问题, 查询到的数据包含引号, 去掉引号方法如下: https://blog.csdn.net/springhub/article/details/129258588


-- ①>> 双箭头 ②JSON_UNQUOTE(json_content->'$.name')函数	③TRIM
mysql> SELECT json_content->'$.id' AS id,json_content->>'$.name' AS `name` FROM my_json_test WHERE json_content->'$.id' = 10002;
+-------+---------+
| id    | name    |
+-------+---------+
| 10002 | 测试2   |
+-------+---------+
1 row in set (0.01 sec)


-- 包含关系: 判断JSON类型的字段中是否包含某个值: 用JSON_CONTAINS(字段,JSON_OBJECT('json属性', "内容"))
mysql> SELECT JSON_CONTAINS(json_content, JSON_OBJECT('name', '测试')) FROM my_json_test WHERE json_id = 1;
+------------------------------------------------------------+
| JSON_CONTAINS(json_content, JSON_OBJECT('name', '测试'))   |
+------------------------------------------------------------+
|                                                          0 |
+------------------------------------------------------------+
1 row in set (0.00 sec)
~~~



**计数和分组**

https://www.qyyshop.com/info/885007.html



**创建索引**

~~~sql
ALTER Table my_json_test ADD INDEX myjtjcny( ( CAST( json_content -> '$[*].id' as UNSIGNED ARRAY) );
~~~



Mysql为json字段创建索引的两种方式

https://blog.csdn.net/weixin_43888891/article/details/130419850

MySQL创建JSON数据的索引

https://blog.csdn.net/BREATH57/article/details/129320951

实现MySQL JSON数组索引的步骤

https://blog.51cto.com/u_16175438/7196894

如何实现MySQL5.7 json 字段索引的具体操作步骤

https://blog.51cto.com/u_16175514/6637519





# 常用命令

~~~sql
--环境IP
192.168.0.127
--启停
service mysql start
service mysql stop

--启动
mysqld_safe --defaults-file=/data/yaokang/mysql/data/3306/my.cnf --user=mysql
--停止
mysqladmin -uroot -p shutdown -S /data/yaokang/mysql/data/3306/mysql.sock
OR
mysqladmin -uroot -prootroot shutdown -S /data/yaokang/mysql/data/3306/mysql.sock


--外部执行命令
mysql -uhr -phr -h 192.168.1.64 hr -e 'select * from employees;'

--root用户连接
mysql -uroot -prootroot
--报错处理
ERROR 2002 (HY000): Can not connect to local MySQL server through socket '/tmp/mysql.sock' (2)
ln -s /data/yaokang/mysql/data/3306/mysql.sock /tmp
OR
mysql -uroot -p -S /data/yaokang/mysql/data/3306/mysql.sock



--在线迁移的数据库和用户
create database source_testdb;
use source_testdb
create user 'usr_replica'@'%' identified by 'Test_123';
grant all on *.* to 'usr_replica'@'%' identified by 'Test_123';
grant reload on *.* to 'usr_replica';
grant replication client on *.* to 'usr_replica';
grant replication slave on *.* to 'usr_replica';
flush privileges;

set global init_connect="set autocommit=1";
SHOW GLOBAL VARIABLES LIKE 'init_connect';
SHOW VARIABLES LIKE '%log_bin%';



--枚举类型表
CREATE TABLE IF NOT EXISTS `enum_set_test` (
`user_id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户 ID',
`real_name` varchar(20) CHARACTER SET utf8 DEFAULT NULL COMMENT '姓名',
`sex` enum('none','male','female') CHARACTER SET utf8 DEFAULT 'none' COMMENT '性别',
`my_fruit` set('apple','banana','pear','orange','peach','lemon') CHARACTER SET utf8 DEFAULT '' COMMENT '喜欢的水果',
PRIMARY KEY (`user_id`)

)  COMMENT='MYSQL enum set 字段演示';

-- 正在导出表 num_set_test 的数据：14 rows

INSERT INTO `enum_set_test` (`user_id`, `real_name`, `sex`, `my_fruit`) VALUES
(1, '张三', 'none', ''),
(2, '李四', 'male', 'apple,banana'),
(3, '王五', 'male', 'banana,pear,orange'),
(4, '赵六', 'male', 'orange,peach,lemon'),
(5, '程七', 'male', 'banana,orange,lemon'),
(6, '孙九', 'male', 'apple,pear,orange,peach'),
(7, '陈十', 'none', 'apple,pear,peach'),
(8, '张三一', 'none', 'banana,orange,lemon'),
(9, '李四一', 'female', 'apple,banana,pear'),
(10, '王五一', 'female', 'orange,peach,lemon'),
(11, '赵六一', 'female', ''),
(12, '程七一', 'female', 'banana'),
(13, '孙九一', 'female', 'orange'),
(14, '陈十一', 'none', 'apple,banana,pear');

2、enum(枚举类型)查询和更新

可以通过序号方式查询，也可以通过值。# 通过序号查询 姓别

SELECT * from enum_set_test where `sex` = 1; # 对应值 none
SELECT * from enum_set_test where `sex` = 2; # 对应值 male
SELECT * from enum_set_test where `sex` = 3; # 对应值 female

# 通过值查询 姓别

SELECT * from enum_set_test where `sex` = 'none'; # 对应序号 1
SELECT * from enum_set_test where `sex` = 'male'; # 对应序号 2
SELECT * from enum_set_test where `sex` = 'female'; # 对应序号 3
~~~



# 对象创建

~~~shell
#建表、删表 DDL（含自动创建sequence）
--建表（幂等）【不指定主键的名字】
--【主键默认是 "表名_pkey"，即 my_table_pkey】
--【serial或者serial8分别表示int4和int8的，这种写法会自动建sequence，且名字是 "表名_id_seq"，删除表的时候会级联删除该序列】
CREATE TABLE IF NOT EXISTS "my_table"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  PRIMARY KEY ("id")
);
--建表（幂等）【指定主键的名字】
CREATE TABLE IF NOT EXISTS "my_table2"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  CONSTRAINT "custom_name_of_my_table2" PRIMARY KEY ("id")
);


CREATE TABLE `name_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(12) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `year` int(12) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `cs` (`name`,`year`)
);


--删表（幂等）
drop table if exists "data_oss_upload";







#列（增删改列）
--新增列（无法重复执行，无法判断是否已经存在）
alter table "communication" add COLUMN table_name varchar(512);
--删除列（无法重复执行，无法判断字段是否已存在）
alter table "communication" drop column dr;
--修改列类型和精度（可重复执行，只能修改列类型）
alter table "communication" alter column table_name type varchar(500);
--修改列名（不可重复执行，修改列名要用这个）
alter table "communication" rename column table_name to table_name2;
--列名和类型一起修改，结合用上面2句即可，貌似没一句话干两样的



#注释
--对表注释(可重复执行，但需要表存在)
COMMENT ON TABLE "communication" IS '通信表';
--对列注释（可重复执行，但需要表、列存在）
COMMENT ON COLUMN "communication"."id" IS '自增主键';



#索引
--建普通索引（幂等）
CREATE INDEX IF NOT EXISTS "idx_table_name" ON "communication" USING btree (
  "table_name" COLLATE "pg_catalog"."default" "pg_catalog"."bpchar_ops" ASC NULLS LAST
);
--建唯一索引（幂等）
create unique index IF NOT EXISTS data_app_api_app_id_api_no on data_app_api (app_id,api_no);
--删除索引（幂等）
drop INDEX IF EXISTS "idx_table_name";
--修改索引：先删后增即可



#约束（注意别把 CONSTRAINT 写成复数），感觉有部分的约束其实是可以使用index来表示的，使用index以便实现幂等
--新增唯一约束（应该就是唯一索引的另外一种写法）
ALTER TABLE "communication" ADD CONSTRAINT "idx_communication_only" UNIQUE ("ds_id", "table_name", "tenant_id");
--貌似等价于
create unique index IF NOT EXISTS "idx_communication_only" on "communication" ("ds_id", "table_name", "tenant_id");
--新增普通约束（非唯一，也相当于索引）
ALTER TABLE "communication" ADD CONSTRAINT "idx_communication_only"("ds_id", "table_name", "tenant_id");



#主键，表已经建好了，如何新增、修改、删除主键
--新增主键。不指定主键的名字，默认是"表名_pkey"，即 my_table_pkey 【不指定主键名字】
ALTER TABLE "my_table" ADD PRIMARY KEY(id,minute);
--新增主键。指定主键的名字（注意不要写错 ADD CONSTRAINTS）【指定主键名字】
ALTER TABLE "my_table" ADD CONSTRAINT custom_name_of_my_table6666 PRIMARY KEY (id);



--新建表的时候顺带建主键
--创建表的顺带创建主键【不指定主键的名字，默认是 "表名_pkey"，即 my_table_pkey】
CREATE TABLE IF NOT EXISTS "my_table"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  PRIMARY KEY ("id")
);
--创建表的顺带创建主键  【指定主键的名字】
CREATE TABLE IF NOT EXISTS "my_table2"
(
  "id"               SERIAL       NOT NULL,
  "file_id"          varchar(255) NOT NULL,
  "file_name"        varchar(255) NOT NULL,
  "dr"               int2 DEFAULT 0,
  CONSTRAINT "custom_name_of_my_table2" PRIMARY KEY ("id")
);

--删除主键（不知道主键名删不了）
--删除主键【知道名字的情况下】
ALTER TABLE "my_table" DROP CONSTRAINT IF EXISTS my_cons;
--主键名的情况下似乎删不了（可以查主键叫什么名）



#创建序列（sequence）
--创建序列（幂等）【指定从某个值开始】
CREATE SEQUENCE IF NOT EXISTS api_no START 10000;

#创建用户
create user 'test_u'@'%' identified by 'test@123';


#分区表
https://blog.csdn.net/frostlulu/article/details/122304238
https://cloud.tencent.com/developer/article/1408996?from=15425
~~~

# 事件定时器

## 概述

自MySQL5.1.6起，增加了一个非常有特色的功能 - 事件调度器（Event Scheduler），可以用做定时执行某些特定任务（例如：删除记录、数据统计报告、数据备份等等），来取代原先只能由操作系统的计划任务来执行的工作。

值得一提的是MySQL的事件调度器可以精确到每秒钟执行一个任务，而操作系统的计划任务（如：Linux的cron）只能精确到每分钟执行一次。对于一些对数据实时性要求比较高的应用（例如：股票、赔率、比分等）就非常适合。

事件有时也可以称为临时触发器（temporal triggers），因为事件调度器是基于特定时间周期触发来执行某些任务，而触发器（Triggers）是基于某个表所产生的事件触发的，区别也就在这里。

## 开启/关闭/查询事件功能

1、查询功能是否开启：

~~~sql
show variables like 'event_scheduler';
~~~

2、开启、关闭功能命令：

```sql
-- 开启功能命令：
SET GLOBAL event_scheduler = 1;
SET GLOBAL event_scheduler = ON;
-- 关闭功能命令：
SET GLOBAL event_scheduler = 0;
SET GLOBAL event_scheduler = OFF;
```

3、持久化开启方式

```shell
#my.cnf
[mysqld]
event_scheduler=ON 
```

4、查询事件

```sql
-- 查看所有定时任务
SELECT event_name,event_definition,interval_value,interval_field,status FROM information_schema.EVENTS;
-- 查看当前事件：
SHOW EVENTS;
-- 查看指定定时任务创建详细
show create EVENT 事件名称;
```



## 创建事件

### 语法

```sql
CREATE
    [DEFINER={user | CURRENT_USER}]
    EVENT [IF NOT EXISTS] event_name
    ON SCHEDULE schedule
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'comment']
    DO event_body;
```



详细说明

| SQL语法                           | 说明                                                         |
| :-------------------------------- | :----------------------------------------------------------- |
| DEFINER                           | 可选项，给指定用户使用权限                                   |
| IF NOT EXISTS                     | 可选项，用于判断要创建的事件是否存在                         |
| EVENT event_name                  | 必选项，指定事件名称，event_name的最大长度为64个字符，如果为指定event_name，则默认为当前的MySQL用户名（不区分大小写） |
| ON SCHEDULE schedule              | 必选项，这里的schedule用于定义执行的时间和时间间隔，在下面我们详细讲解 |
| ON COMPLETION [NOT] PRESERVE      | 可选项，配置事件执行完一次后的处理方式；当为on completion preserve 的时候,当event到期了,event会被disable,但是该event还是会存在 当为on completion not preserve的时候,当event到期的时候,该event会被自动删除掉. |
| ENABLE、DISABLE、DISABLE ON SLAVE | 可选项，用于指定事件的一种属性。ENABLE表示该事件是开启的，也就是调度器检查事件是否必选调用；DISABLE表示该事件是关闭的，也就是事件的声明存储到目录中，但是调度器不会检查它是否应该调用；DISABLE ON SLAVE表示事件在从机中是关闭的。如果不指定这三个选择中的任意一个，则在一个事件创建之后，它立即变为活动的。 |
| COMMENT ‘comment’                 | 可选项，用于定义事件的注释                                   |
| DO event_body                     | 必选项，用于指定事件启动时所要执行的代码。可以是任何有效的SQL语句、存储过程或者一个计划执行的事件。如果包含多条语句，可以使用BEGIN…END复合结构 |

`schedule` 调度时间配置语法：调度时间配置包括`AT` 和 `EVERY`两种

```sql
AT timestamp [+ INTERVAL interval] ...
  | EVERY interval
    [STARTS timestamp [+ INTERVAL interval] ...]
    [ENDS timestamp [+ INTERVAL interval] ...]


-- INTERVAL中包含的时间单位如下:
{YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
 WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
 DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}
```

**参数说明：**

- AT：表示该事件只执行一次，可以设置一个具体的时间，也可以如图中CURRENT_TIMESTAMP代表当前时间，后面可以加上一个时间间隔interval，表示在这个时间多久以后后事件发生，表示延迟触发时间；
- EVERY：循环执行该事件，其中STARTS子句用于指定开始时间；ENDS子句用于指定结束时间。
- interval：表示从现在开始时间延迟多久以后的一个时间点，其值由一个数值和单位构成。例如，使用“4 WEEK”表示4周后；使用“‘1:10’ HOUR_MINUTE”表示1小时10分钟后。间隔的距离用DATE_ADD()函数来支配。



### 创建 - 单次定时执行事件

```sql
AT TIMESTAMP 时间字符串 [+ INTERVAL INTERVAL]
```

AT TIMESTAMP表示该事件只执行一次，TIMESTAMP表示一个具体的时间点，后面可以加上一个时间间隔，表示在这个时间间隔后事件发生。[+ INTERVAL INTERVAL]表示延迟触发时间；

需要注意的是，TIMESTAMP和具体字符串连用，如果不是具体字符串（如CURRENT_TIMESTAMP取当前时间等），则不加TIMESTAMP;

```sql
-- 示例 1：往demo_1119表中插入一行数据，执行时间：2020-11-20 00:00:00
CREATE EVENT demo_event2 
ON SCHEDULE AT TIMESTAMP '2020-11-20 00:00:00' 
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())

-- 示例 2：往demo_1119表中插入一行数据，执行时间：当前时间往后5个小时；
CREATE EVENT demo_event2 
ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 5 HOUR
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())
```

### 创建 - 循环定时执行事件

```sql
EVERY INTERVAL [STARTS TIMESTAMP] [ENDS TIMESTAMP]
```

`EVERY表示循环执行该事件`，其中`STARTS`子句用于指定开始时间；`ENDS`子句用于指定结束时间。

```sql
-- 示例 1：从当前开始，每10秒往demo_1119表中插入一行数据
CREATE EVENT demo_event3 
ON SCHEDULE EVERY 10 SECOND 
ON COMPLETION PRESERVE 
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())


-- 示例 2：从2020-11-20 12:00:00开始，每10分钟往demo_1119表中插入一行数据
CREATE EVENT demo_event4 
ON SCHEDULE EVERY 10 MINUTE STARTS '2020-11-20 12:00:00' 
ON COMPLETION PRESERVE 
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())

-- 示例 3：从当前时间一小时后开始，每10分钟往demo_1119表中插入一行数据
CREATE EVENT demo_event5 
ON SCHEDULE EVERY 10 MINUTE STARTS CURRENT_TIMESTAMP+INTERVAL 1 HOUR 
ON COMPLETION PRESERVE 
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())

-- 示例4：从当前时间一天后开始，每1小时往demo_1119表中插入一行数据，三天后结束
CREATE EVENT demo_event5 
ON SCHEDULE EVERY 1 HOUR 
STARTS CURRENT_TIMESTAMP+INTERVAL 1 DAY 
ENDS CURRENT_TIMESTAMP+INTERVAL 3 DAY 
ON COMPLETION PRESERVE 
DO INSERT INTO `demo_1119` (`id`, `name`, `createTime`) VALUES (null, '陈哈哈', NOW())

-- 示例5：每天零点定时清一下demo_1119表数据
CREATE EVENT demo_event5 
ON SCHEDULE EVERY 1 DAY STARTS '2020-11-20 00:00:00' 
ON COMPLETION PRESERVE 
DO TRUNCATE table `demo_1119`
```



## 修改事件

修改事件语句跟创建语句如出一辙，语法如下：

```sql
ALTER EVENT event_name
    　　 [ONSCHEDULE schedule]
    　　 [old_NAME TO new_NAME]
    　　 [ON COMPLETION [NOT] PRESERVE]
    　　 [COMMENT 'comment']
    　　 [ENABLE | DISABLE]
    　　 [DO sql_statement]
```

- 关闭事件任务： ALTER EVENT 事件名称 ON COMPLETION PRESERVE DISABLE;
- 开启事件任务：ALTER EVENT 事件名称 ON COMPLETION PRESERVE ENABLE;

```sql
-- 创建定时任务 8点执行 调用test()存储过程
ALTER EVENT sync_lastday_attendance
ON SCHEDULE
EVERY '1' DAY STARTS '2021-09-19 08:00:00'
DO call test()
```

## 删除事件

```sql
DROP EVENT [IF EXISTS] event_name
```

## 定时规则

### 周期执行(EVERY)

参数单位有：second、minute、hour、day、week(周)、quarter(季度)、month、year

```sql
on schedule every 1 second         -- 每秒执行1次
on schedule every 2 minute         -- 每两分钟执行1次
on schedule every 1 day            -- 每天执行1次
on schedule every 3 day            -- 每3天执行1次
ON schedule every 1 day starts date_add(date_add_curdate(), interval 1 day), interval 1 hour)  -- 每天凌晨1点执行
on schedule every 1 week           -- 每周执行1次
ON schedule every 1 month starts date_add(date_add(date_sub(curdatte(),interval day(curdate())-1 day),interval 1 month),interval 1 hour) -- 每个月的第一天凌晨1点执行
```

### 在具体某个时间执行(AT)

```sql
on schedule at current_timestamp()+interval 5 day     -- 5天后执行
on schedule at current_timestamp()+interval 10 minute -- 10分钟后执行
on schedule at '2021-09-19 05:00:00' -- 在2021年9月19日，5点整执行
```

### 在某个时间段执行(STARTS ENDS)

```sql
-- 3天后开始每天都执行一次到下个月底结束
on schedule every 1 day starts current_timestamp()+interval 3 day ends current_timestamp()+interval 1 month
on schedule every 1 day ends current_timestamp()+interval 3 day -- 从现在起每天执行，执行3天
ON SCHEDULE EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + 1 WEEK -- 每 3 个月，从现在起一周后开始
-- 每十二个小时，从现在起三十分钟后开始，并于现在起四个星期后结束
ON SCHEDULE EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK
-- 5天后开始每天都执行执行到下个月底
on schedule every 1 day starts current_timestamp()+interval 5 day ends current_timestamp()+interval 1 month
on schedule every 1 day ends current_timestamp()+interval 5 day -- 从现在起每天执行，执行5天
```

## 示例

示例1：创建名称为event_user的事件，用于每隔5秒钟向数据表tb_user（用户信息表）中插入一条数据。

```sql
-- 创建用户信息表
CREATE TABLE IF NOT EXISTS tb_user
(
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户编号',
    name VARCHAR(30) NOT NULL COMMENT '用户姓名',
    create_time TIMESTAMP COMMENT '创建时间'
) COMMENT = '用户信息表';

-- 创建事件
CREATE EVENT IF NOT EXISTS event_user
ON SCHEDULE EVERY 5 SECOND
ON COMPLETION PRESERVE
COMMENT '新增用户信息定时任务'
DO INSERT INTO tb_user(name,create_time) VALUES('木子教程的博客',NOW());
```

示例2：创建一个事件，实现每个月的第一天凌晨1点统计一次已经注册的会员人数，并插入到统计表中。

```sql
CREATE PROCEDURE p_total()
BEGIN
    DECLARE n_total INT default 0;
    SELECT COUNT(*) INTO n_total FROM db_database11.tb_user;
    INSERT INTO tb_total (userNumber,createtime) VALUES(n_total,NOW());
END;

CREATE EVENT IF NOT EXISTS e_autoTotal
ON SCHEDULE EVERY 1 MONTH STARTS DATE_ADD(DATE_ADD(DATE_SUB(CURDATE(),INTERVAL DAY(CURDATE())-1 DAY),INTERVAL 1 MONTH),INTERVAL 1 HOUR)
ON COMPLETION PRESERVE ENABLE
DO CALL p_total();
```



https://cloud.tencent.com/developer/article/1888329 
https://www.cnblogs.com/zhuminghui/p/12808024.html 
https://zhuanlan.zhihu.com/p/450454992

# 应用

## 字段拼接

~~~shell
#单行数据多字段拼接
concat

#多行数据同一个字段的拼接
group_concat

#group_concat函数
create table aa(id int,name varchar(100));
insert into aa values(1,10);
insert into aa values(1,20);
insert into aa values(1,20);
insert into aa values(2,20);
insert into aa values(3,200);
insert into aa values(3,500);

mysql> select id,group_concat(name) from aa group by id;
+------+--------------------+
| id   | group_concat(name) |
+------+--------------------+
|    1 | 10,20,20           |
|    2 | 20                 |
|    3 | 200,500            |
+------+--------------------+

mysql> select id,group_concat(name separator ';') from aa group by id;
+------+----------------------------------+
| id   | group_concat(name separator ';') |
+------+----------------------------------+
|    1 | 10;20;20                         |
|    2 | 20                               |
|    3 | 200;500                          |
+------+----------------------------------+

mysql> select id,group_concat(distinct name) from aa group by id;
+------+-----------------------------+
| id   | group_concat(distinct name) |
+------+-----------------------------+
|    1 | 10,20                       |
|    2 | 20                          |
|    3 | 200,500                     |
+------+-----------------------------+

mysql> select id,group_concat(distinct name order by name desc) from aa group by id;
+------+------------------------------------------------+
| id   | group_concat(distinct name order by name desc) |
+------+------------------------------------------------+
|    1 | 20,10                                          |
|    2 | 20                                             |
|    3 | 500,200                                        |
+------+------------------------------------------------+
~~~

## 字符串截取

~~~shell
#根据指定分隔符截取字符串
SUBSTRING_INDEX
mysql> select SUBSTRING_INDEX('haha,hehe,heihei',',',-1);
+--------------------------------------------+
| SUBSTRING_INDEX('haha,hehe,heihei',',',-1) |
+--------------------------------------------+
| heihei                                     |
+--------------------------------------------+
1 row in set (0.00 sec)

https://blog.csdn.net/crack6677/article/details/120334606
~~~

## 字符串转换成时间戳

**使用STR_TO_DATE函数将字符串转换成日期**

~~~shell
STR_TO_DATE(str, format)
~~~

其中，str 是要转换的字符串，format 是日期的格式。下面是一些常用的日期格式：

| 格式 | 说明                 |
| ---- | -------------------- |
| %Y   | 四位数的年份         |
| %m   | 月份                 |
| %d   | 日期                 |
| %H   | 小时                 |
| %i   | 分钟                 |
| %s   | 秒                   |
| %p   | PM或AM               |
| %r   | HH:mm:ss PM形式时间  |
| %W   | 周，周名，如 Tuesday |

~~~sql
SET @str = '2022-01-01 12:00:00';
SET @format = '%Y-%m-%d %H:%i:%s';
SET @date = STR_TO_DATE(@str, @format);

mysql> select @date;
+---------------------+
| @date               |
+---------------------+
| 2022-01-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
~~~

**使用UNIX_TIMESTAMP函数将日期转换成时间戳**

在MySQL中，我们可以使用UNIX_TIMESTAMP函数将日期转换成时间戳。该函数的语法如下：

~~~shell
UNIX_TIMESTAMP(date)
~~~

其中，date 是要转换的日期。下面是一些常用的日期表示形式：

- 'YYYY-MM-DD HH:MM:SS'：年-月-日 时:分:秒
- 'YYYYMMDDHHMMSS'：年月日时分秒

具体操作时，我们可以使用以下代码将日期转换成时间戳：

~~~sql
SET @timestamp = UNIX_TIMESTAMP(@date);
~~~

上述代码中，我们将日期 @date 转换成时间戳，并将其赋值给变量 @timestamp。

## 常用的日期时间函数

### 获取当前时间和日期

~~~sql
-- 1、日期(date)函数
返回当前日期：
mysql> select CURDATE(),CURRENT_DATE(),CURRENT_DATE;
+------------+----------------+--------------+
| CURDATE()  | CURRENT_DATE() | CURRENT_DATE |
+------------+----------------+--------------+
| 2023-08-28 | 2023-08-28     | 2023-08-28   |
+------------+----------------+--------------+
1 row in set (0.01 sec)

-- 2、时间(time)函数
mysql> select CURTIME(),CURRENT_TIME(),CURRENT_TIME;
+-----------+----------------+--------------+
| CURTIME() | CURRENT_TIME() | CURRENT_TIME |
+-----------+----------------+--------------+
| 21:24:50  | 21:24:50       | 21:24:50     |
+-----------+----------------+--------------+
1 row in set (0.00 sec)

-- 3、日期和时间函数
mysql> select CURRENT_TIMESTAMP(),CURRENT_TIMESTAMP,LOCALTIME(),LOCALTIME,LOCALTIMESTAMP(),LOCALTIMESTAMP,NOW(),SYSDATE()\G
*************************** 1. row ***************************
CURRENT_TIMESTAMP(): 2023-08-28 21:26:11
  CURRENT_TIMESTAMP: 2023-08-28 21:26:11
        LOCALTIME(): 2023-08-28 21:26:11
          LOCALTIME: 2023-08-28 21:26:11
   LOCALTIMESTAMP(): 2023-08-28 21:26:11
     LOCALTIMESTAMP: 2023-08-28 21:26:11
              NOW(): 2023-08-28 21:26:11
          SYSDATE(): 2023-08-28 21:26:11
1 row in set (0.00 sec)
~~~



### NOW(), SYSDATE()的区别

~~~sql
-- NOW()返回执行当前SQL语句的时间：
mysql> select now(),sleep(2),now();
+---------------------+----------+---------------------+
| now()               | sleep(2) | now()               |
+---------------------+----------+---------------------+
| 2023-08-28 21:28:18 |        0 | 2023-08-28 21:28:18 |
+---------------------+----------+---------------------+
1 row in set (2.00 sec)

-- SYSDATE()返回执行当前函数的时间：
mysql> select sysdate(),sleep(2),sysdate();
+---------------------+----------+---------------------+
| sysdate()           | sleep(2) | sysdate()           |
+---------------------+----------+---------------------+
| 2023-08-28 21:29:17 |        0 | 2023-08-28 21:29:19 |
+---------------------+----------+---------------------+
1 row in set (2.00 sec)

-- SYSDATE()可以传入一个参数:fsp 表示是否包括小数秒精度（0~6位）
mysql> select sysdate(),sysdate(6);
+---------------------+----------------------------+
| sysdate()           | sysdate(6)                 |
+---------------------+----------------------------+
| 2023-08-28 21:31:27 | 2023-08-28 21:31:27.087888 |
+---------------------+----------------------------+
1 row in set (0.00 sec)
~~~

### 日期和时间比较

Mysql中可以直接用字符串进行比较时间大小， 只要你的日期格式是合法的就行

~~~sql
mysql> select '2023-08-28 21:31:27' > '2023-08-29 21:31:27';
+-----------------------------------------------+
| '2023-08-28 21:31:27' > '2023-08-29 21:31:27' |
+-----------------------------------------------+
|                                             0 |
+-----------------------------------------------+
1 row in set (0.01 sec)

mysql> select '2023-08-28 21:31:27' < '2023-08-29 21:31:27';
+-----------------------------------------------+
| '2023-08-28 21:31:27' < '2023-08-29 21:31:27' |
+-----------------------------------------------+
|                                             1 |
+-----------------------------------------------+
1 row in set (0.00 sec)


mysql> select '21:31:27' > '22:31:27';
+-------------------------+
| '21:31:27' > '22:31:27' |
+-------------------------+
|                       0 |
+-------------------------+
1 row in set (0.00 sec)

mysql> select '21:31:27' < '22:31:27';
+-------------------------+
| '21:31:27' < '22:31:27' |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)
~~~



### 日期和时间运算

~~~sql
-- DATE_ADD()函数：日期时间增加减少
select now(),DATE_ADD(now(),INTERVAL 1 year);
select now(),DATE_ADD(now(),INTERVAL -1 year);
select now(),DATE_ADD(now(),INTERVAL 1 quarter);
select now(),DATE_ADD(now(),INTERVAL 1 month);
select now(),DATE_ADD(now(),INTERVAL 1 week);
select now(),DATE_ADD(now(),INTERVAL 1 day);
select now(),DATE_ADD(now(),INTERVAL 1 hour);
select now(),DATE_ADD(now(),INTERVAL 1 minute);
select now(),DATE_ADD(now(),INTERVAL 1 second);
select now(),DATE_ADD(now(),INTERVAL 1 microsecond);

-- DATEDIFF()函数：计算两个日期差 
mysql> select DATEDIFF(now(),DATE_ADD(now(),INTERVAL 1 year));
+-------------------------------------------------+
| DATEDIFF(now(),DATE_ADD(now(),INTERVAL 1 year)) |
+-------------------------------------------------+
|                                            -366 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select DATEDIFF(DATE_ADD(now(),INTERVAL 1 year),now());
+-------------------------------------------------+
| DATEDIFF(DATE_ADD(now(),INTERVAL 1 year),now()) |
+-------------------------------------------------+
|                                             366 |
+-------------------------------------------------+
1 row in set (0.00 sec)


-- TIMEDIFF()函数：计算两个时间差
mysql> select TIMEDIFF(now(),DATE_ADD(now(),INTERVAL 1 minute));
+---------------------------------------------------+
| TIMEDIFF(now(),DATE_ADD(now(),INTERVAL 1 minute)) |
+---------------------------------------------------+
| -00:01:00                                         |
+---------------------------------------------------+
1 row in set (0.00 sec)

mysql> select TIMEDIFF(DATE_ADD(now(),INTERVAL 1 minute),now());
+---------------------------------------------------+
| TIMEDIFF(DATE_ADD(now(),INTERVAL 1 minute),now()) |
+---------------------------------------------------+
| 00:01:00                                          |
+---------------------------------------------------+
1 row in set (0.01 sec)
~~~

### 日期和时间的格式化

~~~sql
-- DATE_FORMAT(date,format)函数

DATE_FORMAT(SYSDATE(),'%Y-%m-%d %H:%i:%s')
~~~

常用格式

| 格式 | 说明                                     |
| ---- | ---------------------------------------- |
| %Y   | 四位数的年份                             |
| %m   | 月份                                     |
| %d   | 日期                                     |
| %H   | 小时                                     |
| %i   | 分钟                                     |
| %s   | 秒                                       |
| %p   | PM或AM                                   |
| %r   | HH:mm:ss PM形式时间                      |
| %w   | 周，0-6, 0为周日                         |
| %W   | 周，周名，如 Tuesday                     |
| %j   | 当前日期所在一年中的天数，3位（001-366） |

~~~sql
-- DATE_FORMAT(date,format) 函数
将数据库中的date数据格式化为String类型


-- STR_TO_DATE(str,format) 函数：
将指定的时间格式的字符串按照格式转换为DATETIME类型的值。str要与format的格式保持一致，否则会报错。
~~~

### YEAR()函数

取日期时间的年份

~~~sql
mysql> select year(now());
+-------------+
| year(now()) |
+-------------+
|        2023 |
+-------------+
1 row in set (0.00 sec)
~~~







## 动态SQL拼接

https://www.shuzhiduo.com/A/kvJ3g0RAJg/
https://blog.csdn.net/weixin_35020039/article/details/113656384

## 拼接sql删除索引和自增主键

~~~shell
--删除普通索引
select concat('drop index ',t2.name,' on ',SUBSTRING_INDEX(t1.NAME,'/',-1),';') 
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name not in('GEN_CLUST_INDEX', 'PRIMARY');

--删除自增属性
select concat('alter table ',TABLE_NAME,' modify ',COLUMN_NAME,' ',DATA_TYPE,';') from information_schema.COLUMNS 
where TABLE_SCHEMA='sysbenchdb' and TABLE_NAME regexp 'sbtest' and EXTRA regexp 'auto_increment';

--删除主键
select concat('alter table ',SUBSTRING_INDEX(t1.NAME,'/',-1),' drop primary key;') from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name = 'PRIMARY';


--将查询导出为sql文件
select concat('drop index ',t2.name,' on ',SUBSTRING_INDEX(t1.NAME,'/',-1),';') 
from information_schema.INNODB_TABLES t1
join information_schema.INNODB_INDEXES t2
on (t1.TABLE_ID=t2.TABLE_ID)
where t1.name REGEXP '.*sbtest'
and t2.name not in('GEN_CLUST_INDEX', 'PRIMARY') into outfile '/tmp/drop_index1.sql';

--执行SQL文件
mysql -uroot -prootroot -Dsysbenchdb < /tmp/drop_index1.sql &
~~~

## 正则函数

https://blog.csdn.net/wzy0623/article/details/130791381



# 插件安装

在MySQL中，您可以通过INSTALL PLUGIN语句来安装插件。但在安装插件之前，您通常需要确保有相关的插件共享库文件，并确保MySQL的plugin_dir系统变量正确指向共享库文件所在的目录。
以下是一个简化的步骤来安装MySQL插件：
1.获取插件:
2.首先，您需要从合适的来源下载或编译您所需的插件。这通常是一个.so（在Unix-like系统上）或.dll（在Windows上）的共享库文件。
3.放置共享库文件:
4.将该共享库文件复制到MySQL的插件目录中。您可以通过执行以下命令查找此目录：

~~~shell
SHOW VARIABLES LIKE 'plugin_dir';
~~~

5.安装插件:
使用INSTALL PLUGIN语句。例如，如果您要安装名为myplugin的插件，则可以执行：

~~~shell
INSTALL PLUGIN myplugin SONAME 'myplugin.so';
~~~

注意: 在Windows上，您将使用.dll后缀而不是.so。
6.验证插件已安装:
可以查询information_schema.plugins表来确认：

~~~shell
SELECT * FROM information_schema.plugins WHERE plugin_name = 'myplugin';
~~~

7.如果需要，配置插件:
根据插件的文档，可能需要进行进一步的配置或初始化步骤。
8.卸载插件:
如果您需要在以后卸载插件，可以使用：

~~~shell
UNINSTALL PLUGIN myplugin;
~~~

注意：
9.在安装任何插件之前，请确保从可靠的来源获取它，并确保它与您的MySQL版本兼容。
10.有些插件可能需要特定的MySQL配置或系统库。务必阅读并遵循插件的文档。
11.在生产环境中安装插件之前，建议在开发或测试环境中首先进行测试。



# 开发相关

## MySQL数据库自增id、uuid与雪花id详解

https://www.jb51.net/article/276641.htm

https://blog.51cto.com/u_16175471/7184867

主键策略之雪花算法详解

https://blog.csdn.net/lingerlan510/article/details/116207951

数据库主键的选择--雪花ID

https://www.cnblogs.com/Harrylsj/p/14696577.html

## MYSQL 5.7实现ROW_NUMBER() 功能

https://blog.csdn.net/subaiqiao/article/details/130305728

https://blog.csdn.net/weixin_43211480/article/details/127590617



## MySQL中order by排序将NULL排在最前/后面

>NULL的意思表示什么都不是，或者理解成“未知”也可以，它与任何值比较的结果都是false
>注意：
>默认情况下，MySQL会认为NULL值比其他类型的数据小， 也就是说：在order by排序的时候，NULL是最小的。

创建测试数据

```sql
create database testdb;
use testdb
create table test_t(id int,age int,name varchar(20));
insert into test_t values(1,12,'zhangsan');
insert into test_t values(2,32,'lizi');
insert into test_t values(3,22,'wangwu');
insert into test_t values(4,null,'zhaoliu');
insert into test_t values(5,12,'yangqi');

mysql> select * from test_t;
+------+------+----------+
| id   | age  | name     |
+------+------+----------+
|    1 |   12 | zhangsan |
|    2 |   32 | lizi     |
|    3 |   22 | wangwu   |
|    4 | NULL | zhaoliu  |
|    5 |   12 | yangqi   |
+------+------+----------+
5 rows in set (0.00 sec)
```

Null排在最前面：ASC默认NULL值是在最前面的

```sql
mysql> select * from test_t order by age asc;
+------+------+----------+
| id   | age  | name     |
+------+------+----------+
|    4 | NULL | zhaoliu  |
|    1 |   12 | zhangsan |
|    5 |   12 | yangqi   |
|    3 |   22 | wangwu   |
|    2 |   32 | lizi     |
+------+------+----------+
5 rows in set (0.00 sec)
```

Null值排在最后面

```sql
mysql> select * from test_t order by age is null asc ,age asc;
+------+------+----------+
| id   | age  | name     |
+------+------+----------+
|    1 |   12 | zhangsan |
|    5 |   12 | yangqi   |
|    3 |   22 | wangwu   |
|    2 |   32 | lizi     |
|    4 | NULL | zhaoliu  |
+------+------+----------+
5 rows in set (0.00 sec)
```

## MySQL重复记录删除

~~~sql
delete t  
from t, 
( select table_name,max(id) id 
  from t 
  group by table_name 
  having count(*)>1 ) d 
where t.table_name=d.table_name 
  and t.id<d.id;
~~~







# 参考资料

MySQL 知识手册
https://blog.csdn.net/qq_53569667/article/details/128754058

Mysql：创建和管理表（全面详解）

https://blog.csdn.net/weixin_52533007/article/details/131545621
