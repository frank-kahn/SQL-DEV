# 表

## 普通表

~~~sql
--General Examples
CREATE TABLE employees_demo
( employee_id NUMBER(6)
, first_name VARCHAR2(20)
, last_name VARCHAR2(25)
CONSTRAINT emp_last_name_nn_demo NOT NULL
, email VARCHAR2(25)
CONSTRAINT emp_email_nn_demo NOT NULL
, phone_number VARCHAR2(20)
, hire_date DATE DEFAULT SYSDATE
CONSTRAINT emp_hire_date_nn_demo NOT NULL
, job_id VARCHAR2(10)
CONSTRAINT emp_job_nn_demo NOT NULL
, salary NUMBER(8,2)
CONSTRAINT emp_salary_nn_demo NOT NULL
, commission_pct NUMBER(2,2)
, manager_id NUMBER(6)
, department_id NUMBER(4)
, dn VARCHAR2(300)
, CONSTRAINT emp_salary_min_demo
CHECK (salary > 0)
, CONSTRAINT emp_email_uk_demo
UNIQUE (email)
) ;

--Storage Example
CREATE TABLE employees_demo
( employee_id NUMBER(6)
, first_name VARCHAR2(20)
, last_name VARCHAR2(25)
CONSTRAINT emp_last_name_nn_demo NOT NULL
, email VARCHAR2(25)
CONSTRAINT emp_email_nn_demo NOT NULL
, phone_number VARCHAR2(20)
, hire_date DATE DEFAULT SYSDATE
CONSTRAINT emp_hire_date_nn_demo NOT NULL
, job_id VARCHAR2(10)
CONSTRAINT emp_job_nn_demo NOT NULL
, salary NUMBER(8,2)
CONSTRAINT emp_salary_nn_demo NOT NULL
, commission_pct NUMBER(2,2)
, manager_id NUMBER(6)
, department_id NUMBER(4)
, dn VARCHAR2(300)
, CONSTRAINT emp_salary_min_demo
CHECK (salary > 0)
, CONSTRAINT emp_email_uk_demo
UNIQUE (email)
)
TABLESPACE example
STORAGE (INITIAL 8M);

--Creating a Table with a DEFAULT ON NULL Column Value: Example
CREATE TABLE myemp (employee_id number, last_name varchar2(25),
department_id NUMBER DEFAULT ON NULL 50 NOT NULL);

--Creating a Table with an Identity Column: Examples
CREATE TABLE t1 (id NUMBER GENERATED AS IDENTITY);
CREATE TABLE t2 (id NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 100
INCREMENT BY 10));

--表重命名
rename t1 to t2;
--列重命名
alter table t2 rename column id to id1;
--修改列数据类型
alter table t2 modify id1 NUMBER(18);

--表的复制
create table t2 as select * from t1;
create table t2 as select * from t1 where id=1;

--表的截断
truncate table t1;

--表的删除
drop table t1;
drop table table_name cascade constraints;--相关的视图，约束，等相关所有的关系对象
drop table table_name purge;--释放资源，不经过回收站。

--回收站参数查询
select name,value from v$parameter where name = 'recyclebin';
alter system set recyclebin ='off' scope=spfile;

--查询当前用户的所有表
select * from tab;
--查询当前所有用户的所有表的详细信息
select * from user_tables;
~~~





## 临时表

~~~sql
create table test(id int,name varchar(100));
insert into test values(1,'zhangsan');
insert into test values(2,'lisi');
insert into test values(3,'wangwu');
insert into test values(4,'zhaoliu');
insert into test values(5,'qiti');
insert into test values(6,'liumei');
commit;


--事务级临时表:事务结束（commit,rollback），清除数据
--transaction级别，临时表的作用范围在一个事务之内，
create global temporary table temp_transaction
			  on commit delete rows
			  as select * from test;

--会话级临时表:会话结束自动清空数据
--session级别，只要用户不退出,临时表一直有效，一旦用户退出了，数据就没有了
create global temporary table temp_session
			  on commit preserve rows
			  as select * from test;
~~~

## 分区表

~~~sql
--创建测试表空间
create tablespace tsa datafile '/data1/oracle/oradata/tsa.dbf' size 50m;
create tablespace tsb datafile '/data1/oracle/oradata/tsb.dbf' size 50m;
create tablespace tsc datafile '/data1/oracle/oradata/tsc.dbf' size 50m;
create tablespace tsd datafile '/data1/oracle/oradata/tsd.dbf' size 50m;
create tablespace ts1 datafile '/data1/oracle/oradata/ts1.dbf' size 50m;
create tablespace ts2 datafile '/data1/oracle/oradata/ts2.dbf' size 50m;
create tablespace ts3 datafile '/data1/oracle/oradata/ts3.dbf' size 50m;
create tablespace ts4 datafile '/data1/oracle/oradata/ts4.dbf' size 50m;
~~~

### 范围分区

(1)最早、最经典、应用最广的分区算法

(2)范围分区通过对分区字段值的范围进行分区

(3)范围分区特别适合于按时间期进行数据的存储。日、周、月、年等。

(4)数据管理能力强(数据迁移,数据备份,数据交换)

(5)范围分区的数据可能不均匀。

(6)范围分区与记录值相关,实施难度和可维护性相对较差。

~~~sql
--Example 4–1 Creating a range-partitioned table
CREATE TABLE sales
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id)
( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
TABLESPACE tsa
, PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
TABLESPACE tsb
, PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
TABLESPACE tsc
, PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
TABLESPACE tsd
);


--Example 4–2 Creating a range-partitioned table with ENABLE ROW MOVEMENT
CREATE TABLE sales
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
STORAGE (INITIAL 100K NEXT 50K) LOGGING
PARTITION BY RANGE (time_id)
( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
TABLESPACE tsa STORAGE (INITIAL 20K NEXT 10K)
, PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
TABLESPACE tsb
, PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
TABLESPACE tsc
, PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
TABLESPACE tsd
)
ENABLE ROW MOVEMENT;


/*
	这里的ENABLE ROW MOVEMENT表示启用行移动，控制是否允许修改列值所造成的行移动，默认是disable，disable下如果记录被更新至其它分区就会报错，比如上述的第一个分区时间为小于2006年4月1日，某条记录日期为20060101为该分区，现在手动修改日志为20060501，disable下修改就会报错，enable下会自动把该条数据启动到第二个分区，但是有性能问题，建议创建分区的时候不要启动行移动，有类型的修改的时候，再启用，修改数据后再关闭行移动
	启用行移动弊端：一般情况下ROWID不会改变，但是行移动会改变rowid,改变之后就不能使用logminner（日志挖掘），因为挖掘日志是使用sql undo来恢复的，恢复的原理就是找ROWID，ROWID改变了就恢复不了了，所以一般不建议开启行移动。
	这里还有个问题，如上案例分区的最大日期小于20070101，也就是该表纯粹就是为了存放2006年的数据的，那如果有2007年的记录呢？插入就会报错，对于这种不可预测的一般都是创建一个最大的分区，不包含其它分区的数据，数据就存放到该分区。
如下案例：
        CREATE TABLE emp (deptno NUMBER, empname VARCHAR(32), grade NUMBER)
        PARTITION BY RANGE(deptno) 
        (PARTITION p1 VALUES LESS THAN (1000),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (MAXVALUE)
        );
*/




--按时间分区，不同时间存放不用分区，各个分区使用独立的表空间
--创建表空间
create tablespace test_r1_p2014 datafile '/data1/oracle/oradata/test_r1_p2014.dbf' size 20m autoextend off;
create tablespace test_r1_p2015 datafile '/data1/oracle/oradata/test_r1_p2015.dbf' size 20m autoextend off;
create tablespace test_r1_p2016 datafile '/data1/oracle/oradata/test_r1_p2016.dbf' size 20m autoextend off;
create tablespace test_r1_p2017 datafile '/data1/oracle/oradata/test_r1_p2017.dbf' size 20m autoextend off;
--设置权限
alter user test quota unlimited on test_r1_p2014;
alter user test quota unlimited on test_r1_p2015;
alter user test quota unlimited on test_r1_p2016;
alter user test quota unlimited on test_r1_p2017;
--创建分区表
create table test_r1
(
	id NUMBER(20) not null,
	name VARCHAR2(20) not null,
	age NUMBER(10) not null,
	sex VARCHAR2(10) not null,
	cardid NUMBER(30) not null,
	joindate DATE not null,
	region VARCHAR2(12) not null,
	tel VARCHAR2(12) not null,
	email VARCHAR2(30) not null,
	recommend VARCHAR2(10),
	identifier VARCHAR2(100)
)
partition by range(joindate)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD'))
tablespace test_r1_p2014,
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD'))
tablespace test_r1_p2015,
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD'))
tablespace test_r1_p2016,
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
tablespace test_r1_p2017
);

--查询验证
--user_part_tables/dba/all 记录分区的表的信息
--user_tab_partitions/dba/all 记录表的分区的信息
--user_part_indexes/dba/all 查询分区的索引信息
select * from dba_part_tables where table_name='TEST_R1';
select * from dba_tab_partitions where table_name='TEST_R1';
select * from dba_part_indexes where table_name='TEST_R1';
select count(*) from test_r1 partition(p2014);



--按照数值范围分区
--创建测试表空间
create tablespace test_ts datafile '/data1/oracle/oradata/test_ts.dbf' size 20m autoextend off;
--创建分区表
create table test_r2
(
	id NUMBER(20) not null,
	name VARCHAR2(20) not null,
	age NUMBER(10) not null,
	sex VARCHAR2(10) not null,
	cardid NUMBER(30) not null,
	joindate DATE not null,
	region VARCHAR2(12) not null,
	tel VARCHAR2(12) not null,
	email VARCHAR2(30) not null,
	recommend VARCHAR2(10),
	identifier VARCHAR2(100)
) tablespace test_ts
partition by range(id)
(
partition p10000 values less than (20010000),
partition p20000 values less than (20020000),
partition p30000 values less than (20030000),
partition p40000 values less than (20040000),
partition p50000 values less than (20050000),
partition p_max values less than (maxvalue)
);

/*
说明：如果分区没有指定具体的表空间，那么默认就和主表的表空间一致，如果主表也没有指定表空间，那么默认就是users表空间，此时主表和分区都默认是test_ts表空间
*/



--直接创建有数据的表分区
--创建测试表和数据
create table test_t as 
select rownum as id,
               to_char(sysdate + rownum/24/3600, 'yyyy-mm-dd hh24:mi:ss') as inc_datetime,
               trunc(dbms_random.value(0, 100)) as random_id,
               dbms_random.string('x', 20) random_string
          from dual
        connect by level <= 60000;
--创建分区表
create table test_r3
( id,inc_datetime,random_id,random_string)
tablespace test_ts
partition by range(id)
(
partition p10000 values less than (10000),
partition p20000 values less than (20000),

partition p30000 values less than (30000),
partition p40000 values less than (40000),
partition p50000 values less than (50000),
partition p_max values less than (maxvalue)
)
as
select id,inc_datetime,random_id,random_string from test_t;

--查询验证
select * from dba_part_tables where table_name='TEST_R3';
select * from dba_tab_partitions where table_name='TEST_R3';
select * from dba_part_indexes where table_name='TEST_R3';
select count(*) from test_r3 partition(p10000);
select count(*) from test_r3 partition(p20000);
select count(*) from test_r3 partition(p30000);
select count(*) from test_r3 partition(p40000);
select count(*) from test_r3 partition(p50000);
select count(*) from test_r3 partition(p_max);


--联合字段分区
create table test_r4
(
	id NUMBER(20) not null,
	name VARCHAR2(20) not null,
	age NUMBER(10) not null,
	sex VARCHAR2(10) not null,
	cardid NUMBER(30) not null,
	joindate DATE not null,
	region VARCHAR2(12) not null,
	tel VARCHAR2(12) not null,
	email VARCHAR2(30) not null,
	recommend VARCHAR2(10),
	identifier VARCHAR2(100)
) tablespace test_ts
partition by range(age,joindate)
(
partition p_30_2014 values less than (30,to_date('2015-01-01','YYYY-MM-DD')),
partition p_30_2015 values less than (30,to_date('2016-01-01','YYYY-MM-DD')),
partition p_30_2016 values less than (30,to_date('2017-01-01','YYYY-MM-DD')),
partition p_30_2017 values less than (30,to_date('2018-01-01','YYYY-MM-DD')),
partition p_30_max  values less than (30,maxvalue),
partition p_60_2014 values less than (60,to_date('2015-01-01','YYYY-MM-DD')),
partition p_60_2015 values less than (60,to_date('2016-01-01','YYYY-MM-DD')),
partition p_60_2016 values less than (60,to_date('2017-01-01','YYYY-MM-DD')),
partition p_60_2017 values less than (60,to_date('2018-01-01','YYYY-MM-DD')),
partition p_60_max  values less than (60,maxvalue)
);
~~~

### 列表分区

(1) List分区通过对分区字段的离散值进行分区。

(2) List分区是不排序的,而且分区之间没有关联关系

(3) List分区适合于对数据离散值进行控制。

(4) List分区只支持单个字段。

~~~sql
--Example 4–7 Creating a list-partitioned table
CREATE TABLE q1_sales_by_region
(      deptno number,
       deptname varchar2(20),
       quarterly_sales number(10, 2),
       state varchar2(2))
PARTITION BY LIST (state)
(PARTITION q1_northwest VALUES ('OR', 'WA'),
PARTITION q1_southwest VALUES ('AZ', 'UT', 'NM'),
PARTITION q1_northeast VALUES ('NY', 'VM', 'NJ'),
PARTITION q1_southeast VALUES ('FL', 'GA'),
PARTITION q1_northcentral VALUES ('SD', 'WI'),
PARTITION q1_southcentral VALUES ('OK', 'TX'));

--Example 4–8 Creating a list-partitioned table with a default partition
CREATE TABLE sales_by_region (
       item# INTEGER, 
       qty INTEGER,
       store_name VARCHAR(30), 
       state_code VARCHAR(2),
       sale_date DATE)
STORAGE(INITIAL 10K NEXT 20K) TABLESPACE users
PARTITION BY LIST (state_code)
(
PARTITION region_east VALUES ('MA','NY','CT','NH','ME','MD','VA','PA','NJ')
STORAGE (INITIAL 8M)
TABLESPACE test_ts,
PARTITION region_west VALUES ('CA','AZ','NM','OR','WA','UT','NV','CO')
NOLOGGING,
PARTITION region_south VALUES ('TX','KY','TN','LA','MS','AR','AL','GA'),
PARTITION region_central VALUES ('OH','ND','SD','MO','IL','MI','IA'),
PARTITION region_null VALUES (NULL),
PARTITION region_unknown VALUES (DEFAULT)
);
--说明：这里的defalut于范围分区的maxvalue一样，就不在范围内的值，放在这个分区



--按照性别分区
create table test_l1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by list(sex)
(
      partition par_01 values('男'),
      partition par_02 values('女'),
      partition p_max values (default)
);
~~~

### 哈希分区

基于分区字段的HASH值,自动将记录插入到指定分区。

分区数一般是2的幂

易于实施

总体性能最佳

适合于静态数据

HASH分区适合于数据的均匀存储

HASH分区特别适合于PDML和partition-wise joins。

支持(hash) local indexes

9i不支持(hash) global indexes

10g支持(hash) global indexes HASH分区

数据管理能力弱

HASH分区对数据值无法控制

对于那些无法有效划分范围的表,可以使用hash分区,这样对于提高性能还是会有一定的帮助。 hash分区会将表中的数据平均分配到你指定的几个分区中,列所在分区是依据分区列的hash值自动分配,因此你并不能控制也不知道哪条记录会被放到哪个分区中, hash分区也可以支持多个依赖列。

~~~sql
--Example 4–5 Creating a hash-partitioned table
CREATE TABLE scubagear
(    id NUMBER,
     name VARCHAR2 (60))
PARTITION BY HASH (id)
PARTITIONS 4
STORE IN (tsa, tsb, tsc, tsd);

--指定分区数量
CREATE TABLE dept (
     deptno NUMBER,
     deptname VARCHAR(32))
PARTITION BY HASH(deptno) 
PARTITIONS 16;

--不指定分区数量
CREATE TABLE dept1 (
     deptno NUMBER, 
     deptname VARCHAR(32))
STORAGE (INITIAL 10K)
PARTITION BY HASH(deptno)
(  PARTITION p1 TABLESPACE tsa,
   PARTITION p2 TABLESPACE tsb,
   PARTITION p3 TABLESPACE tsc, 
   PARTITION p4 TABLESPACE tsd);
~~~

### 复合分区

如果某表按照某列分区之后,仍然较大,或者是一些其它的需求,还可以通过分区内再建子分区的方式将分区再分区,即组台分区的方式。

既适合于历史数据,又适合于数据均匀分布

与范围分区一样提供高可用性和管理性

更好的PDML和partition-wise joins性能

实现粒度更细的操作

支持复合local indexes

不支持复合composite global indexes

RANGE-HASH

RANGE-LIST

RANGE-RANGE

--注意顺序,根分区只能是range分区,子分区可以是hash分区、list分区。

LIST-RANGE

LIST-HASH

LIST-LIST

--注意顺序,根分区只能是list分区,子分区可以是hash分区、range分区。

组合分区比range分区更容易管理,充分使用了hash分区的并行优势。

#### RANGE-HASH

~~~sql
--Example 4–10 Creating a composite range-hash partitioned table
CREATE TABLE sales2
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id) SUBPARTITION BY HASH (cust_id)
SUBPARTITIONS 8 STORE IN (tsa, tsb, tsc, tsd)
( PARTITION sales_q1_2006 VALUES LESS THAN (TO_DATE('01-APR-2006','dd-MON-yyyy'))
, PARTITION sales_q2_2006 VALUES LESS THAN (TO_DATE('01-JUL-2006','dd-MON-yyyy'))
, PARTITION sales_q3_2006 VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
, PARTITION sales_q4_2006 VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
);



CREATE TABLE emp2 (
       deptno NUMBER, 
       empname VARCHAR(32), 
       grade NUMBER)
PARTITION BY RANGE(deptno) 
SUBPARTITION BY HASH(empname)
SUBPARTITIONS 8 STORE IN (ts1, ts3, tsa, tsb)
(PARTITION p1 VALUES LESS THAN (1000),
PARTITION p2 VALUES LESS THAN (2000)
STORE IN (ts2, ts4, tsc, tsd),
PARTITION p3 VALUES LESS THAN (MAXVALUE)
(SUBPARTITION p3_s1 TABLESPACE ts4,
SUBPARTITION p3_s2 TABLESPACE tsa));


--为所有分区各创建2个hash子分区
create table test_rh1
(
    id NUMBER(20) not null primary key,
    name VARCHAR2(20) not null,
    age NUMBER(10) not null,
    sex VARCHAR2(10) not null,
    cardid NUMBER(30) not null,
    joindate DATE not null,
    region VARCHAR2(12) not null,
    tel VARCHAR2(12) not null,
    email VARCHAR2(30) not null,
    recommend VARCHAR2(10),
    identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
subpartition by hash(cardid)
subpartitions 2
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD')),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD')),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD')),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
);

--查询验证
select * from DBA_tab_partitions where table_name='TEST_RH1';
select * from Dba_Part_Tables where table_name='TEST_RH1';
select * from dba_tab_subpartitions where table_name='TEST_RH1';
select count(*) from test_rh1 partition(p2015);
select count(*) from test_rh1 subpartition(SYS_SUBP67);
~~~



#### RANGE-LIST

~~~sql
--Example 4–11 Creating a composite range-list partitioned table
CREATE TABLE quarterly_regional_sales(
       deptno number, 
       item_no varchar2(20),
       txn_date date, 
       txn_amount number,
       state varchar2(2))
TABLESPACE ts4
PARTITION BY RANGE (txn_date)
SUBPARTITION BY LIST (state)
(PARTITION q1_1999 VALUES LESS THAN (TO_DATE('1-APR-1999','DD-MON-YYYY'))
(SUBPARTITION q1_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q1_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q1_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q1_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q1_1999_northcentral VALUES ('SD', 'WI'),
SUBPARTITION q1_1999_southcentral VALUES ('OK', 'TX')
),
PARTITION q2_1999 VALUES LESS THAN ( TO_DATE('1-JUL-1999','DD-MON-YYYY'))
(SUBPARTITION q2_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q2_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q2_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q2_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q2_1999_northcentral VALUES ('SD', 'WI'),
SUBPARTITION q2_1999_southcentral VALUES ('OK', 'TX')
),
PARTITION q3_1999 VALUES LESS THAN (TO_DATE('1-OCT-1999','DD-MON-YYYY'))
(SUBPARTITION q3_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q3_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q3_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q3_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q3_1999_northcentral VALUES ('SD', 'WI'),
SUBPARTITION q3_1999_southcentral VALUES ('OK', 'TX')
),
PARTITION q4_1999 VALUES LESS THAN ( TO_DATE('1-JAN-2000','DD-MON-YYYY'))
(SUBPARTITION q4_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q4_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q4_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q4_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q4_1999_northcentral VALUES ('SD', 'WI'),
SUBPARTITION q4_1999_southcentral VALUES ('OK', 'TX')
)
);




CREATE TABLE sample_regional_sales (
       deptno number, 
       item_no varchar2(20),
       txn_date date, 
       txn_amount number, 
       state varchar2(2))
PARTITION BY RANGE (txn_date)
SUBPARTITION BY LIST (state)
(PARTITION q1_1999 VALUES LESS THAN (TO_DATE('1-APR-1999','DD-MON-YYYY'))
TABLESPACE ts1
(SUBPARTITION q1_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q1_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q1_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q1_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q1_others VALUES (DEFAULT) TABLESPACE ts4
),
PARTITION q2_1999 VALUES LESS THAN ( TO_DATE('1-JUL-1999','DD-MON-YYYY'))
TABLESPACE ts2
(SUBPARTITION q2_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q2_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q2_1999_northeast VALUES ('NY', 'VM', 'NJ'),
SUBPARTITION q2_1999_southeast VALUES ('FL', 'GA'),
SUBPARTITION q2_1999_northcentral VALUES ('SD', 'WI'),
SUBPARTITION q2_1999_southcentral VALUES ('OK', 'TX')
),
PARTITION q3_1999 VALUES LESS THAN (TO_DATE('1-OCT-1999','DD-MON-YYYY'))
TABLESPACE ts3
(SUBPARTITION q3_1999_northwest VALUES ('OR', 'WA'),
SUBPARTITION q3_1999_southwest VALUES ('AZ', 'UT', 'NM'),
SUBPARTITION q3_others VALUES (DEFAULT) TABLESPACE ts4
),
PARTITION q4_1999 VALUES LESS THAN ( TO_DATE('1-JAN-2000','DD-MON-YYYY'))
TABLESPACE ts4
);



--为所有分区各创建2 个list 子分区
create table test_rl1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
subpartition by list(sex)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD'))
(
subpartition sub_p2014_m values('男'),
subpartition sub_p2014_w values('女')
),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD'))
(
subpartition sub_p2015_m values('男'),
subpartition sub_p2015_w values('女')
),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD'))
(
subpartition sub_p2016_m values('男'),
subpartition sub_p2016_w values('女')
),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
(
subpartition sub_p2017_m values('男'),
subpartition sub_p2017_w values('女')
)
);



--采用模板(template)为所有分区各创建2 个list 子分区
create table test_rl2
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
subpartition by list(sex)
subpartition template
(
subpartition sub_p_m values('男'),
subpartition sub_p_w values('女'),
subpartition sub_p_other values(default)
)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD')),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD')),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD')),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
);
~~~



#### RANGE-RANGE

~~~sql
--Example 4–12 Creating a composite range-range partitioned table
CREATE TABLE shipments
(     order_id NUMBER NOT NULL, 
      order_date DATE NOT NULL,
      delivery_date DATE NOT NULL,
      customer_id NUMBER NOT NULL,
      sales_amount NUMBER NOT NULL
)
PARTITION BY RANGE (order_date)
SUBPARTITION BY RANGE (delivery_date)
( PARTITION p_2006_jul VALUES LESS THAN (TO_DATE('01-AUG-2006','dd-MON-yyyy'))
( SUBPARTITION p06_jul_e VALUES LESS THAN (TO_DATE('15-AUG-2006','dd-MON-yyyy'))
, SUBPARTITION p06_jul_a VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
, SUBPARTITION p06_jul_l VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_2006_aug VALUES LESS THAN (TO_DATE('01-SEP-2006','dd-MON-yyyy'))
( SUBPARTITION p06_aug_e VALUES LESS THAN (TO_DATE('15-SEP-2006','dd-MON-yyyy'))
, SUBPARTITION p06_aug_a VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
, SUBPARTITION p06_aug_l VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_2006_sep VALUES LESS THAN (TO_DATE('01-OCT-2006','dd-MON-yyyy'))
( SUBPARTITION p06_sep_e VALUES LESS THAN (TO_DATE('15-OCT-2006','dd-MON-yyyy'))
, SUBPARTITION p06_sep_a VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
, SUBPARTITION p06_sep_l VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_2006_oct VALUES LESS THAN (TO_DATE('01-NOV-2006','dd-MON-yyyy'))
( SUBPARTITION p06_oct_e VALUES LESS THAN (TO_DATE('15-NOV-2006','dd-MON-yyyy'))
, SUBPARTITION p06_oct_a VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
, SUBPARTITION p06_oct_l VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_2006_nov VALUES LESS THAN (TO_DATE('01-DEC-2006','dd-MON-yyyy'))
( SUBPARTITION p06_nov_e VALUES LESS THAN (TO_DATE('15-DEC-2006','dd-MON-yyyy'))
, SUBPARTITION p06_nov_a VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
, SUBPARTITION p06_nov_l VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_2006_dec VALUES LESS THAN (TO_DATE('01-JAN-2007','dd-MON-yyyy'))
( SUBPARTITION p06_dec_e VALUES LESS THAN (TO_DATE('15-JAN-2007','dd-MON-yyyy'))
, SUBPARTITION p06_dec_a VALUES LESS THAN (TO_DATE('01-FEB-2007','dd-MON-yyyy'))
, SUBPARTITION p06_dec_l VALUES LESS THAN (MAXVALUE)
)
);



--非模板的案例
create table test_rr1
(     id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
subpartition by range(id)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD'))
(
subpartition sub_p2014_m values less than(10000),
subpartition sub_p2014_w values less than(20000),
subpartition sub_p2014_max values less than(maxvalue)
),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD'))
(
subpartition sub_p2015_m values less than(10000),
subpartition sub_p2015_w values less than(20000),
subpartition sub_p2015_max values less than(maxvalue)
),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD'))
(
subpartition sub_p2016_m values less than(10000),
subpartition sub_p2016_w values less than(20000),
subpartition sub_p2016_max values less than(maxvalue)
),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
(
subpartition sub_p2017_m values less than(10000),
subpartition sub_p2017_w values less than(20000),
subpartition sub_p2017_max values less than(maxvalue)
)
);





--使用模板创建RR 分区案例
create table test_rr2
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
subpartition by range(age)
subpartition template
(
subpartition sub_p_30 values less than('30'),
subpartition sub_p_60 values less than('60'),
subpartition sub_p_other values less than(maxvalue)
)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD')),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD')),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD')),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
);
~~~



#### LIST-RANGE

~~~sql
--Example 4–15 Creating a composite list-range partitioned table
CREATE TABLE accounts
( id NUMBER,
  account_number NUMBER,
  customer_id NUMBER,
  balance NUMBER,
  branch_id NUMBER,
  region VARCHAR(2),
  status VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY RANGE (balance)
( PARTITION p_northwest VALUES ('OR', 'WA')
( SUBPARTITION p_nw_low VALUES LESS THAN (1000)
, SUBPARTITION p_nw_average VALUES LESS THAN (10000)
, SUBPARTITION p_nw_high VALUES LESS THAN (100000)
, SUBPARTITION p_nw_extraordinary VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
( SUBPARTITION p_sw_low VALUES LESS THAN (1000)
, SUBPARTITION p_sw_average VALUES LESS THAN (10000)
, SUBPARTITION p_sw_high VALUES LESS THAN (100000)
, SUBPARTITION p_sw_extraordinary VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
( SUBPARTITION p_ne_low VALUES LESS THAN (1000)
, SUBPARTITION p_ne_average VALUES LESS THAN (10000)
, SUBPARTITION p_ne_high VALUES LESS THAN (100000)
, SUBPARTITION p_ne_extraordinary VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_southeast VALUES ('FL', 'GA')
( SUBPARTITION p_se_low VALUES LESS THAN (1000)
, SUBPARTITION p_se_average VALUES LESS THAN (10000)
, SUBPARTITION p_se_high VALUES LESS THAN (100000)
, SUBPARTITION p_se_extraordinary VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_northcentral VALUES ('SD', 'WI')
( SUBPARTITION p_nc_low VALUES LESS THAN (1000)
, SUBPARTITION p_nc_average VALUES LESS THAN (10000)
, SUBPARTITION p_nc_high VALUES LESS THAN (100000)
, SUBPARTITION p_nc_extraordinary VALUES LESS THAN (MAXVALUE)
)
, PARTITION p_southcentral VALUES ('OK', 'TX')
( SUBPARTITION p_sc_low VALUES LESS THAN (1000)
, SUBPARTITION p_sc_average VALUES LESS THAN (10000)
, SUBPARTITION p_sc_high VALUES LESS THAN (100000)
, SUBPARTITION p_sc_extraordinary VALUES LESS THAN (MAXVALUE)
)
) ENABLE ROW MOVEMENT;




--为所有分区各创建5 个范围子分区
create table test_lr1
(
    id NUMBER(20) not null primary key,
    name VARCHAR2(20) not null,
    age NUMBER(10) not null,
    sex VARCHAR2(10) not null,
    cardid NUMBER(30) not null,
    joindate DATE not null,
    region VARCHAR2(12) not null,
    tel VARCHAR2(12) not null,
    email VARCHAR2(30) not null,
    recommend VARCHAR2(10),
    identifier VARCHAR2(100)
) tablespace test_ts
partition by list(sex)
subpartition by range(joindate)
(
partition p_m values('男')
(
subpartition p_m_2014 values less than
(to_date('2015-01-01','YYYY-MM-DD')),
subpartition p_m_2015 values less than
(to_date('2016-01-01','YYYY-MM-DD')),
subpartition p_m_2016 values less than
(to_date('2017-01-01','YYYY-MM-DD')),
subpartition p_m_2017 values less than
(to_date('2018-01-01','YYYY-MM-DD')),
subpartition p_m_max values less than (maxvalue)
),
partition p_w values('女')
(
subpartition p_w_2014 values less than
(to_date('2015-01-01','YYYY-MM-DD')),
subpartition p_w_2015 values less than
(to_date('2016-01-01','YYYY-MM-DD')),
subpartition p_w_2016 values less than
(to_date('2017-01-01','YYYY-MM-DD')),
subpartition p_w_2017 values less than
(to_date('2018-01-01','YYYY-MM-DD')),
subpartition p_w_max values less than (maxvalue)
)
);
~~~



#### LIST-HASH

~~~sql
--Example 4–13 Creating a composite list-hash partitioned table
CREATE TABLE accounts2
( id NUMBER
, account_number NUMBER
, customer_id NUMBER
, balance NUMBER
, branch_id NUMBER
, region VARCHAR(2)
, status VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY HASH (customer_id) SUBPARTITIONS 8
( PARTITION p_northwest VALUES ('OR', 'WA')
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
, PARTITION p_southeast VALUES ('FL', 'GA')
, PARTITION p_northcentral VALUES ('SD', 'WI')
, PARTITION p_southcentral VALUES ('OK', 'TX')
);


create table test_lh1
(     id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by list(sex)
subpartition by hash(region) subpartitions 4
(
partition p_m values('男'),
partition p_w values('女'),
partition p_max values(default)
);
~~~



#### LIST-LIST

~~~sql
--Example 4–14 Creating a composite list-list partitioned table
CREATE TABLE accounts3
( id NUMBER
, account_number NUMBER
, customer_id NUMBER
, balance NUMBER
, branch_id NUMBER
, region VARCHAR(2)
, status VARCHAR2(1)
)
PARTITION BY LIST (region)
SUBPARTITION BY LIST (status)
( PARTITION p_northwest VALUES ('OR', 'WA')
( SUBPARTITION p_nw_bad VALUES ('B')
, SUBPARTITION p_nw_average VALUES ('A')
, SUBPARTITION p_nw_good VALUES ('G')
)
, PARTITION p_southwest VALUES ('AZ', 'UT', 'NM')
( SUBPARTITION p_sw_bad VALUES ('B')
, SUBPARTITION p_sw_average VALUES ('A')
, SUBPARTITION p_sw_good VALUES ('G')
)
, PARTITION p_northeast VALUES ('NY', 'VM', 'NJ')
( SUBPARTITION p_ne_bad VALUES ('B')
, SUBPARTITION p_ne_average VALUES ('A')
, SUBPARTITION p_ne_good VALUES ('G')
)
, PARTITION p_southeast VALUES ('FL', 'GA')
( SUBPARTITION p_se_bad VALUES ('B')
, SUBPARTITION p_se_average VALUES ('A')
, SUBPARTITION p_se_good VALUES ('G')
)
, PARTITION p_northcentral VALUES ('SD', 'WI')
( SUBPARTITION p_nc_bad VALUES ('B')
, SUBPARTITION p_nc_average VALUES ('A')
, SUBPARTITION p_nc_good VALUES ('G')
)
, PARTITION p_southcentral VALUES ('OK', 'TX')
( SUBPARTITION p_sc_bad VALUES ('B')
, SUBPARTITION p_sc_average VALUES ('A')
, SUBPARTITION p_sc_good VALUES ('G')
)
);



--按照性别、年龄分区
create table test_ll1
(     id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by list(sex)
subpartition by list(age)
(
partition p_m values('男')
(
subpartition p_m_30 values (30),
subpartition p_m_60 values (60),
subpartition p_m_max values (default)
),
partition p_w values('女')
(
subpartition p_w_30 values (30),
subpartition p_w_60 values (60),
subpartition p_w_max values (default)
)
);
~~~

### 间隔分区

~~~sql
--Example 4–4 Creating an interval-partitioned table
CREATE TABLE interval_sales
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id)
INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))
( PARTITION p0 VALUES LESS THAN (TO_DATE('1-1-2008', 'DD-MM-YYYY')),
PARTITION p1 VALUES LESS THAN (TO_DATE('1-1-2009', 'DD-MM-YYYY')),
PARTITION p2 VALUES LESS THAN (TO_DATE('1-7-2009', 'DD-MM-YYYY')),
PARTITION p3 VALUES LESS THAN (TO_DATE('1-1-2010', 'DD-MM-YYYY')) );


--Example 4–16 Creating a composite interval-hash partitioned table
CREATE TABLE sales3
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
SUBPARTITION BY HASH (cust_id) SUBPARTITIONS 4
( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;


CREATE TABLE sales4
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
SUBPARTITION BY hash(cust_id)
SUBPARTITION template
( SUBPARTITION p1 TABLESPACE ts1
, SUBPARTITION p2 TABLESPACE ts2
, SUBPARTITION p3 TABLESPACE ts3
, SUBPARTITION P4 TABLESPACE ts4
)
( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy'))
) PARALLEL;


--Example 4–17 Creating a composite interval-list partitioned table
CREATE TABLE sales5
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY LIST (channel_id)
SUBPARTITION TEMPLATE
( SUBPARTITION p_catalog VALUES ('C')
, SUBPARTITION p_internet VALUES ('I')
, SUBPARTITION p_partners VALUES ('P')
, SUBPARTITION p_direct_sales VALUES ('S')
, SUBPARTITION p_tele_sales VALUES ('T')
)
( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;


--Example 4–18 Creating a composite interval-range partitioned table
CREATE TABLE sales6
( prod_id NUMBER(6)
, cust_id NUMBER
, time_id DATE
, channel_id CHAR(1)
, promo_id NUMBER(6)
, quantity_sold NUMBER(3)
, amount_sold NUMBER(10,2)
)
PARTITION BY RANGE (time_id) INTERVAL (NUMTODSINTERVAL(1,'DAY'))
SUBPARTITION BY RANGE(amount_sold)
SUBPARTITION TEMPLATE
( SUBPARTITION p_low VALUES LESS THAN (1000)
, SUBPARTITION p_medium VALUES LESS THAN (4000)
, SUBPARTITION p_high VALUES LESS THAN (8000)
, SUBPARTITION p_ultimate VALUES LESS THAN (maxvalue)
)
( PARTITION before_2000 VALUES LESS THAN (TO_DATE('01-JAN-2000','dd-MON-yyyy')))
PARALLEL;
~~~

#### interval-range

~~~sql
--创建按月分区的分区表
create table test_i1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
interval (numtoyminterval(1,'month') )
(
partition p_before_2010 values less than
(to_date('2010-01-01','YYYY-MM-DD')),
partition p_001 values less than (to_date('2010-02-01','YYYY-MM-DD')),
partition p_002 values less than (to_date('2010-03-01','YYYY-MM-DD'))
);

/*
默认建表的时候会创建3个分区，p_before_2010、p_001、p_002插入数据的时候会根据间隔生成多个分区，
生成分区的数量取决于数据的多少
*/



--创建一个以天为间隔的分区表
create table test_i2
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
interval (numtodsinterval(1,'day') )
(
partition p_before_2010 values less than
(to_date('2010-01-01','YYYY-MM-DD')),
partition p_001 values less than (to_date('2010-02-01','YYYY-MM-DD')),
partition p_002 values less than (to_date('2010-03-01','YYYY-MM-DD'))
);


--间隔复合分区
create table test_ir1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
interval (numtoyminterval(1,'month') )
subpartition by range(age)
subpartition template
(
subpartition sub_p_30 values less than(30)，
subpartition sub_p_60 values less than(60),
subpartition sub_p_max values less than(maxvalue)
)
(
partition p_before_2010 values less than
(to_date('2010-01-01','YYYY-MM-DD')),
partition p_001 values less than (to_date('2010-02-01','YYYY-MM-DD')),
partition p_002 values less than (to_date('2010-03-01','YYYY-MM-DD'))
);
~~~

#### interval-hash

~~~sql
create table test_ih1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
interval (numtoyminterval(1,'month') )
subpartition by hash(cardid) subpartitions 4
(
partition p_before_2010 values less than
(to_date('2010-01-01','YYYY-MM-DD')),
partition p_001 values less than (to_date('2010-02-01','YYYY-MM-DD')),
partition p_002 values less than (to_date('2010-03-01','YYYY-MM-DD'))
);
~~~

#### interval-list

~~~sql
create table test_il1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by range(joindate)
interval (numtoyminterval(1,'month') )
subpartition by list(sex)
subpartition template
(
subpartition sub_p_m values('男')，
subpartition sub_p_w values('女')
)
(
partition p_before_2010 values less than
(to_date('2010-01-01','YYYY-MM-DD')),
partition p_001 values less than (to_date('2010-02-01','YYYY-MM-DD')),
partition p_002 values less than (to_date('2010-03-01','YYYY-MM-DD'))
);
~~~



### 虚拟列分区

说明

~~~sql
--定义一个虚拟列的语法：
column_name [datatype] [GENERATED ALWAYS] AS [expression] [VIRTUAL]
1 只能在堆组织表(普通表)上创建虚拟列,不能在索引组织表、外部表、临时表上创建虚拟列
2 虚拟列不能是LOB或者RAW类型
3 虚拟列的值并不是真实存在的,只有用到时,才根据表达式计算出虚拟列的值,磁盘上并不存放
4 可把虚拟列当做分区关键字建立分区表,这是ORACLE 11g的另一新特性--虚拟列分区
5 可在虚拟列上建立索引
6 如果在已经创建的表中增加虚拟列时,若没有指定虚拟列的字段类型, ORACLE会根据generated always as后面的表达式计算的结果自动设置该字段的类型
7 虚拟列的值由ORACLE根据表达式自动计算得出,不可以做UPDATE和INSERT操作,可以对虚拟列做DELETE操作
8 表达式中的所有列必须在同一张表
9 表达式不能使用其它虚拟列

generated always as
(
case
when sales_amt <= 10000 then 'LOW'
when sales_amt > 10000 and sales_amt <= 100000 then 'MEDIUM'
when sales_amt > 100000 and sales_amt <= 1000000 then 'HIGH'
else 'ULTRA'
end
)

generated always as
(quantity_sold * amount_sold)
generated always as
(TO_NUMBER(TO_CHAR(Joindate, 'MM')))
~~~



~~~sql
--Example 4–22 Creating a table with a virtual column for the subpartitioning key
CREATE TABLE sales7
( prod_id NUMBER(6) NOT NULL
, cust_id NUMBER NOT NULL
, time_id DATE NOT NULL
, channel_id CHAR(1) NOT NULL
, promo_id NUMBER(6) NOT NULL
, quantity_sold NUMBER(3) NOT NULL
, amount_sold NUMBER(10,2) NOT NULL
, total_amount AS (quantity_sold * amount_sold)
)
PARTITION BY RANGE (time_id) INTERVAL (NUMTOYMINTERVAL(1,'MONTH'))
SUBPARTITION BY RANGE(total_amount)
SUBPARTITION TEMPLATE
( SUBPARTITION p_small VALUES LESS THAN (1000)
, SUBPARTITION p_medium VALUES LESS THAN (5000)
, SUBPARTITION p_large VALUES LESS THAN (10000)
, SUBPARTITION p_extreme VALUES LESS THAN (MAXVALUE)
)
(PARTITION sales_before_2007 VALUES LESS THAN
(TO_DATE('01-JAN-2007','dd-MON-yyyy'))
)
ENABLE ROW MOVEMENT
PARALLEL NOLOGGING;



--表中有一个日期列，根据日期列进行分区，每个月份一个分区
create table test_v1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100),
      partition_month number(30) generated always as
      (to_number(to_char(joindate,'MM')))
) tablespace test_ts
partition by list(partition_month)
(
partition P_M1 values(1),
partition P_M2 values(2),
partition P_M3 values(3),
partition P_M4 values(4),
partition P_M5 values(5),
partition P_M6 values(6),
partition P_M7 values(7),
partition P_M8 values(8),
partition P_M9 values(9),
partition P_M10 values(10),
partition P_M11 values(11),
partition P_M12 values(12)
);
~~~

### 系统分区

​		11g以前的分区表,需要指定一个或多个分区字段,并根据这个分区字段的值,按照一定的算法( RANGE, HASH和LIST )来决定一条记录属于那个分区。从11g开始, Oracle允许用户不指定分区列,完全根据程序来控制数据存储在那个分区中。这就是11g提供的系统分区功能。  

​		在以前,确定了分区列和分区方式,那么一条数据属于哪个分区也就被确定下来。而对于系统分区而言,分区是分区,数据是数据,二者没有对应的关系。数据可以被放在任意一个分区中,这不是由数据本身决定的,而是应用程序在插入时确定的。

~~~sql
create table test_s1
(
      id NUMBER(20) not null primary key,
      name VARCHAR2(20) not null,
      age NUMBER(10) not null,
      sex VARCHAR2(10) not null,
      cardid NUMBER(30) not null,
      joindate DATE not null,
      region VARCHAR2(12) not null,
      tel VARCHAR2(12) not null,
      email VARCHAR2(30) not null,
      recommend VARCHAR2(10),
      identifier VARCHAR2(100)
) tablespace test_ts
partition by system
(partition P1,partition P2,partition P3,partition P4);

/*对于系统方法分区的表，必须对DML使用分区扩展名或绑定变量，也就插入值的时候不能按照所有的值插入，只能插入值*/
~~~

### 参考分区

​		参考分区功能,对于主子表关系,如果对主表进行了分区,那么可以在子表上根据外键约束来建立对应主表的分区。

​		这样主表和子表采用相同的等同分区方式,不但连接的时候可以利用PARTITION-WISE JOIN ,而且对于主子表的分区操作也会十分方便。而且,这种方式并不需要在子表中存在主表的分区列。

~~~sql
--Example 4–9 Creating reference-partitioned tables
CREATE TABLE orders(
      order_id NUMBER(12),
      order_date TIMESTAMP,
      order_mode VARCHAR2(8),
      customer_id NUMBER(6),
      order_status NUMBER(2),
      order_total NUMBER(8,2),
      sales_rep_id NUMBER(6),
      promotion_id NUMBER(6),
CONSTRAINT orders_pk PRIMARY KEY(order_id)
)
PARTITION BY RANGE(order_date)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD')),
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD')),
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD')),
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
);


CREATE TABLE order_items( 
      order_id NUMBER(12) NOT NULL,
      line_item_id NUMBER(3) NOT NULL,
      product_id NUMBER(6) NOT NULL,
      unit_price NUMBER(8,2),
      quantity NUMBER(8),
CONSTRAINT order_items_fk
FOREIGN KEY(order_id) REFERENCES orders(order_id)
)
PARTITION BY REFERENCE(order_items_fk);
--如上是子表的建表语句，子表并没有分区，创建之后系统给出的表定义如下：

-- Create table
create table ORDER_ITEMS
(
  order_id     NUMBER(12) not null,
  line_item_id NUMBER(3) not null,
  product_id   NUMBER(6) not null,
  unit_price   NUMBER(8,2),
  quantity     NUMBER(8)
)
partition by  (ORDER_ID)
(
  partition P2014
    tablespace USERS
    pctfree 10
    initrans 1
    maxtrans 255,
  partition P2015
    tablespace USERS
    pctfree 10
    initrans 1
    maxtrans 255,
  partition P2016
    tablespace USERS
    pctfree 10
    initrans 1
    maxtrans 255,
  partition P2017
    tablespace USERS
    pctfree 10
    initrans 1
    maxtrans 255
);
-- Create/Recreate primary, unique and foreign key constraints 
alter table ORDER_ITEMS
  add constraint ORDER_ITEMS_FK foreign key (ORDER_ID)
  references ORDERS (ORDER_ID);
~~~

### INTERVAL-REFERENCE 分区

​		把interval分区和reference分区结合,这样主表自动增加一个分区后,所有字表,孙子表 重重孙子表上都会自动随着外界的数据增加，自动创建新的分区

### 分区表的管理

#### 增加表分区

alter table tbname add partition ...针对list,range,要注意边界分区；hash 没有边界分区的限制

```sql
--01 没有边界的范围分区(普通)
alter table test_r1
add partition p2015 values less than
(to_date('2016-01-01','YYYY-MM-DD'))
tablespace test_r1_p2015;

alter table test_r1
add partition p2016 values less than
(to_date('2017-01-01','YYYY-MM-DD'))
tablespace test_r1_p2016;

alter table test_r1
add partition p2017 values less than
(to_date('2018-01-01','YYYY-MM-DD'))
tablespace test_r1_p2017;



--02.有边界的范围/列表分区（maxvalue/default）
alter table test_r1
add partition p_max values less than (maxvalue)
tablespace test_ts;
--加上边界之后再新增分区就会报错：
alter table test_r1
add partition p2020 values less than
(to_date('2021-01-01','YYYY-MM-DD'))
tablespace test_r1_p2017;
ERROR at line 2:
ORA-14074: partition bound must collate higher than that of the last partition



--03.哈希分区
alter table test_h1 add partition;
alter table test_h1 add partition p6 tablespace test;
```







# 索引

## 索引说明

**索引的作用:**

1)索引是数据库对象之一,用于加快数据的检索,类似于书籍的索引,在数据库中索引可以减少数据库程序查询结果时需要读取的数据量,类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。

2)索引是建立在表上的可选对象;索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式,从而提高检索效率

3)索引在逻辑上和物理上都与相关的表和数据无关,当创建或者删除一个索引时,不会影响基本的表;

4)索引一旦建立,在表上进行DML操作时(例如在执行插入、修改或者删除相关操作时) , oracle会自动管理索引,索引删除,不会对表产生影响

5)索引对用户是透明的,无论表上是否有索引, sql语句的用法不变

6) oracle创建主键时会自动在该列上创建索引

**索引原理**

1,若没有索引,搜索某个记录时(例如查找name='test')需要搜索所有的记录,因为不能保证只有一个test,必须全部搜索一遍

2.若在name上建立索引, oracle会对全表进行一次搜索,将每条记录的name值哪找升序排列,然后构建索引条目( name和rowid ) ,存储到索引段中,查询name为test时即可直接查找对应地方

3.创建了索引并不一定就会使用, oracle自动统计表的信息后,决定是否使用索引,表中数据很少时使用全表扫描速度已经很快,没有必要使用索引



索引分类：
    **逻辑分类:**
		单列或多列
		唯一索引和非唯一索引
		函数索引
		Doman
	**物理分类:**
		B-TREE
		Bitmap

**B-tree特性**

~~~
适合与大量的增、删、改(OLTP)不能用包含OR操作符的查询;
适合高基数的列(唯一值多);
典型的树状结构;
每个结点都是数据块;
大多都是物理上一层、两层或三层不定,逻辑上三层;叶子块数据是排序的,从左向右递增;
在分支块和根块中放的是索引的范围。
~~~

**Bitmap特性**

~~~
位图索引主要用于决策支持系统或静态数据，不支持行级锁定
做UPDATE代价非常高;
非常适合OR操作符的查询;
基数比较少的时候才能建位图索引。
~~~

**单列索引**

~~~
一列的索引
~~~

**复合/组合索引**
~~~
where a=1 and b=2
当某个索引包含有多个已索引的列时,称这个索引为组合(concatented )索引.
注意:只有在使用到索引的前导索引时才可以使用组合索引
即如果索引建立在多个列上,只有它的第一个列被where子句引用时,优化器才会使用该索引,即至少要包含组合索引的第一列
~~~
**函数索引**
~~~
当经常要访问一些函数或者表达式时,可以将其存储在索引中,这样下次访问时,该值已经计算出来了,可以加快查询速度
函数索引既可以使用B树索引,也可以使用位图索引;当函数结果不确定时采用B树索引,结果是固定的某几个值时使用位图索引
函数索引中可以使用len, trim, substr, upper (每行返回独立结果) ,不能使用如sum, max, min, avg等
~~~

## 索引管理

~~~sql
--索引创建语法
CREATE [UNIQUE] | [BITMAP] INDEX index_name --unique 表示唯一索引
ON table_name([column1 [ASC|DESC],column2 --bitmap，创建位图索引
[ASC|DESC],…] | [express])
[TABLESPACE tablespace_name]
[PCTFREE n1] --指定索引在数据块中空闲空间
[STORAGE (INITIAL n2)]
[NOLOGGING] --表示创建和重建索引时允许对表做DML 操作，默认情况下不应该使用
[NOLINE]
[NOSORT]; --表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用


--1、创建索引
--创建测试表
create table test(id int,name varchar(200),sex varchar(10),status varchar(10));
--单列索引
create index i_id on test (id); 
--单列索引指定表空间
create index i_name on test (name) tablespace test_ts;
--组合索引
create index i_id_name on test(id,name);
--位图索引
create bitmap index i_sex on test(sex);

--2、修改索引
--重命名索引
alter index i_id rename to i1_id;
--合并索引
--表使用一段时间之后会产生碎片，对索引的效率有影响，这个时候就需要合并或者重建索引，合并索引更好一点，不用额外的存储空间
alter index i1_id coalesce;

--3、重建索引
drop index i1_id;
create index i_id on test (id);
--rebuild
alter index i_id rebuild; --会锁表。
alter index i_id rebuild online;

--4、删除索引
drop index i_id;

--5、索引相关数据字典
select * from dba_indexes;
select * from dba_ind_columns
select * from all_indexes;
select * from all_ind_columns;
select * from user_indexes;
select * from user_ind_columns;

select * from dba_indexes where owner='YAOKANG';
select * from dba_indexes where table_name='TEST';

select *
  from dba_ind_columns
 where index_owner = 'YAOKANG'
   and table_name = 'TEST';

-- 查询索引的名称、列名、类型、表空间
select index_name, column_name, index_type, uniqueness, tablespace_name
  from dba_indexes natural
  join dba_ind_columns
where table_name = 'TEST';
~~~

## 分区索引

​		对于索引，需要区分创建的是全局索引，或本地索引：

​		分区索引既可以与分区表相对独立（全局索引（global index）），也可以采用与分区表相同的分区方式（本地索引（local index））。

​		普通表可以建分区索引，分区表可以建非分区的global index，也可以建range 或hash 分区的global index，也可以建基于分区的local index。

使用方式：

| 表     | 索引   |
| ------ | ------ |
| 分区   | 不分区 |
| 分区   | 分区   |
| 不分区 | 分区   |
| 不分区 | 不分区 |

### 全局索引(global index)

~~~
即可以分区，也可以不分区。即可以建range 分区，也可以建hash 分区，即可建于分区表，又可创建于非分区表上，就是说，全局索引是完全独立的，因此它也需要我们更多的维护操作。
~~~



### 本地索引(local index)

​		其分区形式与表的分区完全相同，依赖列相同，存储属性也相同。对于本地索引，其索引分区的维护自动进行，就是说你add/drop/split/truncate 表的分区时，本地索引会自动维护其索引分区。

​		本地索引又可以分为**有前缀(prefix)的索引**和**无前缀(nonprefix)的索引**。

​		而全局索引目前只支持有前缀的索引。

​		如果本地索引的索引列以分区键开头（分区用什么列分的，索引就用什么列创建，11对应），则称为**前缀局部索引**。

​		如果本地索引的列不是以分区键开头，或者不包含分区键列（分区用什么列分的，索引不用什么列创建。），则称为**非前缀索引**。

​		全局索引的索引列必须是以索引分区键作为其前几列。

### 分区索引使用场景

~~~
1）当有表的分区或子分区操作维护的时候，本地索引提供更好的可用性；如合并分区时，只有合并的表分区的分区索引失效,而非分区索引以及全局分区索引在合并、删除表分区后全部失效；可以单独重建本地索引；若只有一个分区需要维护，则只有一个本地索引受影响。
2）本地索引可以提高性能，因为数据大，很多分区必然会被并行的查询。
3）对于历史表，本地索引是必须，这样在有规律的drop分区的时候，比较方便。
4）本地索引多应用于数据仓库环境中。
5）在非分区字段上建立unique 索引只能建全局索引。
6）全局索引不支持位图索引，全局分区索引只能是B树索引。
7）全局索引多应用于oltp（交易性事务）系统中。
8）全局分区索引只按范围或者散列hash分区
9）表用a列作分区，索引用b做局部分区索引，若where条件中用b来查询，那么oracle会扫描所有的表和索引的分区，成本会比分区更高，此时可以考虑用b做全局分区索引。也就是说where条件有分区字段（表分区而非索引分区）使用local index，where条件没有有分区字段（表分区而非索引分区）使用global index 
~~~

​		本地分区索引是对单个分区的，每个分区索引只指向一个表分区，全局索引则不然，一个分区索引能指向n 个表分区，同时，一个表分区，也可能指向n 个索引分区，对分区表中的某个分区做truncate 或者move，shrink 等，可能会影响到n 个全局索引分区，正因为这点，本地分区索引具有更高的可用性。

### 分区索引的创建

普通表可以建分区索引,分区表可以建非分区的global index ,也可以建range或hash分区的global index ,也可以建基于分区的local index

#### 本地索引

add/drop/split/truncate 表的分区时，local index会自动维护其索引分区。

```sql
--1.有前缀的本地索引(joindate为分区键)
create index i_test_r1_joindate on test_r1(joindate) local;
--2.无前缀的本地索引
create index i_test_r1_cardid on test_r1(cardid) local;
--3.自定义有前缀的本地索引分区(joindate为分区键)
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) local
(
partition p_i_2014 tablespace test_r1_p2014,
partition p_i_2015 tablespace test_r1_p2015,
partition p_i_2016 tablespace test_r1_p2016,
partition p_i_2017 tablespace test_r1_p2017
);
--4.获取创建索引的ddl语句
select dbms_metadata.get_ddl('INDEX','I_TEST_R1_JOINDATE','YAOKANG') index_name from dual;
--1 创建索引的ddl
CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
 PCTFREE 10 INITRANS 2 MAXTRANS 255 
 STORAGE(
 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
(PARTITION "P2014" NOCOMPRESS 
 PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
 STORAGE(
 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
 TABLESPACE "TEST_R1_P2014" , 
PARTITION "P2015" NOCOMPRESS 
 PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
 STORAGE(
 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
 TABLESPACE "TEST_R1_P2015" , 
PARTITION "P2016" NOCOMPRESS 
 PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
 STORAGE(
 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
 TABLESPACE "TEST_R1_P2016" , 
PARTITION "P2017" NOCOMPRESS 
 PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
 STORAGE(
 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
 TABLESPACE "TEST_R1_P2017" ) ;

select dbms_metadata.get_ddl('INDEX','I_TEST_R1_CARDID','YAOKANG') index_name from dual;
--2 创建索引的ddl
  CREATE INDEX "YAOKANG"."I_TEST_R1_CARDID" ON "YAOKANG"."TEST_R1" ("CARDID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "P2014" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2014" , 
 PARTITION "P2015" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2015" , 
 PARTITION "P2016" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2016" , 
 PARTITION "P2017" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2017" ) 
 
--3 创建索引的ddl
 CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) LOCAL
 (PARTITION "P_I_2014" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2014" , 
 PARTITION "P_I_2015" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2015" , 
 PARTITION "P_I_2016" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2016" , 
 PARTITION "P_I_2017" NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2017" ) 
```

​		如上创建本地索引的没有定义任何分区，默认按照每个分区创建索引，索引的表空间也在默认的表空间里面，也就是索引继承表分区的属性

​		生产环境建议使用第三种自定义本地索引分区，这样可以指定索引表空间，不建议索引和数据表空间一致，这样影响性能

```sql
--查看分区索引的相关数据字典
select * from dba_part_indexes where table_name='TEST_R1';
select * from dba_ind_partitions where INDEX_name='I_TEST_R1_JOINDATE';
select * from dba_indexes where table_name='TEST_R1';
select * from dba_ind_columns where table_name='TEST_R1';
--查看索引段的分配
select segment_name, segment_type, sum(bytes) / 1024 / 1024
from dba_segments
where segment_name in
(select index_name from dba_indexes where table_name = 'TEST_R1')
group by segment_name, segment_type;
--查询每个索引分区的分配
select segment_name, segment_type,partition_name, bytes / 1024 / 1024
from dba_segments
where segment_name in
(select index_name from dba_indexes where table_name = 'TEST_R1');
```

#### 全局索引

​		前缀范围，hash

​		因为全局索引只能建立前缀索引，表的joindate列做了分区，也只能用这个列来做索引，如果查询的时候joindate列不在查询范围内，那么只能建本地索引

##### 前缀范围全局索引创建

```sql
--1.范围分区global索引
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) global
partition by range(joindate)
(
partition p2014 values less than (to_date('2015-01-01','YYYY-MM-DD'))
tablespace test_r1_p2014,
partition p2015 values less than (to_date('2016-01-01','YYYY-MM-DD'))
tablespace test_r1_p2015,
partition p2016 values less than (to_date('2017-01-01','YYYY-MM-DD'))
tablespace test_r1_p2016,
partition p2017 values less than (to_date('2018-01-01','YYYY-MM-DD'))
tablespace test_r1_p2017,
partition p_max values less than (maxvalue) tablespace test_ts
);
--2.非分区的global 索引
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) global;

--3
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate);


--索引的ddl
--1
CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  GLOBAL PARTITION BY RANGE ("JOINDATE") 
 (PARTITION "P2014"  VALUES LESS THAN (TO_DATE(' 2015-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2014" , 
 PARTITION "P2015"  VALUES LESS THAN (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2015" , 
 PARTITION "P2016"  VALUES LESS THAN (TO_DATE(' 2017-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2016" , 
 PARTITION "P2017"  VALUES LESS THAN (TO_DATE(' 2018-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_R1_P2017" , 
 PARTITION "P_MAX"  VALUES LESS THAN (MAXVALUE) NOCOMPRESS 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 LOGGING 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "TEST_TS" ) 
--2
CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" 
--3
CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" 
```

##### 前缀hash全局索引创建

```sql
--1、
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) global
partition by hash(joindate)
(
partition p2014,
partition p2015,
partition p2016,
partition p2017
);
--2
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) global;
--3
drop index i_test_r1_joindate;
create index i_test_r1_joindate on test_r1(joindate) ;



--索引ddl
--1
CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  GLOBAL PARTITION BY HASH ("JOINDATE") 
 (PARTITION "P2014" NOCOMPRESS 
  TABLESPACE "USERS" , 
 PARTITION "P2015" NOCOMPRESS 
  TABLESPACE "USERS" , 
 PARTITION "P2016" NOCOMPRESS 
  TABLESPACE "USERS" , 
 PARTITION "P2017" NOCOMPRESS 
  TABLESPACE "USERS" )
  
--2
  CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" 
--3
  CREATE INDEX "YAOKANG"."I_TEST_R1_JOINDATE" ON "YAOKANG"."TEST_R1" ("JOINDATE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" 
```

全局需要我们手工维护（删除分区索引仍在，查询的时候还是会扫描），本地索引自动管理（删除分区索引自动删除）

```sql
--查询当前索引分区信息（使用如上1创建的索引）
select * from dba_ind_partitions where INDEX_name='I_TEST_R1_JOINDATE';
yaokang@orclcdb(134)> select INDEX_NAME,PARTITION_NAME,STATUS from dba_ind_partitions where INDEX_name='I_TEST_R1_JOINDATE';

INDEX_NAME           PARTITION_ STATUS
-------------------- ---------- ----------
I_TEST_R1_JOINDATE   P2014      USABLE
I_TEST_R1_JOINDATE   P2015      USABLE
I_TEST_R1_JOINDATE   P2016      USABLE
I_TEST_R1_JOINDATE   P2017      USABLE
--删除一个分区
alter table test_r1 drop partition p2017;
--如下此时对应分区的全局索引还存在
yaokang@orclcdb(134)> select INDEX_NAME,PARTITION_NAME,STATUS from dba_ind_partitions where INDEX_name='I_TEST_R1_JOINDATE';

INDEX_NAME           PARTITION_ STATUS
-------------------- ---------- ----------
I_TEST_R1_JOINDATE   P2014      USABLE
I_TEST_R1_JOINDATE   P2015      USABLE
I_TEST_R1_JOINDATE   P2016      USABLE
I_TEST_R1_JOINDATE   P2017      USABLE


--查询local index
select INDEX_NAME,PARTITION_NAME,STATUS from dba_ind_partitions where INDEX_name='I_TEST_R1_CARDID';
yaokang@orclcdb(134)> select INDEX_NAME,PARTITION_NAME,STATUS from dba_ind_partitions where INDEX_name='I_TEST_R1_CARDID';

INDEX_NAME           PARTITION_ STATUS
-------------------- ---------- ----------
I_TEST_R1_CARDID     P2014      USABLE
I_TEST_R1_CARDID     P2015      USABLE
I_TEST_R1_CARDID     P2016      USABLE
--如上分区删除之后，对应分区的本地索引自动被删除


--全局分区索引必须要加上前缀，以下非前缀就报错
create index ih_test_r1_joindate on test_r1(cardid) global
partition by hash(joindate)
(
partition p2014,
partition p2015,
partition p2016,
partition p2017
);
ERROR at line 2:
ORA-14038: GLOBAL partitioned index must be prefixed
--如上报错，全局分区索引必须要加上前缀，也就是说索引列必须是joindate（表分区的列）

--全局分区索引不能与位图索引一起使用
create bitmap index ih_test_r1_joindate on test_r1(joindate) global
partition by hash(joindate)
(
partition p2014,
partition p2015,
partition p2016,
partition p2017
);
ERROR at line 1:
ORA-25113: GLOBAL may not be used with a bitmap index
```

### 分区索引的重建

```sql
--分区索引必须对每个分区重建，不能作为整体重建
alter index i_test_r1_joindate rebuild online nologging;
ERROR at line 1:
ORA-14086: a partitioned index may not be rebuilt as a whole
--删除重建，不在线默认写日志（要锁表，会导致业务不可用），在线不写日志

--查询失效的索引
select * from dba_ind_partitions where index_owner='YAOKANG' and status='UNUSABLE';
select * from dba_ind_partitions where INDEX_name='I_TEST_R1_JOINDATE';

--全局索引
--hash 索引分区
alter index i_test_r1_joindate rebuild partition P2014 online;
alter index i_test_r1_joindate rebuild partition P2015 online;
alter index i_test_r1_joindate rebuild partition P2016 online;
alter index i_test_r1_joindate rebuild partition P2017 online;
--范围索引分区
alter index i_test_r1_joindate rebuild partition P2014 online nologging;
--本地索引
alter index i_test_r1_joindate rebuild partition P2014 online nologging;
```









# 约束

## 5种常见约束

~~~sql
-- 1.not null (非空约束)
--1.1 创建表的时候
create table itpux01(id number not null primary key,name varchar2(20));
--1.2 在已经创建的表加添加
create table itpux02(id number,name varchar2(20));
alter table itpux02 modify id not null;
--1.3 验证。
insert into itpux02 values(null,'name');
insert into itpux02 values(1,'name');
select * from itpux02;
--1.4 删除
alter table itpux02 modify id null;
insert into itpux02 values(null,'name');
select * from itpux02;
insert into itpux02 values(2,'name');



-- 2.primary key 约束
主键约束就是一个唯一索引
--2.1 创建表的时候
drop table itpux01
create table itpux01(id number not null primary key,name varchar2(20));
--2.2 在已经创建的表加添加
drop table itpux02;
create table itpux02(id number,name varchar2(20));
alter table itpux02 add constraint itpux02_id_con primary key(id);--建议命名
--alter table itpux02 drop constraint itpux02_id_con;
alter table itpux02 add primary key(id);
--2.3 删除
alter table itpux02 drop constraint itpux02_id_con;
alter table itpux02 drop constraint SYS_C0011169;



--3.unique 约束
--3.1 创建表的时候
create table itpux03(id number not null,name varchar2(20) unique);
insert into itpux03 values(1,'name1');
insert into itpux03 values(2,'name2');
--3.2 删除
alter table itpux03 drop unique(name);
insert into itpux03 values(3,'name2');
--3.3 后期添加
alter table itpux03 add unique(name);
delete from itpux03 where id=3;
alter table itpux03 add unique(name);


--4.Check 约束
--4.1 新建表添加约束
create table itpux04(
id number not null primary key,
name varchar2(20),
age number constraint itpux04_age_con check(age>17));
insert into itpux04 values (1,'mm',16);
insert into itpux04 values (2,'mm',18);
--4.2 删除
alter table itpux04 drop constraint itpux04_age_con;
--4.3 后期
alter table itpux04 add constraint itpux04_age_con check(age>17);



--5.Foreign key 约束
--5.1 创建外键
create table itpux051 (
jobid number not null primary key,
name1 varchar2(20),
age number(3)
);
create table itpux052 (
no number not null primary key,
dcname varchar2(20),
dcid number references itpux051(jobid)
);

insert into itpux052 values (1,'dc1008',20161218);--error
insert into itpux051 values (20161218,'风哥',31);
insert into itpux052 values (1,'dc1008',20161218);
select * from itpux051;
select * from itpux052;
--删除
alter table itpux052 drop constraint SYS_C0011182;
drop table itpux051;
drop table itpux051 cascade constraints;
--后期增加
alter table itpux052 add constraint itpux052_dcid_con foreign key(dcid)
references itpux051(jobid);
~~~

## 约束的管理

~~~sql
--1.约束表级定义与列级定义
--1.1 表级定义：定义了所有列之后再定义约束
create table itpux08(
id number(8),
name varchar2(50),
constraint pk_itpux08_id primary key(id)
);
--1.2 列级定义：定义列的同时定义约束
create table itpux09(
id number(8) constraint pk_itpux09_id primary key,
name varchar2(50)
);




--2.约束的disable/enable,validate/novalidate 的区别
--disable 禁用
--disable validate --关闭后，不能增删改
--disable novalidate --关闭后，可以增删改
--enable 启用
--enable validate --启用后，进行所有约束，有的，新加的
--enable novalidate --启用后，对新加入的约束，对旧的不约束
--2.1 非主键的
create table itpux06(
id number not null primary key,
name varchar2(20),
age number constraint itpux06_age_con check(age>17));
alter table itpux06 disable constraint itpux06_age_con; --novalidate
insert into itpux06 values(2,'name2',18);
alter table itpux06 enable constraint itpux06_age_con; --validate
alter table itpux06 disable validate constraint itpux06_age_con; --validate
insert into itpux06 values(3,'name3',18); --error
alter table itpux06 enable constraint itpux06_age_con; --validate
insert into itpux06 values(3,'name3',18);
alter table itpux06 disable constraint itpux06_age_con; --novalidate
insert into itpux06 values(4,'name4',16);
alter table itpux06 enable constraint itpux06_age_con; --error
alter table itpux06 enable novalidate constraint itpux06_age_con;
--2.2 主键的
create table itpux07(id number,name varchar2(20));
alter table itpux07 add constraint itpux07_id_con primary key(id);
insert into itpux07 values(1,'name1');
alter table itpux07 disable constraint itpux07_id_con; --novalidate
insert into itpux07 values(1,'name2');
select * from itpux07;
alter table itpux07 enable constraint itpux07_id_con; --error
alter table itpux07 enable novalidate constraint itpux07_id_con; --error
因为创建主键的时候，系统同时创建了一个唯一索引，novalidate只是使用主键约束，对已经存在的数据进行校验，但是并不对创建唯一索引进行控制，所以会失败
我们可以在创建主键前，先给字段建立普通的索引，这样建主键的时候，系统会自动利用这个普通索引，
create index idx_itpux07_id on itpux07(id);
alter table itpux07 enable novalidate constraint itpux07_id_con; --ok
select * from itpux07;
~~~

## 显示约束的信息

~~~sql
--1.约束的数据字典
select * from all_constraints;
select * from dba_constraints;
select * from user_constraints;
select distinct constraint_type from user_constraints ;
-- R references : column
-- U unique : column
-- P primary key : column
-- C check : column
-- O read only on a view : object
-- V Check on a view : object
select * from all_cons_columns;
select * from dba_cons_columns;
select * from user_cons_columns;
select * from dba_constraints where table_name='ITPUX08';



--2.约束的可延迟属性。
select * from dba_constraints where table_name='ITPUX07';
--DEFERRABLE(延迟条件): NOT DEFERRABLE(默认，立即验证), DEFERRABLE（提交时验证）
--DEFERRED ： IMMEDIATE(默认，立即验证)，DEFERRED（提交时才验证）,
--set constraint 名字immediate;
--用途：物化视图，级联更新。
create table itpux10(
id number not null primary key DEFERRABLE initially IMMEDIATE,
name varchar2(20),
age number constraint itpux10_age_con check(age>17) DEFERRABLE
initially DEFERRED);
select * from dba_constraints where table_name='ITPUX10';

~~~



# 序列

序列是一个计数器,它并不会与特定的表关联。通过创建Oracle序列和触发器实现表的主键自增。序列的用途一般用来填充主键和计数。

序列:是oracle提供的用于产生一系列唯一数字的数据库对象。

自动提供唯一的数值

共享对象

主要用于提供主键值

将序列值装入内存可以提高访问效率

**创建序列：**

1、要有创建序列的权限create sequence 或create any sequence

2、创建序列的语法

~~~sql
CREATE SEQUENCE sequence //创建序列名称
[INCREMENT BY n] //递增的序列值是n 如果n 是正数就递增,如果是负数就递减，默认是1
[START WITH n] //开始的值,递增默认是minvalue 递减是maxvalue
[{MAXVALUE n | NOMAXVALUE}] //最大值
[{MINVALUE n | NOMINVALUE}] //最小值
[{CYCLE | NOCYCLE}] //循环/不循环
[{CACHE n | NOCACHE}];//分配并存入到内存中

NEXTVAL 返回序列中下一个有效的值，任何用户都可以引用
CURRVAL 中存放序列的当前值
NEXTVAL 应在CURRVAL 之前指定，二者应同时有效
~~~



序列在下列情况下出现裂缝：

- 回滚
- 系统异常

**修改序列**

~~~sql
//修改序列的增量，最大值，最小值，循环选项，或是否装入内存
alter SEQUENCE sequence //创建序列名称
[INCREMENT BY n] //递增的序列值是n 如果n 是正数就递增,如果是负数就递减，默认是1
[START WITH n] //开始的值,递增默认是minvalue 递减是maxvalue
[{MAXVALUE n | NOMAXVALUE}] //最大值
[{MINVALUE n | NOMINVALUE}] //最小值
[{CYCLE | NOCYCLE}] //循环/不循环
[{CACHE n | NOCACHE}];//分配并存入到内存中
~~~

**修改序列的注意事项：**

​    必须是序列的拥有者或对序列有alter权限

​    只有未来的序列值会被改变

​    改变序列的初始值只能通过删除序列之后重建序列的方法实现

~~~sql
--创建普通序列
create sequence seql start with 10 nocache maxvalue 15 cycle;
create sequence seql1     --创建不带任何参数的序列

--创建一个带主键的表
drop table seqtest
create table seqtest(
c1 number,
c2 varchar2(10)
);
alter table seqtest add constraint seqtest_pk primary key (c1);
create sequence seq_test_pk_s
minvalue 1
maxvalue 9999999999999999
start with 1
increment by 1
cache 20;
--间断
A:
insert into seqtest values (seq_test_pk_s.nextval,'11');
commit;
B:
insert into seqtest values (seq_test_pk_s.nextval,'22');      --不提交
A:
insert into seqtest values (seq_test_pk_s.nextval,'33');     
commit;
select * from seqtest;
B:
select * from seqtest;
rollback;
select * from seqtest;
如上可以看到B会话的2序列因为回滚了所以出现了裂缝，即便此时任何一个会话再次使用序列，2序列也不会被使用：
--删除
drop table seqtest
drop sequence SEQ_TEST_PK_S
~~~








# 视图

## 普通视图

**一what (什么是视图? )**

1视图是一种数据库对象,是从一个或者多个数据表或视图中导出的虚表,视图所对应的数据并不真正地存储在视图中,而是存储在所引用的数据表中,视图的结构和数据是对数据表进行查询的结果。

2根据创建视图时给定的条件,视图可以是一个数据表的一部分,也可以是多个基表的联合,它存储了要执行检索的查询语句的定义,以便在引用该视图时使用。



**二why (为什么要用视图?视图的优点)**

1.简化数据操作:视图可以简化用户处理数据的方式

2着重于特定数据:不必要的数据或敏感数据可以不出现在视图中。

3视图提供了一个简单而有效的安全机制,可以定制不同用户对数据的访问权限。

4提供向后兼容性:视图使用户能够在表的架构更改时为表创建向后兼容接口。

5·自定义数据:视图允许用户以不同方式查看数据。

**视图分为简单视图和复杂视图.**

简单视图只从单表里获取数据;复杂视图从多表里获取数据。

简单视图不包含函数和数据组;复杂视图包含函数和数据组。

简单视图可以实现DML操作;复杂视图不可以。

**视图的优点:**

1)安全性:通过视图用户只能查询和修改他们所能见到的数据

2)逻辑数据独立性:视图可帮助用户屏蔽真实表结构变化带来的影响。视图可以使应用程序和数据库表在一定程度上独立。

3)简单性:视图不仅可以简化用户对数据的理解,也可以简化他们的操作

4)可以合并分离的数据,创建分区视图

**视图的限制性：**

1) 性能的降低

2) 修改的限制

**视图的创建语法**

~~~shell
CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view_name
[(alias[, alias]...)]
AS subquery
[WITH CHECK OPTION [CONSTRAINT constraint]]
[WITH READ ONLY]
OR REPLACE ：若所创建的试图已经存在，ORACLE 自动重建该视图；
FORCE ：不管基表是否存在ORACLE 都会自动创建该视图；
NOFORCE ：只有基表都存在ORACLE 才会创建该视图：
alias ：为视图产生的列定义的别名；
subquery ：一条完整的SELECT 语句，可以在该语句中定义别名；
WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束；
WITH READ ONLY ：该视图上不能进行任何DML 操作。
-- O read only on a view : object
-- V Check OPTION on a view : object
~~~

**视图的定义原则:**

1,在没有WITH CHECK OPTION和READ ONLY的情况下,查询中不能使用ORDER BY子句;

2,如果没有为CHECK OPTION约束命名,系统会自动为之命为SYS Cn

~~~sql
--视图
--1 创建视图
create view yg_v as select hire_date,job_id,salary,department_id from yg;
create view bm_v as select department_id,department_name,location_id from bm;
create view bm_sum_v as
select y.department_id,
        b.department_name,
       count(1) bmyg_count,
       sum(y.salary) as salary
  from yg_v y
  join bm_v b
    on y.department_id = b.department_id
 group by y.department_id, b.department_name;

--2 查询视图
select * from yg_v;
select * from bm_v;
select * from bm_sum_v;

--3 插入/更新视图
insert into bm_sum_v values(....);

--4 删除视图
drop view bm_sum_v;
~~~





## 物化视图

**物化视图( MATERIALIZED VIEW )** ,也称实体化视图,快照(8i以前的说法) ,它是含有数据的,占用有储空间。

~~~shell
CREATE MATERIALIZED VIEW;
~~~

# 同义词

同义词是指数据库对象(表、视图、序列、存储过程等数据库对象)用另一个名字来引用。比如:

建立一个同义词可以排除一个对象名字的限制

如果你的数据库有多个用户, USER A要访问USER B的TABLE1,只能使用USER B.TABLE1

建一个同义词abc指向USER B.TABLE1,那你就可以select * from abc了,而且public的同义词会直接出现在所有用户的面前,开发就方便多了

Oracle同义词有两种类型,分别是**Oracle公用同义词**与**Oracle私有同义词**。普通用户创建的同义词一般都是私有同义词,公有同义词一般由DBA创建,普通用户如果希望创建同义词,则需要CREATE PUBLIC SYNONYM这个系统权限

**1)Oracle公用同义词:**

由一个特殊的用户组Public所拥有。顾名思义,数据库中所有的用户都可以使用公用同义词。公用同义词往往用来标示一些比较普通的数据库对象,这些对象往往大家都需要引用。

**2)Oracle私有同义词:**

它是跟公用同义词所对应,他是由创建他的用户所有。当然,这个同义词的创建者,可以通过授权控制其他用户是否有权使用属于自己的私有同义词。

**普通用法如下所示:**

~~~shell
CREATE [OR REPLACE] [PUBLIC] SYNONYM [ schema.]同义词名称FOR [schema.] object [@dblink ];
语法说明:
OR REPLACE:在不使用DROP的前提下容许你重新创建(如果同义词已经存在)。
PUBLIC:所创建的同义词是全局的同义词,所有数据库用户都可以使用。
schema:要创建同义词的对象所在的schema,如果省略,则默认的应用对象在当前schema下。object name:要创建同义词的对象,它可以是以下几种类型:
TABLE
VIEW
SEQUENCE
STORED PROCEDURE
FUNCTION
PACKAGE
MATERIALIZED VIEW
JAVA CLASS SCHEMA OBJECT
USER-DEFINED OBJECT
SYNONYM
~~~

**专有(私有)同义词**

~~~shell
CREATE SYNONYM SYSN TEST FOR TEST
~~~

**公共同义词**

~~~shell
CREATE PUBLIC SYNONYM PUBLIC TEST FOR TEST;
~~~

如果要创建一个远程的数据库上的某张表的同义词,需要先创建一个Database Link(数据库连接)来扩展访问,然后再使用如下语句创建数据库同义词: create synonym table-name for table-name@DBLink

公共同义词是和用户的schema无关的,但是公共的意思并不是所有的用户都可以访问它,必须被授权后才能进行;私有同义词是schema的对象

**同义词权限管理**

与同义词相关的权限有CREATE SYNONYM, CREATE ANY SYNONYM, CREATE PUBLIC SYNONYM权限。

~~~shell
--1.创建同义词
create synonym yg_s for yg_v;
create synonym bm_s for bm_v;
create synonym bm_sum_s for bm_sum_v;
select * from yg_s;
select * from bm_s;
drop view yg_v;
drop view bm_v;
alter view bm_sum_v compile;
drop view bm_sum_v;
alter synonym yg_s compile;
--2.删除同义词
drop synonym yg_s;
drop synonym bm_s;
drop synonym bm_sum_s;
--3.查看同义词
select * from dba_synonyms where owner='ITPUX';
select * from all_synonyms
select * from user_synonyms
select * from scott.emp;
create synonym emp_s for scott.emp;
select * from emp_s;
create table emp as select * from scott.emp;
select * from emp;
--4.权限
grant create synonym to itpux01;
grant create any synonym to itpux01;
grant create public synonym to itpux01;
~~~





# 触发器

触发器是很多关系数据库中都提供一种技术,可以在用户进行某种操作的时候,自动的进行另外一个操作,这种技术称为触发器技术。当发生特定事件时(如修改表、建立对象、登录到数据库) , oracle就会自动的去执行相应的代码。

## 触发器的使用

触发器是一种特殊的存储过程,触发器一般由事件触发并且不能接受参数,存储器由语句块去调用

触发器分类:

1. DML触发器:创建在表上,由DML事件引发
2. instead of触发器:创建在视图上并且只能在行级上触发,用于替代insert, delete等操作(由于oracle中不能直接对有两个以上的表建立的视图进行DML操作,所以给出替代触发器,它是专门为进行视图操作的一种处理方法)
3. DDL触发器:触发事件时数据库对象的创建和修改
4. 数据库系统事件触发器:定义在数据库或者模式上,由数据库事件触发组成
   - 触发事件:
     - 引发触发器被触发的事件DML语句(INSERT, UPDATE, DELETE语句对表或视图执行数据处理操作)、
     - DDL语句(如CREATE, ALTER, DROP语句在数据库中创建、修改、删除模式对象)、
     - 数据库系统事件(如系统启动或退出、异常错误)、用户事件(如登录或退出数据库)。
   - 触发时间:即该触发器是在触发事件发生之前(BEFORE )还是之后(AFTER)触发
   - 触发操作:触发器触发后要完成的事情
   - 触发对象:包括表、视图、模式、数据库,只有在这些对象上发生了符合触发条件的触发事件,触发器才会执行触发操作。
   - 触发条件:由WHEN子句指定一个逻辑表达式,只有当该表达式的值为TRUE时,遇到触发事件才会自动执行触发操作
   - 触发频率:说明触发器内定义的动作被执行的次数。即语句级(STATEMENT)触发器和行级(ROW触发器。(比如delete多条数据时,行级触发器可能会执行多次,语句级触发器只会触发一次)

## 触发器的语法

**说明**

不同类型的触发器例如DML触发器，Instead of 触发器，系统触发器语法格式区别较大

~~~sql
CREATE [OR REPLACE] TIGGER 触发器名触发时间触发事件
ON 表名/视图名
[FOR EACH ROW] //加上FOR EACH ROW 即为行级触发器，不加时为语句级触发器
BEGIN
pl/sql 语句
END
~~~

**注意事项**

- 在触发器的执行部分只能用DML语句(SELECT, INSERT, UPDATE, DELETE ) ,不能使用DDL语句(CREATE, ALTER, DROP)
- 触发器中不能使用commit语句,触发器的操作与触发事件(INSERT,UPDATE,DELETE )一起进行COMMIT和ROLLBACK;
- 一个表上的触发器越多,对于表的DML操作性能影响越大
- 触发器最大为32K

## DML 触发器及案例

dml 触发器语法：

~~~sql
create [or replace] trigger 触发器名称
{before|after}
{insert|delete|update[of column [,column...]]}
or {insert|delete|update[of column [,column...]]}
on [schema.] 表名|[schema.]视图
[for each row]
[when condition]
begin
执行语句;
end;
~~~

**详细说明：**

~~~sql
or replace带上则为覆盖
before在触发事件之前执行
after在触发事件之后执行
insert/delete/update在插入、删除、更新操作时触发
or可以多个操作同时定义触发器
on对哪一个表或视图进行监控
for each row带上是对每一条数据都记录
when condition条件表达式
~~~

**使用条件谓词**

当触发器中同时包含多个触发事件(insert,update,delete)时,为了在触发器代码中区分具体的触发事件,可以使用三个条件:

~~~sql
inserting
updating
deleting
~~~

案例

~~~sql
--DML 触发器
--准备
create table emp as select * from scott.emp;
select * from emp;
--1.设置一个添加记录就提示的触发器
create or replace trigger t1
after insert on itpux.emp
begin
dbms_output.put_line('你向ITPUX.EMP 表中添加了一条数据');
end;
/
--验证
--set serverout on
insert into emp values('8000','itpux15','DBA','8001',sysdate,'15000','0','30');
insert into emp values('8002','itpux16','DBA','8002',sysdate,'15000','0','30');
--2.设置一个更改记录就提示的触发器
create or replace trigger t_update
after update on itpux.emp
for each row --提示每一条修改的记录
begin
dbms_output.put_line('你修改了ITPUX.EMP 表中多条数据');
end;
/
--验证
--set serverout on
select * from emp;
update emp set job='DBA+SA+HR' where ENAME in ('itpux15','itpux16');
--你修改了ITPUX.EMP 表中多条数据
--3.设置一个删除记录就提示的触发器
create or replace trigger t_delete
before delete on itpux.emp
begin
--select to_char(sysdate,'day') from dual;
if to_char(sysdate,'day') in ('星期六','星期天') then
dbms_output.put_line('禁止在周末删除ITPUX.EMP 表数据');
raise_application_error(-20001,'禁止在周末删除ITPUX.EMP 表数据'); --
-20000~20999
end if;
end;
/
--验证
--set serverout on
delete from emp;
~~~

## DDL触发器及案例

创建ddl 触发器基本语法：

~~~sql
create or replace trigger ddl 触发器名称
after ddl on 方案名.schema
begin
执行语句;
end;
~~~

DDL 触发器需要system用户数据库管理员去权限才可以建立

在Oracle dml语句需要手动commit（提交），如果没有手动提交，在正常退出客户端时，Oracle会自动提交；ddl语句是自动commit（提交）

~~~sql
--使用SYSTEM 用户
drop table itpux_ddl01
create table itpux_ddl01
(
dbname varchar2(100),
event varchar2(100),
username varchar2(30),
client_ip varchar2(100),
ddl_time date
);
create or replace trigger t_itpux_ddl01
after ddl on itpux.schema
begin
insert into itpux_ddl01
values(ora_database_name,ora_sysevent,ora_login_user,ora_client_ip_address,sysdate);
-- ora_database_name这些是系统时间，作为变量可以直接使用
end;
--切换至ITPUX 用户
create table itpux012(id number);
select * from system.itpux_ddl01;
~~~

## 数据库系统触发器及案例

系统触发器

系统事件是指基于Oracle事件（例如logon/logout和startup/shutdown）所建立的触发器。通过使用系统事件触发器，提供了跟踪系统或者数据库变化的机制

系统触发器创建基本语法：

~~~sql
create or replace trigger 系统触发器名称
after[before] logon[logoff] on datebase
begin
执行语句;
end;
~~~

详细说明

~~~sql
after 事件之后触发
before 事件之前触发
logon 登陆触发
logoff 登出触发
startup 开启系统触发
shutdown 关闭系统触发
~~~

下面介绍一些常用的系统事件属性函数，和建立各种事件触发器的方法在建立系统事件触发器时，需要使用事件属性函数，

常用的事件属性函数如下：

~~~sql
ora_client_ip_address //返回客户端的ip
ora_database_name //返回数据库名称
ora_login_user //返回登陆用户名
ora_sysevent //返回触发器的系统事件名
ora_des_encrypted_password //返回用户des(md5)加密后的密码
~~~

**事件属性函数表**

~~~sql
Ora_client_ip_address 返回客户端的ip 地址
Ora_database_name 返回当前数据库名
Ora_des_encrypted_password 返回des 加密后的用户口令
Ora_dict_obj_name 返回ddl 操作所对应的数据库对象名
Ora_dict_obj_name_list(name_list out ora_name_list_t)返回在事件中被修改的对象名列表
Ora_dict_obj_owner 返回ddl 操作所对应的对象的所有者名
Ora_dict_obj_owner_list(owner_list out ora_name_list_t)返回在事件中被修改的对象的所有者列表
Ora_dict_obj_type 返回ddl 操作所对应的数据库对象的类型
Ora_grantee(user_list out ora_name_list_t)返回授权事件的授权者
Ora_instance_num 返回例程号
Ora_is_alter_column(column_name in varchar2)检测特定列是否被修改
Ora_is_creating_nested_table 检测是否正在建立嵌套表
Ora_is_drop_column(column_name in varchar2)检测特定列是否被删除
Ora_is_servererror(error_number)检测是否返回了特定oracle 错误
Ora_login_user 返回登录用户名
Ora_sysevent 返回触发器的系统事件名
~~~

**系统触发器的种类和事件出现的时机（前或后）：**

~~~sql
事件	允许的时机	说明
STARTUP AFTER 启动数据库实例之后触发
SHUTDOWN BEFORE 关闭数据库实例之前触发（非正常关闭不触发）
SERVERERROR AFTER 数据库服务器发生错误之后触发
LOGON AFTER 成功登录连接到数据库后触发
LOGOFF BEFORE 开始断开数据库连接之前触发
CREATE BEFORE，AFTER 在执行CREATE 语句创建数据库对象之前、之后触发
DROP BEFORE，AFTER 在执行DROP 语句删除数据库对象之前、之后触发
ALTER BEFORE，AFTER 在执行ALTER 语句更新数据库对象之前、之后触发
DDL BEFORE，AFTER 在执行大多数DDL 语句之前、之后触发
GRANT BEFORE，AFTER 执行GRANT 语句授予权限之前、之后触发
REVOKE BEFORE，AFTER 执行REVOKE 语句收权限之前、之后触犯发
RENAME BEFORE，AFTER 执行RENAME 语句更改数据库对象名称之前、之后触犯发
AUDIT/NOAUDIT BEFORE，AFTER 执行AUDIT 或NOAUDIT 进行审计或停止审计之前、之后触发
~~~

<font color='red'>特别说明：系统触发器的级别较高，由系统管理员来创建。</font>

~~~sql
--记录登录数据库的用户名和IP
--使用sys用户登陆
create table login_info (ip varchar(30),username varchar(30));
create or replace trigger logon_ip_info
after logon on database
declare
ip varchar(30);
user varchar(30);
begin
select sys_context('USERENV','SESSION_USER') into user from dual;
select sys_context('USERENV','ip_address') into ip from dual;
insert into login_info values(ip,user);
end;
/
select * from login_info;
~~~

管理触发器

~~~sql
--禁用
alter trigger logon_ip_info disable;
--启用
alter trigger logon_ip_info enable;
--编译
alter trigger logon_ip_info compile;
--删除
drop trigger logon_ip_info;
--查询
select * from dba_objects where owner='ITPUX' and object_type='TRIGGER';
drop trigger ITPUX.T_UPDATE;
drop trigger ITPUX.T_DELETE;
drop trigger system.t_itpux_ddl01;
~~~





# 存储过程

## 存储过程说明

**说明:**

1存储过程是用于特定操作的pl/sql语句块

2存储过程是预编译过的,经优化后存储在sql内存中,使用时无需再次编译,提高了使用效率;

3存储过程的代码直接存放在数据库中,一般直接通过存储过程的名称调用,减少了网络流量,加快了系统执行效率;

**存储过程与函数的区别:**

1一股来说,存储过程实现的功能要复杂一点,而函数的实现的功能针对性比较强,

2对于存储过程来说可以返回参数(output) ,而函数只能返回值或者表对象。

3存储过程一般是作为一个独立的部分来执行,而函数可以作为查询语句的一个部分来调用,由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面

**存储过程的优点**

1执行速度更快-在数据库中保存的存储过程语句都是编译过的

2.允许模块化程序设计,程序的可移植性更强-类似方法的复用(使用存储过程可以实现存储过程设计和编码工作的分开进行，只要将存储过程名、参数、返回信息等告诉编程人员即可

3提高系统安全性-防止SQL注入(执行存储过程的用户要具有一定的权限才能使用存储过程)

4减少网络流通量-只要传输存储过程的名称(在大批数据查询时使用存储过程分页查询比其他方式的分页要快很多)

5在同时进行逐主、从表间的数据维护及有效性验证时,使用存储过程更加方便,可以有效的利用SQL中的事务处理机制

## 语法

~~~sql
CREATE [OR REPLACE] PROCEDURE procedure_name
[(parameter1[model] datatype1, parameter2 [model] datatype2..)]
IS[AS]
BEGIN
PL/SQL;
END [procedure_name];
~~~

1. parameter用于指定参数, model用于指定参数模式, datatype用于指定参数类型
2. 定义存储过程的参数时,只能指定数据类型,不能指定数据长度
3. IS/AS用于开始PL/SQL代码块
4. 创建存储过程时,既可以指定参数也可以不指定任可参数;
5. 存储过程参数:
   1. 输入参数IN IN用于接收调用环境的输入参数(创建存储过程时,输入参数的IN可以省略)
   2. 输出参数OUT OUT用于将输出数据传递到调用环境
   3. 输入输出参数(IN OUT )其中IN用于接收调用环境的输入参数, OUT用于将输出数据传递到调用环境

## 简单案例

~~~sql
--1.编写存储过程
--显示当前系统时间
create or replace procedure print_sysdate
is
begin
dbms_output.put_line(sysdate);
end print_sysdate;
/


--2.存储过程的调用
--sqlplus,pl/sql 代码块
exec print_sysdate;
--set serverout on;
--exec print_sysdate（）;


--3.存储过程的删除
drop procedure test1;



--4.编译存储过程
alter procedure print_sysdate compile;

--5.查询存储过程
select * from dba_objects where object_type='PROCEDURE' and owner='ITPUX';
select * from all_objects where object_type='PROCEDURE' and owner='ITPUX';
select * from user_objects where object_type='PROCEDURE';


--6.查看存储过程的内容
select * from user_source where name='PRINT_SYSDATE';
select * from dba_source where owner='ITPUX' and name='PRINT_SYSDATE';
select * from all_source;
select text from user_source where name='PRINT_SYSDATE';
select * from dba_source where type='PROCEDURE' and text like '%sysdate%';
~~~

## 存储过程中事务处理

**事务说明**

1. 事务用于确保数据的一致性,由一组相关的DML语句组成,DML语句所执行的操作要么全部确认,要么全部取消。
2. 当执行事务操作DML时, oracle会在被作业的表上加锁,以防止其他用户改变表结构,同时也会在被作业的行上加锁,以防止其他事务在该行上执行DML操作
3. 当执行事务提交或者事务回滚时, oracle会确认事务变化或者回滚事务、结束事务、事务保存点、释放锁。
4. 提交事务(commit)确认事务变化,结束当前事务、删除保存点,释放锁,使得当前事务中所有未决的数据永久改变
5. 保存点( savepoint )在当前事务中,标记事务的保存点
6. 回滚操作(rollback )回滚整个事务,删除该事务中所有保存点,释放锁,丢弃所有未决的数据改变
7. ROLLBACK TO SAVEPOINT回滚到指定的保存点

**存储过程中事务说明**

- 尽可能的让事务持续的越短越好
- 在事务中尽可能的存取最少的数据量

~~~sql
--案例1 显示YG 表中员工人数的存储过程。
create or replace procedure yg_count
as
v_total number(10);
begin
select count(*) into v_total from yg;
dbms_output.put_line('员工总人数为：'||v_total);
end;
set serverout on;
execute yg_count;


--案例2 存储过程中的增删改DML 事务操作。
--准备
create table itpux_st(id int,name varchar2(10));
insert into itpux_st values(1,'itpux01');
insert into itpux_st values(2,'itpux02');
commit;

-2.1 增加
create or replace procedure pro_insert
(v_id int,v_name varchar2)
is
begin
insert into itpux_st values(v_id,v_name);
commit;
end;
--执行
begin
pro_insert(3,'itpux03');
end;
--检查
select * from itpux_st;



--2.2 删除
--创建过程
create or replace procedure pro_delete
(v_id int)
is
begin
delete from itpux_st where id=v_id;
commit;
end;
--执行
begin
pro_delete(3);
end;
--检查
select * from itpux_st;


--2.3 更新/更改
--创建过程
create or replace procedure pro_update
(v_id int,v_name varchar2)
is
begin
update itpux_st set name=v_name where id=v_id;
commit;
end;
--执行
begin
pro_update(2,'itpux02222');
end;
--检查
select * from itpux_st;


--2.4 查询
--创建过程
create or replace procedure pro_select
(v_id int) --定义输入变量，输入变量用括号括起来
is
v_name varchar2(10);--定义输出变量，输出变量不需要括起来
begin
select name into v_name from itpux_st where id=v_id;--执行查询
dbms_output.put_line('学生姓名为：'||v_name);--输出结果
end;
--执行
--set serverout on;
begin
pro_select(2);
end;

~~~








# 函数


# 匿名块

# 包

## 定义

**包**

1. 被组合在一起的相关对象的集合,当包中任何函数或存储过程被调用,包就被加载入内存。
2. 包中的任何函数或存储过程的子程序访问速度将大大加快。
3. 包由两个部分组成:包头和包体,在包头中描述变量、常量、游标、和子程序。
4. 包体由完整的子程序,游标定义组成

**包结构**

一个包由两个分开的部分组成:包规范和包体

**包定义( PACKAGE )**

包定义部分是为应用程序的接口,声明包内数据类型、变量、常量、游标、子程序和异常错误处理等元素,这些元素为包的公有元素。

~~~sql
CREATE [OR REPLACE] PACKAGE package_name
{IS | AS}
[公有数据类型定义]
[公有游标声明]
[公有变量、常量声明]
[公有子程序声明]
[package_name];
~~~

**定义包规范:**

~~~sql
CREATE OR REPLACE 
package p.stu
as
--定义结构体
type re_stu is record(
rname student.name%type,
rage student.age%type
);
--定义游标
type c stu is ref cursor;
--定义函数
function numAdd(num1 number,num2 number)return number;
--定义过程
procedure GetStuList(cid in varchar2,c st out c_stu);
end;
~~~

**包主体( PACKAGE BODY )**

包主体( PACKAGE BODY ) :包主体则是包定义部分的具体实现,它定义了包定义部分所声明的游标和子程序,在包主体中还可以声明包的私有元素。如果在包主体中的游标或子程序并没有在包头中定义,那么这个游标或子程序是私有的。

~~~sql
CREATE [OR REPLACE] PACKAGE BODY package_name
(IS | AS)
[私有数据类型定义]
[私有变量、常量声明]
[私有子程序声明和定义]
[公有子程序定义]
BEGIN
执行部分(初始化部分)
END [package_name];
~~~

与类相同,包中的程序元素也分为公用元素和私用元素两种,这两种元素的区别是他们允许访问的程序范围不同,即它们的作用域不同,公用元素不仅可以被包中的函数、过程所调用,也可以被包面的PL/SQL程序访问,而私有元素只能被包内的函数和过程所访问

包定义和包主体分开编译，并作为两部分分开的对象存放在数据字典中，（包定义一定要在包主体前面编译，包主体可以没有，但包定义一定要有）包的名称和包体的名称要保持一致。

~~~sql
CREATE OR REPLACE
package p_stu
as
--定义结构体
type re_stu is record(
rname student.name%type,
rage student.age%type
);
--定义游标
type c_stu is ref cursor;
--定义函数
function numAdd(num1 number,num2 number)return number;
--定义过程
procedure GetStuList(cid in varchar2,c_st out c_stu);
end;
~~~

## 创建包

~~~sql
--2.包的使用
create table emp as select * from scott.emp;
select * from emp;
-- 创建包
--2.1 包头
create or replace package itpux_pkg
is
procedure update_sal(e_name varchar2,newsal number);
FUNCTION emp_sal_fun(e_name varchar2) return number;
end;
--2.2 包体
create or replace package body itpux_pkg is
procedure update_sal(e_name varchar2,newsal number)
is
begin
update emp set sal=newsal where ename=e_name;
end;
function emp_sal_fun(e_name varchar2)
return number is
emp_sal number;
begin
select sal*12+nvl(comm,0) into emp_sal from emp
where ename=e_name;
return emp_sal;
end;
end;
--2.3 执行包-调过程
set serveroutput on
exec itpux_pkg.update_sal('itpux14',2000);
commit;
select * from emp;
--查看itpux14 的记录
--2.4 执行包-调函数
declare
v_emp_sal number(7,2);
begin
v_emp_sal:=itpux_pkg.emp_sal_fun('itpux14');
dbms_output.put_line('ITPUX14 的年薪为: '||v_emp_sal);
end;
--ITPUX14 的年薪为: 24000
--2.5 删除包
select * from dba_objects where owner='ITPUX' and object_type='PACKAGE';
drop package ITPUX_PKG;
drop package ITPUXA_PKG;
~~~








# 目录

# 数据库链接(dblink)

## 环境说明

| IP地址        | 端口号 | service_names | 备注       |
| ------------- | ------ | ------------- | ---------- |
| 192.168.1.100 | 1521   | orcl11g       | 本地数据库 |
| 192.168.1.200 | 1521   | orcl19c       | 远程数据库 |

本地tnsnames.ora配置

~~~shell
#本地数据库
orcl_local =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.100)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl11g)
    )
  )

#远程数据库
orcl_remote =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.200)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl19c)
    )
  )
~~~

## dblink的数据字典和权限 

~~~sql
--查看dblink 
select owner,object_name from dba_objects where object_type='DATABASE LINK'; 
OR： 
select * from dba_db_links; 
--创建dblink需要的权限 
create public database link 
create database link 
--授权 
grant create public database link,create database link to myAccount; 
~~~

> 关于权限官方文档的说明： 
> To create a private database link, you must have the CREATE DATABASE LINK system privilege. To create a public database link, you must have the CREATE PUBLIC DATABASE LINK system privilege. Also, you must have the CREATE SESSION system privilege on the remote Oracle Database.

## dblink创建 

Specify PUBLIC to create a public database link visible to all users. If you omit this clause, then the database link is private and is available only to you. 

### 公有dblink 

数据库级的dblink，所有的用户都能够使用的 

~~~sql
--远程数据库上创建测试用户 
sqlplus sys/oracle@orcl_remote as sysdba 
create user test_u1 identified by test_u1; 
grant dba to test_u1; 
--dblink是创建在本地的 
sqlplus / as sysdba
--创建dblink方法1 
create public database link pub_orcl19 connect to test_u1 identified by test_u1 
using '(DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.200)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl19c)))';
      
--创建dblink方法2 
create public database link pub_orcl192 connect to test_u1 identified by test_u1 using 'orcl_remote'; 
--注意方式2中using子句后面是本地配置的本地连接远程数据库的tnsname     
~~~

### 私有dblink 

~~~sql
--dblink是创建在本地的 
sqlplus / as sysdba
--创建dblink方法1 
create database link pri_orcl19 connect to test_u1 identified by test_u1 
using '(DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.200)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl19c)))';
      
--创建dblink方法2 
create database link pri_orcl192 connect to test_u 1 identified by test_u 1 using 'orcl_remote'; 
--注意方式2中using子句后面是本地配置的本地连接远程数据库的tnsname   
~~~

## dblink的使用 

> After you have created a database link, you can use it in SQL statements to refer to tables, views, and PL/SQL objects in the other database by appending @dblink to the table, view, or PL/SQL object name. You can query a table or view in the other database with the SELECT statement. You can also access remote tables and views using any INSERT , UPDATE , DELETE , or LOCK TABLE statement.

~~~sql
--远程数据库对应schema下创建测试数据 
sqlplus test_u1/test_u1@orcl_remote 

create table testtable as 
select 
  rownum as id, 
  to_char(
    sysdate + rownum / 24 / 3600, 'yyyy-mm-dd hh24:mi:ss'
  ) as inc_datetime, 
  trunc(
    dbms_random.value(0, 100)
  ) as random_id, 
  dbms_random.string('x', 5) random_string 
from 
  dual connect by level <= 10;
--本地数据库sys用户使用dblink 
sqlplus / as sysdba 
select * from test_u1.testtable@pub_orcl19; --数据能查询到 
--hr用户测试 
conn hr/hr 
select * from test_u1.testtable@pub_orcl19; --数据能查询到 
--如上因为PUB_LIZHUODB为公有的dblink全局都能访问，所以sys用户创建后hr用户也可以使用 

sqlplus / as sysdba 
select * from test_u1.testtable@pri_orcl19; --数据能查询到 
conn hr/hr 
select * from test_u1.testtable@pri_orcl19;
ERROR at line 1: 
ORA-02019: connection description for remote database not found 
--如上私有dblink是sys用户创建的，hr用户不能使用
~~~



其他使用

~~~sql
其他用法（以public dblink为例）： 
--insert 
insert into test_u1.testtable@pub_orcl19 values(11,sysdate,11,'11'); 
--update 
update test_u1.testtable@pub_orcl19 set id =12 where id=11;
--delete 
delete from test_u1.testtable@pub_orcl19 where id=12; 
--为dblink创建同义词 
CREATE OR REPLACE SYNONYM test_t FOR test_u1.testtable@pub_orcl19; 
select * from test_t; --以后查询这个同义词就可以访问远程数据库的表 
--存储过程中使用dblink 
set serveroutput on;
create or replace procedure test_pro as cnt int; 
begin 
select count(*) into cnt 
from 
  test_u1.testtable@pub_orcl19;
  dbms_output.put_line('远程数据库表' || 'testtable的记录数为：' || cnt ); 
 end;
 /
--调用存过 
begin
test_pro;
end; 
/ 
--函数中使用dblink 
create or replace function test_fun return varchar2 is cnt int; 
str varchar2(100); 
begin 
select count(*) into cnt 
from test_u1.testtable@pub_orcl19; 
str := '远程数据库表testtable的记录数为：' || cnt; 
return str;
end;
/
--调用函数
declare result varchar2(100);
begin 
result := test_fun;
dbms_output.put_line(result);
end;
/
~~~



## dblink删除

~~~sql
drop public database link pub_orcl19; 
drop public database link pub_orcl192; 
drop database link pri_orcl19; 
drop database link pri_orcl192;
~~~



# 对象创建

## 临时表

事务级临时表

~~~shell
#on commit delete rows   transaction级别，临时表的作用范围在一个事务之内
create global temporary table temp_transaction
       on commit delete rows
       as select * from test;
~~~

会话级临时表

~~~shell
#on commit preserve rows   session级别，只要用户不退出临时表一直有效，一旦用户退出了，数据就没有了
create global temporary table temp_tsession
       on commit preserve rows
       as select * from test;
~~~

**总结：**

- 事务级别的临时表，事务提交之后，相当于事务结束了，没有事务了，数据就没有了
- 会话级别的临时表，只要会话没有断开，数据永远在里面，会话断开之后，重新连接数据就没有了

## 视图

语法结构

~~~
CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view_name
    [(alias[, alias]...)]
AS subquery
     [WITH CHECK OPTION [CONSTRAINT constraint]]
     [WITH READ ONLY]
~~~

语法解析：

- OR REPLACE ：若所创建的试图已经存在，则替换旧视图；
- FORCE：不管基表是否存在ORACLE都会自动创建该视图(即使基表不存在，也可以创建该视图，但是该视图不能正常使用，当基表创建成功后，视图才能正常使用)；
- NOFORCE  ：如果基表不存在，无法创建视图，该项是默认选项(只有基表都存在ORACLE才会创建该视图)。
- alias：为视图产生的列定义的别名；
- subquery ：一条完整的SELECT语句，可以在该语句中定义别名；
- WITH CHECK OPTION ：插入或修改的数据行必须满足视图定义的约束；
- WITH READ ONLY：默认可以通过视图对基表执行增删改操作，但是有很多在基表上的限制(比如：基表中某列不能为空，但是该列没有出现在视图中，则不能通过视图执行insert操作)，WITH READ ONLY说明视图是只读视图，不能通过该视图进行增删改操作。现实开发中，基本上不通过视图对表中的数据进行增删改操作。



## 索引

### 创建普通索引

~~~
create index yaokang.zzq_1_index on yaokang.test(a3) pctfree 25 storage (initial 500k)
tablespace ts01
~~~

### 创建位图索引

~~~
create bitmap index yaokang.zzq_2_index on yaokang.test(name) pctfree 25 storage (initial 500k)
tablespace ts01
~~~

### 查询索引所在的表，表空间，索引类型

~~~
col tablespace_name for a15
select index_name,index_type,table_name,tablespace_name,uniqueness,status
from dba_indexes where owner='YAOKANG';
~~~

### 查询索引所在的列

~~~
select index_name,table_name,column_name,index_owner,table_owner
from dba_ind_columns where table_owner='YAOKANG';
~~~

## 主键

### 定义主键

~~~shell
#定义 zzq_3 表中 A1 字段为主键约束 主键名称为 A3_primary_key
alter table yaokang.test ADD constraint id_primary_key primary key (id)
deferrable using index tablespace ts01;
~~~

### 查询主键索引

~~~
col segment_name for a20
select segment_name,segment_type,tablespace_name
from dba_segments where tablespace_name='ts01';
~~~

### 查询约束信息

~~~shell
select constraint_name,table_name,constraint_type,status,deferred,validated
from dba_constraints where owner='YAOKANG';

#状态为 ENABLED表示 主键有效（主键打开），状态为 DISABLED，表示主键关闭
~~~

### 禁止约束

~~~shell
alter table yaokang.test disable novalidate constraint ID_PRIMARY_KEY;
~~~

### 开启主键

~~~
alter table yaokang.test enable novalidate constraint ID_PRIMARY_KEY;
~~~

# 基本的SQL语句

## 对表的操作

~~~shell
#1.创建一张表
Create table 表 (a varchar2(10));
#2.插入内容
Insert into 表 values(‘aa’);
#3.删除内容
Delete from 表名 （可以增加条件 以删除选择的内容）
#4.删除表
Drop table 表名
#5.增加一列
alter table abc add c number
#6.删除一列
alter table abc drop column c
~~~

## 常用的函数

~~~shell
#1.转换函数
to_char
将非字符类型转换为字符型
select to_char(sysdate,'yyyy-mm-dd hh24-mi-ss')
to_date
to_number
#2 聚集函数
avg
max
min
sum
count
#3.系统函数
user
查询当前用户的登陆账号
select user from dual;
decode 函数
select sum(decode(sex,'男',1,0) 男人数,sum(decode(sex,'女',1,0) from e;
查询 e 表中男人数和女人数各有多少，使用 DECODE 函数来做一个判断，if 语句的判断，如果 SEX 为男，
做计数，如果不是男则不做计数。
nvl
对查询的字段做一个标示
select a1,nvl(a2,'未输入') from dual;
如果 a2 的字段为空的话，就显示未输入。
~~~

## 随机查表中的数据

~~~shell
select *
  from (select rownum,c.empno,c.ename,c.job
          from (select * from scott.emp order by dbms_random.value) c
          where rownum <=6);
~~~

