# 类型

## domain

~~~sql
-- 案例
create domain "public"."year" as int4 constraint "year_check" check (value >= 1901 and value <= 2155);
alter domain "public"."year" owner to "postgres";
~~~





https://vimsky.com/examples/usage/postgresql-user-defined-data-type.html

## type

# 序列

~~~sql
-- serial类型
postgres=# create table test_t(id serial,name varchar(100));
CREATE TABLE
postgres=# \d test_t
                                    Table "public.test_t"
 Column |          Type          | Collation | Nullable |              Default               
--------+------------------------+-----------+----------+------------------------------------
 id     | integer                |           | not null | nextval('test_t_id_seq'::regclass)
 name   | character varying(100) |           |          | 
 postgres=# \d
              List of relations
 Schema |     Name      |   Type   |  Owner   
--------+---------------+----------+----------
 public | test_t        | table    | postgres
 public | test_t_id_seq | sequence | postgres
(2 rows)
-- 单独创建序列
postgres=# create sequence  test_s;
CREATE SEQUENCE
-- 孤儿序列查询
select ns.nspname as schema_name,
        seq.relname as seq_name
from pg_class as seq
join pg_namespace ns on (seq.relnamespace=ns.oid)
where seq.relkind='S'
and not exists (select * from pg_depend where objid=seq.oid and deptype='a')
order by seq.relname;

 schema_name | seq_name 
-------------+----------
 public      | test_s
(1 row)


-- 孤儿序列绑定表的字段
postgres=# create table test_t1(id int,name varchar(100));
CREATE TABLE
postgres=# \d test_t1
                      Table "public.test_t1"
 Column |          Type          | Collation | Nullable | Default 
--------+------------------------+-----------+----------+---------
 id     | integer                |           |          | 
 name   | character varying(100) |           |          | 
postgres=# alter sequence test_s owned by test_t1.id;
ALTER SEQUENCE
-- 绑定后删除表test_t1，则test_s序列就会被同时删除

-- 复制表的问题 使用like复制表结构时，会指向同一个序列，会使系统变得复杂
postgres=# create table test_t2 (id serial, info text);
CREATE TABLE
postgres=# \d test_t2
                            Table "public.test_t2"
 Column |  Type   | Collation | Nullable |               Default               
--------+---------+-----------+----------+-------------------------------------
 id     | integer |           | not null | nextval('test_t2_id_seq'::regclass)
 info   | text    |           |          | 

postgres=# create table test_t3 (like test_t2 including all);
CREATE TABLE
postgres=# \d test_t3
                            Table "public.test_t3"
 Column |  Type   | Collation | Nullable |               Default               
--------+---------+-----------+----------+-------------------------------------
 id     | integer |           | not null | nextval('test_t2_id_seq'::regclass)
 info   | text    |           |          | 
~~~





# 表

## 分区表

参考：https://blog.csdn.net/weixin_49756466/article/details/123348922

### 范围分区

~~~sql
create table tbp(n int, t text) partition by range(n);
create table tbp_1 partition of tbp for values from (MINVALUE) to (10);
create table tbp_2 partition of tbp for values from (10) to (100);
create table tbp_3 partition of tbp for values from (100) to (1000);
create table tbp_4 partition of tbp for values from (1000) to (MAXVALUE);


postgres=# \d
               List of relations
 Schema | Name  |       Type        |  Owner   
--------+-------+-------------------+----------
 public | tbp   | partitioned table | postgres
 public | tbp_1 | table             | postgres
 public | tbp_2 | table             | postgres
 public | tbp_3 | table             | postgres
 public | tbp_4 | table             | postgres
(5 rows)

postgres=# select * from pg_partitioned_table;
 partrelid | partstrat | partnatts | partdefid | partattrs | partclass | partcollation | partexprs 
-----------+-----------+-----------+-----------+-----------+-----------+---------------+-----------
     16477 | r         |         1 |         0 | 1         | 1978      | 0             | 
(1 row)


postgres=# \d+ tbp
                              Partitioned table "public.tbp"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 n      | integer |           |          |         | plain    |              | 
 t      | text    |           |          |         | extended |              | 
Partition key: RANGE (n)
Partitions: tbp_1 FOR VALUES FROM (MINVALUE) TO (10),
            tbp_2 FOR VALUES FROM (10) TO (100),
            tbp_3 FOR VALUES FROM (100) TO (1000),
            tbp_4 FOR VALUES FROM (1000) TO (MAXVALUE)


-- 获取分区类型和KEY            
postgres=# SELECT pg_get_partkeydef('tbp'::regclass); 
 pg_get_partkeydef 
-------------------
 RANGE (n)
(1 row)


-- 获取分区范围
postgres=# SELECT pg_get_partition_constraintdef('tbp_1'::regclass) ; 
 pg_get_partition_constraintdef 
--------------------------------
 ((n IS NOT NULL) AND (n < 10))
(1 row)
~~~

### 列表分区

~~~sql
CREATE TABLE sales (product_id int, saleroom int, province text) PARTITION BY LIST(province);
CREATE TABLE sales_east PARTITION OF sales FOR VALUES IN ('山东','江苏','上海');
CREATE TABLE sales_west PARTITION OF sales FOR VALUES IN ('山西','陕西','四川');
CREATE TABLE sales_north PARTITION OF sales FOR VALUES IN ('北京','河北','辽宁');
CREATE TABLE sales_south PARTITION OF sales FOR VALUES IN ('广东','福建');

postgres=# \dt
                  List of relations
 Schema |    Name     |       Type        |  Owner   
--------+-------------+-------------------+----------
 public | sales       | partitioned table | postgres
 public | sales_east  | table             | postgres
 public | sales_north | table             | postgres
 public | sales_south | table             | postgres
 public | sales_west  | table             | postgres
(5 rows)

postgres=# insert into sales values(1,1,'山东'),(2,2,'山西'),(3,3,'北京'),(4,4,'广东');
INSERT 0 4
postgres=# 
postgres=# select * from sales;
 product_id | saleroom | province 
------------+----------+----------
          1 |        1 | 山东
          3 |        3 | 北京
          2 |        2 | 山西
          4 |        4 | 广东
(4 rows)

postgres=# select * from only sales;
 product_id | saleroom | province 
------------+----------+----------
(0 rows)


postgres=# select * from sales_west;
 product_id | saleroom | province 
------------+----------+----------
          2 |        2 | 山西
(1 row)
~~~

### hash分区

语法

~~~sql
-- 主表
CREATE TABLE table_name ( column_name data_type )
    PARTITION BY HASH ( { column_name } [, ... ] )

-- 子表
CREATE TABLE table_name
    PARTITION OF parent_table 
FOR VALUES
    WITH ( MODULUS numeric_literal, REMAINDER numeric_literal )
~~~

哈希分区支持多列分区，下面给出示例：

```sql
create table test_hash(id int, date date) 
  partition by hash(id);

create table test_hash_1 partition of test_hash 
  for values with(modulus 2, remainder 0);

create table test_hash_2 partition of test_hash 
  for values with(modulus 2, remainder 1);

postgres=# \d+ test_hash
                           Partitioned table "public.test_hash"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 id     | integer |           |          |         | plain   |              | 
 date   | date    |           |          |         | plain   |              | 
Partition key: HASH (id)
Partitions: test_hash_1 FOR VALUES WITH (modulus 2, remainder 0),
            test_hash_2 FOR VALUES WITH (modulus 2, remainder 1)

postgres=# 

postgres=# \d+ test_hash_1 
                                Table "public.test_hash_1"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 id     | integer |           |          |         | plain   |              | 
 date   | date    |           |          |         | plain   |              | 
Partition of: test_hash FOR VALUES WITH (modulus 2, remainder 0)
Partition constraint: satisfies_hash_partition('16559'::oid, 2, 0, id)
Access method: heap

postgres=# 
```

示例2：

```sql
create table test_hash_key(x int, y int) 
  partition by hash(x,y);

create table test_hash_key_1 partition of test_hash_key 
  for values with(modulus 2, remainder 0);

create table test_hash_key_2 partition of test_hash_key 
  for values with(modulus 2, remainder 1);

postgres=# \d+ test_hash_key
                         Partitioned table "public.test_hash_key"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 x      | integer |           |          |         | plain   |              | 
 y      | integer |           |          |         | plain   |              | 
Partition key: HASH (x, y)
Partitions: test_hash_key_1 FOR VALUES WITH (modulus 2, remainder 0),
            test_hash_key_2 FOR VALUES WITH (modulus 2, remainder 1)

postgres=# 

postgres=# \d+ test_hash_key_1
                              Table "public.test_hash_key_1"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 x      | integer |           |          |         | plain   |              | 
 y      | integer |           |          |         | plain   |              | 
Partition of: test_hash_key FOR VALUES WITH (modulus 2, remainder 0)
Partition constraint: satisfies_hash_partition('16569'::oid, 2, 0, x, y)
Access method: heap

postgres=# 
```



# 存储过程

~~~sql
CREATE OR REPLACE PROCEDURE transfer(INT, INT, DEC)
	LANGUAGE plpgsql    
	AS $$
	BEGIN
		-- subtracting the amount from the sender's account 
		UPDATE accounts 
		SET balance = balance - $3
		WHERE id = $1;
	 
		-- adding the amount to the receiver's account
		UPDATE accounts 
		SET balance = balance + $3
		WHERE id = $2 ;
	 
		COMMIT;
	END;
	$$;
~~~



# 应用

## 行列转换

PostgreSQL 实现交叉表（行列转换）的五种方法
https://blog.csdn.net/a258831020/article/details/48446213
PostgreSQL中的crosstab（行转列函数）
https://blog.csdn.net/qq_31156277/article/details/90598311
PostgreSQL_行列转换pivot_unpivot
https://blog.csdn.net/weixin_34388207/article/details/91424011

## 常用函数

~~~sql
#多列合并为一行
string_agg
#拆分一列为多列
split_part
#postgreSQL格式化时间的函数详解
https://blog.csdn.net/snn1410/article/details/7741283

#代替in的查询写法
select name,setting,unit,context from pg_settings
where name = any(string_to_array('a,b,c,d',','));
~~~



## 窗口函数

https://blog.csdn.net/weixin_39870155/article/details/111291051
