# 数据库

## 创建数据库

~~~sql
create database testdb with owner=test_user template=template0 encoding='UTF8' lc_collate='C' lc_ctype='en_US.UTF8' connection limit=-1;
~~~



# 类型

## domain

~~~sql
-- 案例
create domain "public"."year" as int4 constraint "year_check" check (value >= 1901 and value <= 2155);
alter domain "public"."year" owner to "postgres";
~~~





https://vimsky.com/examples/usage/postgresql-user-defined-data-type.html

## type

# 序列

~~~sql
-- 创建序列
CREATE SEQUENCE snc_seq INCREMENT BY 1 START WITH 1 NO MAXvalue NO CYCLE CACHE 10;
-- 查看序列
select * from snc_seq;
-- 查看序列当前值
select currval('snc_seq');
-- 获取序列下一个值
select nextval('snc_seq');
-- 序列相关的表或者视图
select * from pg_sequence;
select * from pg_sequences;
select * from information_schema.sequences;

-- serial类型
postgres=# create table test_t(id serial,name varchar(100));
CREATE TABLE
postgres=# \d test_t
                                    Table "public.test_t"
 Column |          Type          | Collation | Nullable |              Default               
--------+------------------------+-----------+----------+------------------------------------
 id     | integer                |           | not null | nextval('test_t_id_seq'::regclass)
 name   | character varying(100) |           |          | 
 postgres=# \d
              List of relations
 Schema |     Name      |   Type   |  Owner   
--------+---------------+----------+----------
 public | test_t        | table    | postgres
 public | test_t_id_seq | sequence | postgres
(2 rows)
-- 单独创建序列
postgres=# create sequence  test_s;
CREATE SEQUENCE
-- 孤儿序列查询
select ns.nspname as schema_name,
        seq.relname as seq_name
from pg_class as seq
join pg_namespace ns on (seq.relnamespace=ns.oid)
where seq.relkind='S'
and not exists (select * from pg_depend where objid=seq.oid and deptype='a')
order by seq.relname;

 schema_name | seq_name 
-------------+----------
 public      | test_s
(1 row)


-- 孤儿序列绑定表的字段
postgres=# create table test_t1(id int,name varchar(100));
CREATE TABLE
postgres=# \d test_t1
                      Table "public.test_t1"
 Column |          Type          | Collation | Nullable | Default 
--------+------------------------+-----------+----------+---------
 id     | integer                |           |          | 
 name   | character varying(100) |           |          | 
postgres=# alter sequence test_s owned by test_t1.id;
ALTER SEQUENCE
-- 绑定后删除表test_t1，则test_s序列就会被同时删除

-- 复制表的问题 使用like复制表结构时，会指向同一个序列，会使系统变得复杂
postgres=# create table test_t2 (id serial, info text);
CREATE TABLE
postgres=# \d test_t2
                            Table "public.test_t2"
 Column |  Type   | Collation | Nullable |               Default               
--------+---------+-----------+----------+-------------------------------------
 id     | integer |           | not null | nextval('test_t2_id_seq'::regclass)
 info   | text    |           |          | 

postgres=# create table test_t3 (like test_t2 including all);
CREATE TABLE
postgres=# \d test_t3
                            Table "public.test_t3"
 Column |  Type   | Collation | Nullable |               Default               
--------+---------+-----------+----------+-------------------------------------
 id     | integer |           | not null | nextval('test_t2_id_seq'::regclass)
 info   | text    |           |          | 
~~~





# 表

## 普通表

### 创建表

**基于类型创建表**

```sql
-- 语法
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] table_name
    OF type_name [ (
  { column_name [ WITH OPTIONS ] [ column_constraint [ ... ] ]
    | table_constraint }
    [, ... ]

-- 案例
create type type_student as (id int,name varchar,set varchar,age int,class int,grade int);
create table student_t of type_student(constraint id_pk primary key(id));
```



~~~sql
-- 表注释
comment on table test.test_t is 'This is a test table';
~~~



**生成列**

```sql
-- 语法
GENERATED ALWAYS AS ( generation_expr ) STORED

-- 此子句将列创建为generated column。 列无法被写入，读取时将返回指定表达式的结果。
-- 关键字STORED表示将在写入时计算列并将存储在磁盘上。
-- 生成表达式可以引用表中的其他列，但不能引用其他生成的列。使用的任何函数和运算符都必须是不可改变的。不允许引用其他表。

-- 案例
create table test_t (
id int,
name varchar(100),
lower_name varchar(100) generated always as (lower(name)) stored
);
insert into test_t (id,name) values (1,'ZhangSan');
```









### 修改表

~~~sql
-- 添加字段
alter table test_t add column col1 varchar(100);
-- 删除字段
alter table test_t drop col1;
-- 表更改字段
alter table demo1 alter column c3 type varchar(10);
-- 添加字段时字段存在也不报错
alter table test_t add column if not exists col1 varchar(100);
-- 针对表设置指定参数
alter table test set (autovacuum_vacuum_scale_factor=0.1);
-- 修改表的 schema
alter table t_city set schema sncadmin;
-- alter 语句重复执行
blog.csdn.net/qq_36744540/article/details/130861767
~~~

创建生成列

```sql
create table test_t(id int,name varchar(100));
insert into test_t values(1,'ZhanSan'),(2,'LiSi');
alter table test_t add lower_name varchar(100) generated always as (lower(name)) stored;
```

修改表字段名重复执行

```sql
-- 方式1
create table test_t(id int,name text);

do $$ DECLARE
v_tmp text;
BEGIN
  select id into v_tmp from test_t limit 1;
  alter table test_t rename column id to test_id;
  alter table test_t alter column test_id set data type text using test_id::text;
  comment on column test_t.test_id is 'xxx';
  exception
  when others then
  null;
end $$;

-- 方式2
create table test_t(id int,name text);

DO $$
BEGIN
    -- 先检查目标列是否已经存在
    IF NOT EXISTS (
        SELECT 1
        FROM information_schema.columns
        WHERE table_name = 'test_t'
          AND column_name = 'test_id'   -- 新字段名
    ) THEN
        -- 如果目标列名不存在，执行重命名
        EXECUTE 'ALTER TABLE test_t RENAME COLUMN id TO test_id';
    ELSE
        RAISE NOTICE 'Column new_column_name already exists or was previously renamed.';
    END IF;
END $$;
```







### 复制表

```sql
-- 表结构和数据都复制（不复制键值关系、索引、默认值、约束等）
create table new_table as table existing_table;
-- 只复制表结构（不复制键值关系、索引、默认值、约束等）
create table new_table as table existing_table with no data;
-- 表结构和部分表数据（CTAS）：不复制键值关系、索引、默认值、约束等
create table new_table as select * from existing_table where condition;
-- 只复制表结构，不复制数据和约束、索引、默认值等（like选项）
create table new_table (like existing_table)
-- 表结构和所有属性（like + including all）
create table new_table (like existing_table including all)
```





## 填充因子

PostgreSQL数据库中的填充因子是一个重要的性质，对于表和索引也同样重要。填充因子定义了一个表或索引的物理存储拥有多少空间是用来存储实际数据的，多少空间留白来应对更新或其他动态改变。默认情况下，PostgreSQL的填充因子为100，表示100%的空间将被用于存储实际数据，无空间留白。 

假设现在我们有一个在线商店，它有一个名为`orders`的表来存储订单数据。如果订单状态经常变更，例如从"pending"变为"shipped"，那么选择合适的填充因子可能会提高性能。

创建一个分区表并设置一个填充因子可能如下：

```sql
CREATE TABLE orders (
    id serial NOT NULL,
    total_price decimal(5, 2) NOT NULL,
    status varchar(15) NOT NULL,
    created_at timestamp without time zone NOT NULL,
    updated_at timestamp without time zone NOT NULL
) PARTITION BY RANGE (created_at) 
WITH (fillfactor = 70);
```

在此语句中，PARTITION BY RANGE (created_at)，定义了这是一个按照时间范围进行划分的分区表，fillfactor = 70表示每个分区数据块中70%的空间是用来存储实际数据，其余30%的空间留白以便接收对现有行的更新，这样可以减少Row Update时候的数据碎片。

然后可以再为该表分别创建分区：

```sql
CREATE TABLE orders_y2023 PARTITION OF orders
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01') 
    WITH (fillfactor = 70);

CREATE TABLE orders_y2024 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2025-01-01') 
    WITH (fillfactor = 70);
```

这样，根据订单的创建时间(`created_at`)，数据将会被自动分配到相应的分区中，并且每个分区也维护了填充因子为70的设置。

## 分区表

参考：

https://blog.csdn.net/weixin_49756466/article/details/123348922

https://blog.csdn.net/qq_38567039/article/details/119751897



### 范围分区

~~~sql
create table tbp(n int, t text) partition by range(n);
create table tbp_1 partition of tbp for values from (MINVALUE) to (10);
create table tbp_2 partition of tbp for values from (10) to (100);
create table tbp_3 partition of tbp for values from (100) to (1000);
create table tbp_4 partition of tbp for values from (1000) to (MAXVALUE);


postgres=# \d
               List of relations
 Schema | Name  |       Type        |  Owner   
--------+-------+-------------------+----------
 public | tbp   | partitioned table | postgres
 public | tbp_1 | table             | postgres
 public | tbp_2 | table             | postgres
 public | tbp_3 | table             | postgres
 public | tbp_4 | table             | postgres
(5 rows)

postgres=# select * from pg_partitioned_table;
 partrelid | partstrat | partnatts | partdefid | partattrs | partclass | partcollation | partexprs 
-----------+-----------+-----------+-----------+-----------+-----------+---------------+-----------
     16477 | r         |         1 |         0 | 1         | 1978      | 0             | 
(1 row)


postgres=# \d+ tbp
                              Partitioned table "public.tbp"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description 
--------+---------+-----------+----------+---------+----------+--------------+-------------
 n      | integer |           |          |         | plain    |              | 
 t      | text    |           |          |         | extended |              | 
Partition key: RANGE (n)
Partitions: tbp_1 FOR VALUES FROM (MINVALUE) TO (10),
            tbp_2 FOR VALUES FROM (10) TO (100),
            tbp_3 FOR VALUES FROM (100) TO (1000),
            tbp_4 FOR VALUES FROM (1000) TO (MAXVALUE)


-- 获取分区类型和KEY            
postgres=# SELECT pg_get_partkeydef('tbp'::regclass); 
 pg_get_partkeydef 
-------------------
 RANGE (n)
(1 row)


-- 获取分区范围
postgres=# SELECT pg_get_partition_constraintdef('tbp_1'::regclass) ; 
 pg_get_partition_constraintdef 
--------------------------------
 ((n IS NOT NULL) AND (n < 10))
(1 row)
~~~

### 列表分区

~~~sql
CREATE TABLE sales (product_id int, saleroom int, province text) PARTITION BY LIST(province);
CREATE TABLE sales_east PARTITION OF sales FOR VALUES IN ('山东','江苏','上海');
CREATE TABLE sales_west PARTITION OF sales FOR VALUES IN ('山西','陕西','四川');
CREATE TABLE sales_north PARTITION OF sales FOR VALUES IN ('北京','河北','辽宁');
CREATE TABLE sales_south PARTITION OF sales FOR VALUES IN ('广东','福建');

postgres=# \dt
                  List of relations
 Schema |    Name     |       Type        |  Owner   
--------+-------------+-------------------+----------
 public | sales       | partitioned table | postgres
 public | sales_east  | table             | postgres
 public | sales_north | table             | postgres
 public | sales_south | table             | postgres
 public | sales_west  | table             | postgres
(5 rows)

postgres=# insert into sales values(1,1,'山东'),(2,2,'山西'),(3,3,'北京'),(4,4,'广东');
INSERT 0 4
postgres=# 
postgres=# select * from sales;
 product_id | saleroom | province 
------------+----------+----------
          1 |        1 | 山东
          3 |        3 | 北京
          2 |        2 | 山西
          4 |        4 | 广东
(4 rows)

postgres=# select * from only sales;
 product_id | saleroom | province 
------------+----------+----------
(0 rows)


postgres=# select * from sales_west;
 product_id | saleroom | province 
------------+----------+----------
          2 |        2 | 山西
(1 row)
~~~

### hash分区

语法

~~~sql
-- 主表
CREATE TABLE table_name ( column_name data_type )
    PARTITION BY HASH ( { column_name } [, ... ] )

-- 子表
CREATE TABLE table_name
    PARTITION OF parent_table 
FOR VALUES
    WITH ( MODULUS numeric_literal, REMAINDER numeric_literal )
~~~

哈希分区支持多列分区，下面给出示例：

```sql
create table test_hash(id int, date date) 
  partition by hash(id);

create table test_hash_1 partition of test_hash 
  for values with(modulus 2, remainder 0);

create table test_hash_2 partition of test_hash 
  for values with(modulus 2, remainder 1);

postgres=# \d+ test_hash
                           Partitioned table "public.test_hash"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 id     | integer |           |          |         | plain   |              | 
 date   | date    |           |          |         | plain   |              | 
Partition key: HASH (id)
Partitions: test_hash_1 FOR VALUES WITH (modulus 2, remainder 0),
            test_hash_2 FOR VALUES WITH (modulus 2, remainder 1)

postgres=# 

postgres=# \d+ test_hash_1 
                                Table "public.test_hash_1"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 id     | integer |           |          |         | plain   |              | 
 date   | date    |           |          |         | plain   |              | 
Partition of: test_hash FOR VALUES WITH (modulus 2, remainder 0)
Partition constraint: satisfies_hash_partition('16559'::oid, 2, 0, id)
Access method: heap

postgres=# 
```

示例2：

```sql
create table test_hash_key(x int, y int) 
  partition by hash(x,y);

create table test_hash_key_1 partition of test_hash_key 
  for values with(modulus 2, remainder 0);

create table test_hash_key_2 partition of test_hash_key 
  for values with(modulus 2, remainder 1);

postgres=# \d+ test_hash_key
                         Partitioned table "public.test_hash_key"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 x      | integer |           |          |         | plain   |              | 
 y      | integer |           |          |         | plain   |              | 
Partition key: HASH (x, y)
Partitions: test_hash_key_1 FOR VALUES WITH (modulus 2, remainder 0),
            test_hash_key_2 FOR VALUES WITH (modulus 2, remainder 1)

postgres=# 

postgres=# \d+ test_hash_key_1
                              Table "public.test_hash_key_1"
 Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
--------+---------+-----------+----------+---------+---------+--------------+-------------
 x      | integer |           |          |         | plain   |              | 
 y      | integer |           |          |         | plain   |              | 
Partition of: test_hash_key FOR VALUES WITH (modulus 2, remainder 0)
Partition constraint: satisfies_hash_partition('16569'::oid, 2, 0, x, y)
Access method: heap

postgres=# 
```

### 组合分区

oracle中支持多种分区类型的组合，组合分区是range、hash、list分区的相互组合，但不允许hash分区作为 Top level。
pg中同样也支持类似的组合分区，PG支持非常灵活的分区布局，支持任意层级的分区，支持每个分区的层级深度不一样。通过detach、attach的方法来实现分区的拆分、合并。

#### hash-hash

创建hash分区表

```sql
-- 创建4个分区
postgres=# create table t_hash (id int , info text) PARTITION BY hash (id);
CREATE TABLE
postgres=# create table t_hash0 partition of t_hash FOR VALUES with (MODULUS 4, REMAINDER 0);
CREATE TABLE
postgres=# create table t_hash1 partition of t_hash FOR VALUES with (MODULUS 4, REMAINDER 1);
CREATE TABLE
postgres=# create table t_hash2 partition of t_hash FOR VALUES with (MODULUS 4, REMAINDER 2);
CREATE TABLE
postgres=# create table t_hash3 partition of t_hash FOR VALUES with (MODULUS 4, REMAINDER 3);
CREATE TABLE
postgres=#
```

查看分区表

```sql
postgres=# \d+ t_hash
                             Partitioned table "public.t_hash"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description
--------+---------+-----------+----------+---------+----------+--------------+-------------
 id     | integer |           |          |         | plain    |              |
 info   | text    |           |          |         | extended |              |
Partition key: HASH (id)
Partitions: t_hash0 FOR VALUES WITH (modulus 4, remainder 0),
            t_hash1 FOR VALUES WITH (modulus 4, remainder 1),
            t_hash2 FOR VALUES WITH (modulus 4, remainder 2),
            t_hash3 FOR VALUES WITH (modulus 4, remainder 3)

postgres=#
```

插入数据查看数据分布

```sql
postgres=# insert into t_hash select generate_series(1,10);
INSERT 0 10
postgres=# select tableoid::regclass,* from t_hash;
 tableoid | id | info
----------+----+------
 t_hash0  |  1 |
 t_hash1  |  3 |
 t_hash1  |  5 |
 t_hash1  |  8 |
 t_hash1  |  9 |
 t_hash2  |  2 |
 t_hash3  |  4 |
 t_hash3  |  6 |
 t_hash3  |  7 |
 t_hash3  | 10 |
(10 rows)
```

接下来将t_hash1分区拆分成2个分区，即其它分区作为直接分区，而t_hash1分区被1个二级分区代替。

解绑分区

```sql
postgres=# alter table t_hash DETACH PARTITION t_hash1;
ALTER TABLE
postgres=#
```

创建二级分区

```sql
postgres=# create table t_hash1_subp (id int, info text) PARTITION BY hash (id);
CREATE TABLE
postgres=# create table t_hash1_subp1 partition of t_hash1_subp FOR VALUES with (MODULUS 8, REMAINDER 1);
CREATE TABLE
postgres=# create table t_hash1_subp5 partition of t_hash1_subp FOR VALUES with (MODULUS 8, REMAINDER 5);
CREATE TABLE
postgres=#
```

绑定二级分区到一级分区

```sql
postgres=# alter table t_hash attach partition t_hash1_subp FOR VALUES WITH ( MODULUS 4, REMAINDER 1 );
ALTER TABLE
```

将原来子分区的数据写入新的二级分区表(数据迁移)

```sql
postgres=# insert into t_hash1_subp select * from t_hash1;
INSERT 0 4
```

查询数据

```sql
postgres=# select tableoid::regclass,* from t_hash;
   tableoid    | id | info
---------------+----+------
 t_hash0       |  1 |
 t_hash1_subp1 |  3 |
 t_hash1_subp5 |  5 |
 t_hash1_subp5 |  8 |
 t_hash1_subp5 |  9 |
 t_hash2       |  2 |
 t_hash3       |  4 |
 t_hash3       |  6 |
 t_hash3       |  7 |
 t_hash3       | 10 |
(10 rows)
```

查看分区表情况

```sql
-- 可以发现分区表变成了非平衡的复合分区
postgres=# \d+ t_hash
                             Partitioned table "public.t_hash"
 Column |  Type   | Collation | Nullable | Default | Storage  | Stats target | Description
--------+---------+-----------+----------+---------+----------+--------------+-------------
 id     | integer |           |          |         | plain    |              |
 info   | text    |           |          |         | extended |              |
Partition key: HASH (id)
Partitions: t_hash0 FOR VALUES WITH (modulus 4, remainder 0),
            t_hash1_subp FOR VALUES WITH (modulus 4, remainder 1), PARTITIONED,
            t_hash2 FOR VALUES WITH (modulus 4, remainder 2),
            t_hash3 FOR VALUES WITH (modulus 4, remainder 3)
```

同样，我们还可以将其它分区拆分，例如将t_hash2拆分成range分区或者list分区，实现oracle组合分区一样的功能，且更加灵活(支持hash分区作为一级分区)。

#### range-list

~~~sql
-- 创建主分区表
CREATE TABLE sales (
    id int,
    region VARCHAR(50),
    sales_date DATE,
    amount NUMERIC
) PARTITION BY RANGE (sales_date);

-- 创建一级分区
CREATE TABLE sales_2023 PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2024-01-01') PARTITION BY LIST (region);
CREATE TABLE sales_2024 PARTITION OF sales FOR VALUES FROM ('2024-01-01') TO ('2025-01-01') PARTITION BY LIST (region);

-- 创建二级分区
CREATE TABLE sales_2023_north PARTITION OF sales_2023 FOR VALUES IN ('North');
CREATE TABLE sales_2023_south PARTITION OF sales_2023 FOR VALUES IN ('South');
CREATE TABLE sales_2023_east PARTITION OF sales_2023 FOR VALUES IN ('East');
CREATE TABLE sales_2023_west PARTITION OF sales_2023 FOR VALUES IN ('West');
CREATE TABLE sales_2024_north PARTITION OF sales_2024 FOR VALUES IN ('North');
CREATE TABLE sales_2024_south PARTITION OF sales_2024 FOR VALUES IN ('South');
CREATE TABLE sales_2024_east PARTITION OF sales_2024 FOR VALUES IN ('East');
CREATE TABLE sales_2024_west PARTITION OF sales_2024 FOR VALUES IN ('West');
~~~



# 触发器

## 事件触发器

PostgreSQL还提供了事件触发器实现第38章探讨的触发器机制。与普通的触发器不同，事件触发器针对整个数据库，且可捕获DDL事件。

事件触发器可使用具有事件触发器支持的过程语言或C编写，但不可使用纯SQL编写。

事件触发器在相关事件发生时触发。当前，支持的事件有ddl_command_start，ddl_command_end，table_rewrite和sql_drop。

ddl_command_start事件在执行CREATE，ALTER，DROP，SECURITY LABEL，COMMENT，GRANT或REVOKE命令前发生。在事件触发器触发之前，不会检查所影响的对象是否存在。不过，针对共享对象（如数据库，角色和表空间）或对事件触发器本身的DDL命令不会触发该事件。事件触发器机制不支持此类对象类型。

因为SELECT INTO命令等价于CREATE TABLE AS，故也会触发ddl_command_start事件。

ddl_comand_end事件在相同DDL命令之后触发。触发器在操作发生后（事务提交前）触发。

sql_drop在删除数据库对象时触发（在ddl_comand_end之前）。可使用pg_event_trigger_dropped_objects()列出删除的数据库对象。该触发器是在将对象从系统视图删除后执行的。

table_rewrite事件在表被ALTER TABLE和ALTER TYPE重写前触发。

事件触发器支持的命令列表

**Table 39.1. Event Trigger Support by Command Tag**

| Command Tag                        | `ddl_command_start` | `ddl_command_end` | `sql_drop` | `table_rewrite` | Notes                  |
| ---------------------------------- | ------------------- | ----------------- | ---------- | --------------- | ---------------------- |
| `ALTER AGGREGATE`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER COLLATION`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER CONVERSION`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER DOMAIN`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER DEFAULT PRIVILEGES`         | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER EXTENSION`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER FOREIGN DATA WRAPPER`       | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER FOREIGN TABLE`              | `X`                 | `X`               | `X`        | `-`             |                        |
| `ALTER FUNCTION`                   | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER LANGUAGE`                   | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER LARGE OBJECT`               | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER MATERIALIZED VIEW`          | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER OPERATOR`                   | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER OPERATOR CLASS`             | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER OPERATOR FAMILY`            | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER POLICY`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER PROCEDURE`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER PUBLICATION`                | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER ROUTINE`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER SCHEMA`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER SEQUENCE`                   | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER SERVER`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER STATISTICS`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER SUBSCRIPTION`               | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TABLE`                      | `X`                 | `X`               | `X`        | `X`             |                        |
| `ALTER TEXT SEARCH CONFIGURATION`  | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TEXT SEARCH DICTIONARY`     | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TEXT SEARCH PARSER`         | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TEXT SEARCH TEMPLATE`       | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TRIGGER`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER TYPE`                       | `X`                 | `X`               | `-`        | `X`             |                        |
| `ALTER USER MAPPING`               | `X`                 | `X`               | `-`        | `-`             |                        |
| `ALTER VIEW`                       | `X`                 | `X`               | `-`        | `-`             |                        |
| `COMMENT`                          | `X`                 | `X`               | `-`        | `-`             | Only for local objects |
| `CREATE ACCESS METHOD`             | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE AGGREGATE`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE CAST`                      | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE COLLATION`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE CONVERSION`                | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE DOMAIN`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE EXTENSION`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE FOREIGN DATA WRAPPER`      | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE FOREIGN TABLE`             | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE FUNCTION`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE INDEX`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE LANGUAGE`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE MATERIALIZED VIEW`         | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE OPERATOR`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE OPERATOR CLASS`            | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE OPERATOR FAMILY`           | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE POLICY`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE PROCEDURE`                 | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE PUBLICATION`               | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE RULE`                      | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE SCHEMA`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE SEQUENCE`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE SERVER`                    | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE STATISTICS`                | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE SUBSCRIPTION`              | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TABLE`                     | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TABLE AS`                  | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TEXT SEARCH CONFIGURATION` | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TEXT SEARCH DICTIONARY`    | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TEXT SEARCH PARSER`        | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TEXT SEARCH TEMPLATE`      | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TRIGGER`                   | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE TYPE`                      | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE USER MAPPING`              | `X`                 | `X`               | `-`        | `-`             |                        |
| `CREATE VIEW`                      | `X`                 | `X`               | `-`        | `-`             |                        |
| `DROP ACCESS METHOD`               | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP AGGREGATE`                   | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP CAST`                        | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP COLLATION`                   | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP CONVERSION`                  | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP DOMAIN`                      | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP EXTENSION`                   | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP FOREIGN DATA WRAPPER`        | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP FOREIGN TABLE`               | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP FUNCTION`                    | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP INDEX`                       | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP LANGUAGE`                    | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP MATERIALIZED VIEW`           | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP OPERATOR`                    | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP OPERATOR CLASS`              | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP OPERATOR FAMILY`             | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP OWNED`                       | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP POLICY`                      | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP PROCEDURE`                   | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP PUBLICATION`                 | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP ROUTINE`                     | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP RULE`                        | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP SCHEMA`                      | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP SEQUENCE`                    | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP SERVER`                      | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP STATISTICS`                  | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP SUBSCRIPTION`                | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TABLE`                       | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TEXT SEARCH CONFIGURATION`   | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TEXT SEARCH DICTIONARY`      | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TEXT SEARCH PARSER`          | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TEXT SEARCH TEMPLATE`        | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TRIGGER`                     | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP TYPE`                        | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP USER MAPPING`                | `X`                 | `X`               | `X`        | `-`             |                        |
| `DROP VIEW`                        | `X`                 | `X`               | `X`        | `-`             |                        |
| `GRANT`                            | `X`                 | `X`               | `-`        | `-`             | Only for local objects |
| `IMPORT FOREIGN SCHEMA`            | `X`                 | `X`               | `-`        | `-`             |                        |
| `REFRESH MATERIALIZED VIEW`        | `X`                 | `X`               | `-`        | `-`             |                        |
| `REVOKE`                           | `X`                 | `X`               | `-`        | `-`             | Only for local objects |
| `SECURITY LABEL`                   | `X`                 | `X`               | `-`        | `-`             | Only for local objects |
| `SELECT INTO`                      | `X`                 | `X`               | `-`        | `-`             |                        |

https://www.postgresql.org/docs/13/event-trigger-matrix.html

事件触发器使用命令CREATE EVENT TRIGGER命令创建。创建事件触发器之前，需要先创建返回event_trigger类型的触发器函数。

触发器定义中，也可使用WHEN指定触发的特定命令。

## 参考：

https://blog.csdn.net/ghostliming/article/details/115457201

PostgreSQL触发器总结

https://www.cnblogs.com/kuang17/p/13140977.html

# 存储过程

~~~sql
CREATE OR REPLACE PROCEDURE transfer(INT, INT, DEC)
	LANGUAGE plpgsql    
	AS $$
	BEGIN
		-- subtracting the amount from the sender's account 
		UPDATE accounts 
		SET balance = balance - $3
		WHERE id = $1;
	 
		-- adding the amount to the receiver's account
		UPDATE accounts 
		SET balance = balance + $3
		WHERE id = $2 ;
	 
		COMMIT;
	END;
	$$;
~~~



# 应用

## 字符串处理

### PostgreSQL nvl

~~~sql
create table test_t (id int,name varchar2(100));
insert into test_t values(1,'test1'),(2,null),(3,''),(4,'test4'),(5,null);
select id,coalesce(nullif(name,null),'none') from test_t;

postgres=# select * from test_t;
 id | name  
----+-------
  1 | test1
  2 | 
  3 | 
  4 | test4
  5 | 
(5 rows)

postgres=# select id,coalesce(nullif(name,null),'none') from test_t;
 id | coalesce 
----+----------
  1 | test1
  2 | none
  3 | 
  4 | test4
  5 | none
(5 rows)
~~~

<font color='red'>注意：在PostgreSQL中空字符串和null值不是一个意思（这点和Oracle不同）</font>

~~~sql
-- Oracle中的nvl
create table test_t (id int,name varchar2(100));
insert into test_t values (1,'test1');
insert into test_t values (2,null);
insert into test_t values (3,'');
insert into test_t values (4,'test4');
insert into test_t values (5,null);
commit;
select * from test_t;
select id,nvl(name,'none') as name from test_t;

SQL> select * from test_t;

  ID NAME
---- ----------
   1 test1
   2
   3
   4 test4
   5

SQL> select id,nvl(name,'none') as name from test_t;

  ID NAME
---- ----------
   1 test1
   2 none
   3 none
   4 test4
   5 none

SQL> 
~~~

### PostgreSQL 字段拼接

一段一段的字符拼接，为了转义单引号，界定符使用$$（两个连续的）

~~~sql
create table test_t (id int,name varchar(100));
insert into test_t values(1,'test1'),(2,'test2'),(3,'test3'),(4,'test4'),(5,'test5');
select $$insert into test_t values ($$ || id || $$,'$$ || name || $$');$$ as insert_sql
from (select * from test_t) t1;

postgres=# select $$insert into test_t values ($$ || id || $$,'$$ || name || $$');$$ as insert_sql
postgres-# from (select * from test_t) t1;
               insert_sql               
----------------------------------------
 insert into test_t values (1,'test1');
 insert into test_t values (2,'test2');
 insert into test_t values (3,'test3');
 insert into test_t values (4,'test4');
 insert into test_t values (5,'test5');
(5 rows)
~~~

### 动态SQL拼接

#### format

~~~sql
-- 创建测试函数
CREATE OR REPLACE FUNCTION my_test_function(arg1 INT DEFAULT 10)
RETURNS INT AS $$
BEGIN
    RETURN arg1;
END;
$$ LANGUAGE plpgsql;


-- 动态拼接SQL
SELECT FORMAT('DROP FUNCTION %s(%s);'
             ,p.oid::regproc
             ,pg_get_function_identity_arguments(p.oid))
FROM pg_proc AS p 
INNER JOIN pg_namespace AS n 
	ON p.pronamespace = n.oid 
WHERE n.nspname NOT IN ('pg_catalog', 'information_schema');
~~~



### 代替in的查询写法

~~~sql
create table test_t (id int,name varchar(100));
insert into test_t values(1,'test1'),(2,'test2'),(3,'test3'),(4,'test4'),(5,'test5');

postgres=# select * from test_t where name in('test1','test3','test5');
 id | name  
----+-------
  1 | test1
  3 | test3
  5 | test5
(3 rows)

postgres=# select * from test_t where name=any(string_to_array('test1,test3,test5',','));
 id | name  
----+-------
  1 | test1
  3 | test3
  5 | test5
(3 rows)
~~~



### 字符串转换

**regexp_split_to_table**
将字符串转换成结果集

~~~sql
postgres=# select regexp_split_to_table(coalesce('/home/postgres/test.sh',''),E'\/');
 regexp_split_to_table 
-----------------------
 
 home
 postgres
 test.sh
(4 rows)
~~~



**regexp_split_to_array**
将字符串转换成数组

~~~sql
postgres=# select regexp_split_to_array(coalesce('/home/postgres/test.sh',''),E'\/');
   regexp_split_to_array    
----------------------------
 {"",home,postgres,test.sh}
(1 row)
~~~

### 字符串函数汇总

https://blog.csdn.net/xiaohuihui1400/article/details/130284568

### 字符串转换为二进制和回转

```sql
-- 字符串转为二进制
postgres=# select '测试数据001'::bytea;
              bytea
----------------------------------
 \xe6b58be8af95e695b0e68dae303031
(1 row)

-- 二进制回转为字符串
postgres=# select convert_from('\xe6b58be8af95e695b0e68dae303031','UTF-8');
 convert_from
--------------
 测试数据001
(1 row)
```







## 行列转换

PostgreSQL 实现交叉表（行列转换）的五种方法
https://blog.csdn.net/a258831020/article/details/48446213
PostgreSQL中的crosstab（行转列函数）
https://blog.csdn.net/qq_31156277/article/details/90598311
PostgreSQL_行列转换pivot_unpivot
https://blog.csdn.net/weixin_34388207/article/details/91424011

PostgreSQL 如何实现数据透视表

https://blog.csdn.net/horses/article/details/107958046

Postgresql实现动态的行转列

https://www.jianshu.com/p/31c586446512

https://gitee.com/tttzzzqqq/tzq-learn/blob/ecc4ef0f0954814ed1d60e4f1317cde08e939f50/flask/tutorial/flaskr/static/sql/tmp.sql

## 常用函数

~~~sql
#多列合并为一行
string_agg
#拆分一列为多列
split_part
~~~



## 数据类型格式化函数

PostgreSQL格式化函数提供一套有效的工具用于把各种数据类型(日期/时间、integer、floating point和numeric)转换成格式化的字符串以及反过来从格式化的字符串转换成指定的数据类型。下面列出了这些函数，它们都遵循一个公共的调用习惯：第一个参数是待格式化的值，而第二个是定义输出或输出格式的模板。

| 函数                            | 返回类型  | 描述                      | 例子                                         |
| ------------------------------- | --------- | ------------------------- | -------------------------------------------- |
| to_char(timestamp, text)        | text      | 把时间戳转换成字串        | to_char(current_timestamp, 'HH12:MI:SS')     |
| to_char(interval, text)         | text      | 把时间间隔转为字串        | to_char(interval '15h 2m 12s', 'HH24:MI:SS') |
| to_char(int, text)              | text      | 把整数转换成字串          | to_char(125, '999')                          |
| to_char(double precision, text) | text      | 把实数/双精度数转换成字串 | to_char(125.8::real, '999D9')                |
| to_char(numeric, text)          | text      | 把numeric转换成字串       | to_char(-125.8, '999D99S')                   |
| to_date(text, text)             | date      | 把字串转换成日期          | to_date('05 Dec 2000', 'DD Mon YYYY')        |
| to_timestamp(text, text)        | timestamp | 把字串转换成时间戳        | to_timestamp('05 Dec 2000', 'DD Mon YYYY')   |
| to_timestamp(double)            | timestamp | 把UNIX纪元转换成时间戳    | to_timestamp(200120400)                      |
| to_number(text, text)           | numeric   | 把字串转换成numeric       | to_number('12,454.8-', '99G999D9S')          |

~~~sql
postgres=# select to_char(current_timestamp, 'HH12:MI:SS');
 to_char  
----------
 09:56:35
(1 row)

postgres=# select to_char(interval '15h 2m 12s', 'HH24:MI:SS');
 to_char  
----------
 15:02:12
(1 row)

postgres=# select to_char(125, '999');
 to_char 
---------
  125
(1 row)

postgres=# select to_char(125.8::real, '999D9');
 to_char 
---------
  125.8
(1 row)

postgres=# select to_char(-125.8, '999D99S');
 to_char 
---------
 125.80-
(1 row)

postgres=# select to_date('05 Dec 2000', 'DD Mon YYYY');
  to_date   
------------
 2000-12-05
(1 row)

postgres=# select to_timestamp('05 Dec 2000', 'DD Mon YYYY');
      to_timestamp      
------------------------
 2000-12-05 00:00:00+08
(1 row)

postgres=# select to_timestamp(200120400);
      to_timestamp      
------------------------
 1976-05-05 13:00:00+08
(1 row)

postgres=# select to_number('12,454.8-', '99G999D9S');
 to_number 
-----------
  -12454.8
(1 row)
~~~

## 用于数值格式化的模板模式

| 模式    | 描述                             |
| ------- | -------------------------------- |
| 9       | 带有指定数值位数的值             |
| 0       | 带前导零的值                     |
| .(句点) | 小数点                           |
| ,(逗号) | 分组(千)分隔符                   |
| PR      | 尖括号内负值                     |
| S       | 带符号的数值                     |
| L       | 货币符号                         |
| D       | 小数点                           |
| G       | 分组分隔符                       |
| MI      | 在指明的位置的负号(如果数字 < 0) |
| PL      | 在指明的位置的正号(如果数字 > 0) |
| SG      | 在指明的位置的正/负号            |

## 时间格式化的函数详解

### 用于日期/时间格式化的模式

| 模式  | 描述                                         |
| ----- | -------------------------------------------- |
| HH    | 一天的小时数(01-12)                          |
| HH12  | 一天的小时数(01-12)                          |
| HH24  | 一天的小时数(00-23)                          |
| MI    | 分钟(00-59)                                  |
| SS    | 秒(00-59)                                    |
| MS    | 毫秒(000-999)                                |
| US    | 微秒(000000-999999)                          |
| AM    | 正午标识(大写)                               |
| Y,YYY | 带逗号的年(4和更多位)                        |
| YYYY  | 年(4和更多位)                                |
| YYY   | 年的后三位                                   |
| YY    | 年的后两位                                   |
| Y     | 年的最后一位                                 |
| MONTH | 全长大写月份名(空白填充为9字符)              |
| Month | 全长混合大小写月份名(空白填充为9字符)        |
| month | 全长小写月份名(空白填充为9字符)              |
| MON   | 大写缩写月份名(3字符)                        |
| Mon   | 缩写混合大小写月份名(3字符)                  |
| mon   | 小写缩写月份名(3字符)                        |
| MM    | 月份号(01-12)                                |
| DAY   | 全长大写日期名(空白填充为9字符)              |
| Day   | 全长混合大小写日期名(空白填充为9字符)        |
| day   | 全长小写日期名(空白填充为9字符)              |
| DY    | 缩写大写日期名(3字符)                        |
| Dy    | 缩写混合大小写日期名(3字符)                  |
| dy    | 缩写小写日期名(3字符)                        |
| DDD   | 一年里的日子(001-366)                        |
| DD    | 一个月里的日子(01-31)                        |
| D     | 一周里的日子(1-7；周日是1)                   |
| W     | 一个月里的周数(1-5)(第一周从该月第一天开始)  |
| WW    | 一年里的周数(1-53)(第一周从该年的第一天开始) |

### 时间/日期操作符

| 操作符 | 例子                                                        | 结果                         |
| ------ | ----------------------------------------------------------- | ---------------------------- |
| +      | date '2001-09-28' + integer '7'                             | date '2001-10-05'            |
| +      | date '2001-09-28' + interval '1 hour'                       | timestamp '2001-09-28 01:00' |
| +      | date '2001-09-28' + time '03:00'                            | timestamp '2001-09-28 03:00' |
| +      | interval '1 day' + interval '1 hour'                        | interval '1 day 01:00'       |
| +      | timestamp '2001-09-28 01:00' + interval '23 hours'          | timestamp '2001-09-29 00:00' |
| +      | time '01:00' + interval '3 hours'                           | time '04:00'                 |
| -      | - interval '23 hours'                                       | interval '-23:00'            |
| -      | date '2001-10-01' - date '2001-09-28'                       | integer '3'                  |
| -      | date '2001-10-01' - integer '7'                             | date '2001-09-24'            |
| -      | date '2001-09-28' - interval '1 hour'                       | timestamp '2001-09-27 23:00' |
| -      | time '05:00' - time '03:00'                                 | interval '02:00'             |
| -      | time '05:00' - interval '2 hours'                           | time '03:00'                 |
| -      | timestamp '2001-09-28 23:00' - interval '23 hours'          | timestamp '2001-09-28 00:00' |
| -      | interval '1 day' - interval '1 hour'                        | interval '23:00'             |
| -      | timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00' | interval '1 day 15:00'       |
| *      | interval '1 hour' * double precision '3.5'                  | interval '03:30'             |
| /      | interval '1 hour' / double precision '1.5'                  | interval '00:40'             |

### 日期/时间函数

| 函数                          | 返回类型  | 描述                                         | 例子                                                | 结果                    |
| ----------------------------- | --------- | -------------------------------------------- | --------------------------------------------------- | ----------------------- |
| age(timestamp, timestamp)     | interval  | 减去参数，生成一个使用年、月的"符号化"的结果 | age('2001-04-10', timestamp '1957-06-13')           | 43 years 9 mons 27 days |
| age(timestamp)                | interval  | 从current_date减去得到的数值                 | age(timestamp '1957-06-13')                         | 43 years 8 mons 3 days  |
| current_date                  | date      | 今天的日期                                   |                                                     |                         |
| current_time                  | time      | 现在的时间                                   |                                                     |                         |
| current_timestamp             | timestamp | 日期和时间                                   |                                                     |                         |
| date_part(text, timestamp)    | double    | 获取子域(等效于extract)                      | date_part('hour', timestamp '2001-02-16 20:38:40')  | 20                      |
| date_part(text, interval)     | double    | 获取子域(等效于extract)                      | date_part('month', interval '2 years 3 months')     | 3                       |
| date_trunc(text, timestamp)   | timestamp | 截断成指定的精度                             | date_trunc('hour', timestamp '2001-02-16 20:38:40') | 2001-02-16 20:00:00+00  |
| extract(field from timestamp) | double    | 获取子域                                     | extract(hour from timestamp '2001-02-16 20:38:40')  | 20                      |
| extract(field from interval)  | double    | 获取子域                                     | extract(month from interval '2 years 3 months')     | 3                       |
| localtime                     | time      | 今日的时间                                   |                                                     |                         |
| localtimestamp                | timestamp | 日期和时间                                   |                                                     |                         |
| now()                         | timestamp | 当前的日期和时间(等效于 current_timestamp)   |                                                     |                         |
| timeofday()                   | text      | 当前日期和时间                               |                                                     |                         |

### EXTRACT，date_part函数支持的field

| 域           | 描述                                                         | 例子                                                      | 结果     |
| ------------ | ------------------------------------------------------------ | --------------------------------------------------------- | -------- |
| CENTURY      | 世纪                                                         | EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');    | 20       |
| DAY          | (月分)里的日期域(1-31)                                       | EXTRACT(DAY from TIMESTAMP '2001-02-16 20:38:40');        | 16       |
| DECADE       | 年份域除以10                                                 | EXTRACT(DECADE from TIMESTAMP '2001-02-16 20:38:40');     | 200      |
| DOW          | 每周的星期号(0-6；星期天是0) (仅用于timestamp)               | EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');        | 5        |
| DOY          | 一年的第几天(1 -365/366) (仅用于 timestamp)                  | EXTRACT(DOY from TIMESTAMP '2001-02-16 20:38:40');        | 47       |
| HOUR         | 小时域(0-23)                                                 | EXTRACT(HOUR from TIMESTAMP '2001-02-16 20:38:40');       | 20       |
| MICROSECONDS | 秒域，包括小数部分，乘以 1,000,000。                         | EXTRACT(MICROSECONDS from TIME '17:12:28.5');             | 28500000 |
| MILLENNIUM   | 千年                                                         | EXTRACT(MILLENNIUM from TIMESTAMP '2001-02-16 20:38:40'); | 3        |
| MILLISECONDS | 秒域，包括小数部分，乘以 1000。                              | EXTRACT(MILLISECONDS from TIME '17:12:28.5');             | 28500    |
| MINUTE       | 分钟域(0-59)                                                 | EXTRACT(MINUTE from TIMESTAMP '2001-02-16 20:38:40');     | 38       |
| MONTH        | 对于timestamp数值，它是一年里的月份数(1-12)；对于interval数值，它是月的数目，然后对12取模(0-11) | EXTRACT(MONTH from TIMESTAMP '2001-02-16 20:38:40');      | 2        |
| QUARTER      | 该天所在的该年的季度(1-4)(仅用于 timestamp)                  | EXTRACT(QUARTER from TIMESTAMP '2001-02-16 20:38:40');    | 1        |
| SECOND       | 秒域，包括小数部分(0-59[1])                                  | EXTRACT(SECOND from TIMESTAMP '2001-02-16 20:38:40');     | 40       |
| WEEK         | 该天在所在的年份里是第几周。                                 | EXTRACT(WEEK from TIMESTAMP '2001-02-16 20:38:40');       | 7        |
| YEAR         | 年份域                                                       | EXTRACT(YEAR from TIMESTAMP '2001-02-16 20:38:40');       | 2001     |

### 当前日期/时间

我们可以使用下面的函数获取当前的日期和/或时间∶
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME (precision)
CURRENT_TIMESTAMP (precision)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME (precision)
LOCALTIMESTAMP (precision)

~~~sql
postgres=# select CURRENT_DATE;
 current_date 
--------------
 2023-11-14
(1 row)

postgres=# select CURRENT_TIME;
    current_time    
--------------------
 22:11:24.265612+08
(1 row)

postgres=# select CURRENT_TIMESTAMP;
       current_timestamp       
-------------------------------
 2023-11-14 22:11:29.498686+08
(1 row)

postgres=# select CURRENT_TIME (1);
 current_time  
---------------
 22:11:34.4+08
(1 row)

postgres=# select CURRENT_TIMESTAMP (2);
     current_timestamp     
---------------------------
 2023-11-14 22:11:39.07+08
(1 row)

postgres=# select LOCALTIME;
    localtime    
-----------------
 22:11:43.842042
(1 row)

postgres=# select LOCALTIMESTAMP;
      localtimestamp       
---------------------------
 2023-11-14 22:11:48.77811
(1 row)

postgres=# select LOCALTIME (3);
  localtime   
--------------
 22:11:53.418
(1 row)

postgres=# select LOCALTIMESTAMP (4);
      localtimestamp      
--------------------------
 2023-11-14 22:12:13.2027
(1 row)

postgres=# 
~~~





## 窗口函数

https://blog.csdn.net/weixin_39870155/article/details/111291051

### update使用排名窗口函数

#### 案例1

我有一个名为medias的表,我最近在其中添加了一个名为sort_order的新列,类型为Int。
行值对整个表来说不是唯一的,而是对它们各自的owner_user_id字段来说是唯一的。无论如何,我什至不在乎它们的独特性。
所有这一切的重点是允许用户设置他们上传的照片的排序顺序(最多 10 个,他们可以拖动和重新排序等)。当用户“删除”一张照片时,我不会删除记录,我只是在该行上将一个visible字段设置为false。
Anyway,我正在引入一个添加sort_order的迁移(他们以前无法订购照片,它们只会根据order by created_at asc进行排序)。
自从添加了新字段后,我将新的sort_order设置为默认值10(以便它向后兼容尚未更新应用程序的人)。
我能够想出这个查询:

~~~sql
select
  owner_user_id, 
  sort_order, rank() over (PARTITION BY owner_user_id ORDER BY sort_order asc, created_at asc) as new_sort_order 
from medias 
where visible=true 
order by sort_order asc, created_at asc;

-- 查询结果如下
 owner_user_id | sort_order | new_sort_order
---------------+------------+---------------
            76 |         10 |      1
            76 |         10 |      2
            76 |         10 |      3
            76 |         10 |      4
            76 |         10 |      5
             9 |         10 |      1
             9 |         10 |      2
             9 |         10 |      3
             9 |         10 |      4
             9 |         10 |      5
            79 |         10 |      1
            79 |         10 |      2
            87 |         10 |      1
            87 |         10 |      2
            87 |         10 |      3
            85 |         10 |      1
            90 |         10 |      1
            90 |         10 |      2
            90 |         10 |      3

~~~

在这一点上,我真正想做的就是将sort_order设置为rank()。关于如何做到这一点的任何想法?

由于您没有唯一键,请使用`ctid`:

~~~sql
update medias m
    set sort_order = new_sort_order
    from (
        select 
            ctid,
            owner_user_id, 
            sort_order, 
            row_number() over w as new_sort_order 
        from medias 
        where visible
        window w as (partition by owner_user_id order by sort_order asc, created_at asc)
    ) s
    where m.ctid = s.ctid;

~~~

注意,row_number()可能比rank()更好,因为第一个从不重复。

#### 案例2

~~~sql
WITH v_table_name AS
(
    SELECT ROW_NUMBER() OVER (partition BY col2 ORDER BY col3) AS rn, primary_key
    FROM TABLE_NAME
)
UPDATE TABLE_NAME SET TABLE_NAME.col1 = v_table_name.rn
FROM v_table_name
WHERE TABLE_NAME.primary_key = v_table_name.primary_key;

-- 或者

UPDATE TABLE_NAME SET TABLE_NAME.col1 = v_table_name.rn
FROM  
(
    SELECT ROW_NUMBER() OVER (partition BY col2 ORDER BY col3) AS rn, primary_key
    FROM TABLE_NAME
) AS v_table_name
WHERE TABLE_NAME.primary_key = v_table_name.primary_key;
~~~



## 数组操作

~~~sql
-- 数组去重
select array(select distinct unnest(array[1,1,1,2,2,3,3,4]));
select array(select distinct unnest(array['zhangsan','lisi','wangwu','zhangsan','lisi','zhangsan']));


-- 字段逗号拼接的字符串去重
-- 数组转字符串
array_to_string(
-- 组成数组
    array(
    -- 数组转行，去重
        select distinct unnest(
        -- 字符串转数组
            string_to_array(t.字段名,',')
        )
    )
,',')

-- 查询数据中是否包含某个值（注意要先写字符串，再写any，否则报错）
select 'zhangsan' = any(array['zhangsan','lisi','wangwu']);
~~~

## JSON类型处理

要更新PostgreSQL中JSON数据类型中的某个键对应的值，可以使用 jsonb_set函数，该函数的语法如下：

~~~sql
jsonb_set(target jsonb, path text[], new_value jsonb[,create_missing boolean]) 
~~~

其中target是要更新的jsonb数据类型，path是要更新的键的路径，new_value是要更新的新的值，create_missing是一个可选参数，如果设置为true，则会在路径中创建缺失的键

例如，假设有以下json数据类型

~~~shell
{
  "name":"John",
  "age":30,
  "address":{
    "city":"New York",
    "state":"NY"
  }
}
~~~

要将address的city更新为 'Los Angeles'，可以使用以下SQL语句

~~~sql
update my_table set my_jsonb_column = jsonb_set(my_jsonb_column,'{address,city}','"Los Angeles"') where id = 1;
~~~



~~~sql
create table test_t (id serial,student jsonb);
insert into test_t values(1,'{"name":"zhangsan","sex":"male"}'),(2,'{"name":"lisi","sex":"female"}');

-- 更新某个键对应的值
update test_t set student=jsonb_set(student,'{name}','"wangwu"') where id =1;


create table test_t (id serial,student json);
insert into test_t values(1,'{"name":"zhangsan","sex":"male"}'),(2,'{"name":"lisi","sex":"female"}');

-- 更新某个键对应的值
update test_t set student=jsonb_set(student::jsonb,'{name}','"wangwu"')::json where id =1;
~~~



## CTE

### 多条update语句并接执行

建表

~~~sql
-- t_student表记录学生每一次考试情况，要求保留历史记录，last_exam =0标识为最新的考试情况
DROP TABLE if exists t_student;
CREATE TABLE t_student(
	id serial8,
	name VARCHAR(20) NOT NULL DEFAULT '',
	class VARCHAR(20) NOT NULL DEFAULT '',
	course VARCHAR[] NOT NULL DEFAULT '{语文,数学,英语,物理,化学,历史,生物,地理,综合}',
	subjects integer[] NOT NULL DEFAULT '{}',
	gross_score int4 NOT NULL DEFAULT 0,
	last_exam int2 NOT NULL DEFAULT 0,
	add_id BIGINT NOT NULL DEFAULT 0,
	add_time TIMESTAMP NOT NULL DEFAULT now(),
	modify_id BIGINT,
	modify_time TIMESTAMP,
	PRIMARY KEY(id)
);
COMMENT ON COLUMN t_student.name IS '用户名';
COMMENT ON COLUMN t_student.class IS '年级';
COMMENT ON COLUMN t_student.course IS '各科目';
COMMENT ON COLUMN t_student.subjects IS '各科目分数';
COMMENT ON COLUMN t_student.gross_score IS '总分数';
COMMENT ON COLUMN t_student.last_exam IS '最新考试标识，0-是，1-不是';
COMMENT ON COLUMN t_student.add_id IS '增加记录人';
COMMENT ON COLUMN t_student.add_time IS '增加日期';
COMMENT ON COLUMN t_student.modify_id IS '修改记录人';
COMMENT ON COLUMN t_student.modify_time IS '修改日期';


-- t_subjects表记录每一次考试的详情，试题库地址，审题人批示等信息。
DROP TABLE if exists t_subjects;
CREATE TABLE t_subjects(
	id serial8,
	student_id BIGINT NOT NULL DEFAULT 0,
	subject VARCHAR(20) NOT NULL DEFAULT '',
	score INTEGER NULL,
	address VARCHAR(1000) NOT NULL DEFAULT 'https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=m',
	remark VARCHAR(300) DEFAULT '继续加油哦',
	add_id BIGINT NOT NULL DEFAULT 0,
	add_time TIMESTAMP NOT NULL DEFAULT now(),
	modify_id BIGINT,
	modify_time TIMESTAMP,
	PRIMARY KEY(id)
);
COMMENT ON COLUMN t_subjects.student_id IS '学生表id';
COMMENT ON COLUMN t_subjects.subject IS '科目';
COMMENT ON COLUMN t_subjects.score IS '科目分数';
COMMENT ON COLUMN t_subjects.address IS '试题链接';
COMMENT ON COLUMN t_subjects.remark IS '老师评语';
COMMENT ON COLUMN t_subjects.add_id IS '增加记录人';
COMMENT ON COLUMN t_subjects.add_time IS '增加日期';
COMMENT ON COLUMN t_subjects.modify_id IS '修改记录人';
COMMENT ON COLUMN t_subjects.modify_time IS '修改日期';
~~~



插入记录二条，可联级插入二张表数据

~~~sql
WITH student_id AS (
	INSERT INTO t_student ( NAME, CLASS, course, subjects, gross_score )
	VALUES
		( '张三', '一年级', '{语文,数学,英语,物理,化学,历史,生物,地理,综合}', '{87,93,81,79,86,78,92,81,84}', 761 ) RETURNING ID 
	) INSERT INTO t_subjects ( student_id, subject, score, address )
VALUES
	( ( SELECT ID FROM student_id ), '语文', 87, 'https://www.baidu.com/1' ),
	( ( SELECT ID FROM student_id ), '数学', 93, 'https://www.baidu.com/2' ),
	( ( SELECT ID FROM student_id ), '英语', 81, 'https://www.baidu.com/3' ),
	( ( SELECT ID FROM student_id ), '物理', 79, 'https://www.baidu.com/4' ),
	( ( SELECT ID FROM student_id ), '化学', 86, 'https://www.baidu.com/5' ),
	( ( SELECT ID FROM student_id ), '历史', 78, 'https://www.baidu.com/6' ),
	( ( SELECT ID FROM student_id ), '生物', 92, 'https://www.baidu.com/7' ),
	( ( SELECT ID FROM student_id ), '地理', 81, 'https://www.baidu.com/8' ),
	( ( SELECT ID FROM student_id ), '综合', 84, 'https://www.baidu.com/9' );


postgres=# select * from t_subjects;
 id | student_id | subject | score |         address         |   remark   | add_id |         add_time          | modify_id | modify_time 
----+------------+---------+-------+-------------------------+------------+--------+---------------------------+-----------+-------------
  1 |          1 | 语文    |    87 | https://www.baidu.com/1 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  2 |          1 | 数学    |    93 | https://www.baidu.com/2 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  3 |          1 | 英语    |    81 | https://www.baidu.com/3 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  4 |          1 | 物理    |    79 | https://www.baidu.com/4 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  5 |          1 | 化学    |    86 | https://www.baidu.com/5 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  6 |          1 | 历史    |    78 | https://www.baidu.com/6 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  7 |          1 | 生物    |    92 | https://www.baidu.com/7 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  8 |          1 | 地理    |    81 | https://www.baidu.com/8 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  9 |          1 | 综合    |    84 | https://www.baidu.com/9 | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
(9 rows)

postgres=# select * from t_student;
-[ RECORD 1 ]-----------------------------------------------
id          | 1
name        | 张三
class       | 一年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {87,93,81,79,86,78,92,81,84}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:50:55.38127
modify_id   | 
modify_time | 
~~~



继续插入数据

~~~sql
WITH student_id AS (
	INSERT INTO t_student ( NAME, CLASS, course, subjects, gross_score )
	VALUES
		(
			'李四',
			'四年级',
			ARRAY [ '语文',
			'数学',
			'英语',
			'物理',
			'化学',
			'历史',
			'生物',
			'地理',
			'综合' ]:: VARCHAR [],
			ARRAY [ 89,
			91,
			85,
			79,
			79,
			78,
			90,
			83,
			87 ]:: INTEGER [],
			761 
		) RETURNING * 
	) INSERT INTO t_subjects ( student_id, subject, score, address )
VALUES
	( ( SELECT ID FROM student_id ), '语文', 89, 'https://www.baidu.com/11' ),
	( ( SELECT ID FROM student_id ), '数学', 91, 'https://www.baidu.com/12' ),
	( ( SELECT ID FROM student_id ), '英语', 85, 'https://www.baidu.com/13' ),
	( ( SELECT ID FROM student_id ), '物理', 79, 'https://www.baidu.com/14' ),
	( ( SELECT ID FROM student_id ), '化学', 79, 'https://www.baidu.com/15' ),
	( ( SELECT ID FROM student_id ), '历史', 90, 'https://www.baidu.com/16' ),
	( ( SELECT ID FROM student_id ), '生物', 90, 'https://www.baidu.com/17' ),
	( ( SELECT ID FROM student_id ), '地理', 83, 'https://www.baidu.com/18' ),
	( ( SELECT ID FROM student_id ), '综合', 87, 'https://www.baidu.com/19' );



postgres=# select * from t_subjects;
 id | student_id | subject | score |         address          |   remark   | add_id |         add_time          | modify_id | modify_time 
----+------------+---------+-------+--------------------------+------------+--------+---------------------------+-----------+-------------
  1 |          1 | 语文    |    87 | https://www.baidu.com/1  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  2 |          1 | 数学    |    93 | https://www.baidu.com/2  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  3 |          1 | 英语    |    81 | https://www.baidu.com/3  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  4 |          1 | 物理    |    79 | https://www.baidu.com/4  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  5 |          1 | 化学    |    86 | https://www.baidu.com/5  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  6 |          1 | 历史    |    78 | https://www.baidu.com/6  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  7 |          1 | 生物    |    92 | https://www.baidu.com/7  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  8 |          1 | 地理    |    81 | https://www.baidu.com/8  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
  9 |          1 | 综合    |    84 | https://www.baidu.com/9  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127 |           | 
 10 |          2 | 语文    |    89 | https://www.baidu.com/11 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 11 |          2 | 数学    |    91 | https://www.baidu.com/12 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 12 |          2 | 英语    |    85 | https://www.baidu.com/13 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 13 |          2 | 物理    |    79 | https://www.baidu.com/14 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 14 |          2 | 化学    |    79 | https://www.baidu.com/15 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 15 |          2 | 历史    |    90 | https://www.baidu.com/16 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 16 |          2 | 生物    |    90 | https://www.baidu.com/17 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 17 |          2 | 地理    |    83 | https://www.baidu.com/18 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
 18 |          2 | 综合    |    87 | https://www.baidu.com/19 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008 |           | 
(18 rows)


postgres=# select * from t_student;
-[ RECORD 1 ]-----------------------------------------------
id          | 1
name        | 张三
class       | 一年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {87,93,81,79,86,78,92,81,84}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:50:55.38127
modify_id   | 
modify_time | 
-[ RECORD 2 ]-----------------------------------------------
id          | 2
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:55:33.05008
modify_id   | 
modify_time | 

postgres=# 
~~~



老师对学生李四的考试作了修改，有了最新的考试成绩，需要新增t_student记录，详情用原来的，也可更新个别字段 ，

正常业务需要===>更新t_student表===>插入t_student表记录===>新增t_subjects，

需要执行三条sql语句，用with 函数可以用一条sql执行

~~~sql
WITH old_exam AS (
	UPDATE t_student 
	SET last_exam = 1,
	modify_id = FLOOR ( random( ) * 80000+20 ),
	modify_time = now( ) 
	WHERE
		ID = 1 RETURNING ID 
	),
	new_exam AS (
		INSERT INTO t_student ( NAME, CLASS, course, subjects, gross_score )
	VALUES
		(
			'李四',
			'四年级',
			ARRAY [ '语文', '数学', '英语', '物理', '化学', '历史', '生物', '地理', '综合' ],
			ARRAY [ 89, 91, 85, 79, 79, 78, 90, 83, 87 ]:: INTEGER [],
			761 
		) RETURNING ID 
	) INSERT INTO t_subjects ( student_id, subject, score, address, add_id ) SELECT
	( SELECT ID FROM new_exam ),
	subject,
	score,
	address,
	FLOOR ( random( ) * 80000+20 ) 
FROM
	t_subjects 
WHERE
	student_id = ( SELECT ID FROM old_exam );


-- 结果
postgres=# select * from t_subjects;
 id | student_id | subject | score |         address          |   remark   | add_id |          add_time          | modify_id | modify_time 
----+------------+---------+-------+--------------------------+------------+--------+----------------------------+-----------+-------------
  1 |          1 | 语文    |    87 | https://www.baidu.com/1  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  2 |          1 | 数学    |    93 | https://www.baidu.com/2  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  3 |          1 | 英语    |    81 | https://www.baidu.com/3  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  4 |          1 | 物理    |    79 | https://www.baidu.com/4  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  5 |          1 | 化学    |    86 | https://www.baidu.com/5  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  6 |          1 | 历史    |    78 | https://www.baidu.com/6  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  7 |          1 | 生物    |    92 | https://www.baidu.com/7  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  8 |          1 | 地理    |    81 | https://www.baidu.com/8  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  9 |          1 | 综合    |    84 | https://www.baidu.com/9  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
 10 |          2 | 语文    |    89 | https://www.baidu.com/11 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 11 |          2 | 数学    |    91 | https://www.baidu.com/12 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 12 |          2 | 英语    |    85 | https://www.baidu.com/13 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 13 |          2 | 物理    |    79 | https://www.baidu.com/14 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 14 |          2 | 化学    |    79 | https://www.baidu.com/15 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 15 |          2 | 历史    |    90 | https://www.baidu.com/16 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 16 |          2 | 生物    |    90 | https://www.baidu.com/17 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 17 |          2 | 地理    |    83 | https://www.baidu.com/18 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 18 |          2 | 综合    |    87 | https://www.baidu.com/19 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 19 |          3 | 语文    |    87 | https://www.baidu.com/1  | 继续加油哦 |  37599 | 2023-12-27 20:59:05.924116 |           | 
 20 |          3 | 数学    |    93 | https://www.baidu.com/2  | 继续加油哦 |  58432 | 2023-12-27 20:59:05.924116 |           | 
 21 |          3 | 英语    |    81 | https://www.baidu.com/3  | 继续加油哦 |  37939 | 2023-12-27 20:59:05.924116 |           | 
 22 |          3 | 物理    |    79 | https://www.baidu.com/4  | 继续加油哦 |  53015 | 2023-12-27 20:59:05.924116 |           | 
 23 |          3 | 化学    |    86 | https://www.baidu.com/5  | 继续加油哦 |  17065 | 2023-12-27 20:59:05.924116 |           | 
 24 |          3 | 历史    |    78 | https://www.baidu.com/6  | 继续加油哦 |  34399 | 2023-12-27 20:59:05.924116 |           | 
 25 |          3 | 生物    |    92 | https://www.baidu.com/7  | 继续加油哦 |  50566 | 2023-12-27 20:59:05.924116 |           | 
 26 |          3 | 地理    |    81 | https://www.baidu.com/8  | 继续加油哦 |  77329 | 2023-12-27 20:59:05.924116 |           | 
 27 |          3 | 综合    |    84 | https://www.baidu.com/9  | 继续加油哦 |  41049 | 2023-12-27 20:59:05.924116 |           | 
(27 rows)



postgres=# select * from t_student;
-[ RECORD 1 ]-----------------------------------------------
id          | 2
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:55:33.05008
modify_id   | 
modify_time | 
-[ RECORD 2 ]-----------------------------------------------
id          | 1
name        | 张三
class       | 一年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {87,93,81,79,86,78,92,81,84}
gross_score | 761
last_exam   | 1
add_id      | 0
add_time    | 2023-12-27 20:50:55.38127
modify_id   | 3985
modify_time | 2023-12-27 20:59:05.924116
-[ RECORD 3 ]-----------------------------------------------
id          | 3
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:59:05.924116
modify_id   | 
modify_time | 
~~~



李四有了最新的考试成绩，需要新增t_student记录，新增t_subjects记录 ，

正常业务需要===>更新t_student表===>插入t_student表记录===>新增t_subjects，

需要执行三条sql语句，用with 函数可以用一条sql执行

~~~sql
WITH old_exam AS (
	UPDATE t_student 
	SET last_exam = 1,
	modify_id = FLOOR ( random( ) * 80000+20 ),
	modify_time = now( ) 
	WHERE
		ID = 3 
	),
	new_exam AS (
		INSERT INTO t_student ( NAME, CLASS, course, subjects, gross_score )
	VALUES
		(
			'李四',
			'四年级',
			ARRAY [ '语文', '数学', '英语', '物理', '化学', '历史', '生物', '地理', '综合' ],
			ARRAY [ 91, 88, 87, 79, 76, 81, 88, 86, 85 ]:: INTEGER [],
			761 
		) RETURNING ID 
	) INSERT INTO t_subjects ( student_id, subject, score, address )
VALUES
	( ( SELECT ID FROM new_exam ), '语文', 91, 'https://www.baidu.com/21' ),
	( ( SELECT ID FROM new_exam ), '数学', 88, 'https://www.baidu.com/2' ),
	( ( SELECT ID FROM new_exam ), '英语', 87, 'https://www.baidu.com/23' ),
	( ( SELECT ID FROM new_exam ), '物理', 79, 'https://www.baidu.com/24' ),
	( ( SELECT ID FROM new_exam ), '化学', 76, 'https://www.baidu.com/25' ),
	( ( SELECT ID FROM new_exam ), '历史', 81, 'https://www.baidu.com/26' ),
	( ( SELECT ID FROM new_exam ), '生物', 88, 'https://www.baidu.com/27' ),
	( ( SELECT ID FROM new_exam ), '地理', 86, 'https://www.baidu.com/28' ),
	( ( SELECT ID FROM new_exam ), '综合', 86, 'https://www.baidu.com/29' );


-- 结果
postgres=# select * from t_subjects;
 id | student_id | subject | score |         address          |   remark   | add_id |          add_time          | modify_id | modify_time 
----+------------+---------+-------+--------------------------+------------+--------+----------------------------+-----------+-------------
  1 |          1 | 语文    |    87 | https://www.baidu.com/1  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  2 |          1 | 数学    |    93 | https://www.baidu.com/2  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  3 |          1 | 英语    |    81 | https://www.baidu.com/3  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  4 |          1 | 物理    |    79 | https://www.baidu.com/4  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  5 |          1 | 化学    |    86 | https://www.baidu.com/5  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  6 |          1 | 历史    |    78 | https://www.baidu.com/6  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  7 |          1 | 生物    |    92 | https://www.baidu.com/7  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  8 |          1 | 地理    |    81 | https://www.baidu.com/8  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
  9 |          1 | 综合    |    84 | https://www.baidu.com/9  | 继续加油哦 |      0 | 2023-12-27 20:50:55.38127  |           | 
 10 |          2 | 语文    |    89 | https://www.baidu.com/11 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 11 |          2 | 数学    |    91 | https://www.baidu.com/12 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 12 |          2 | 英语    |    85 | https://www.baidu.com/13 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 13 |          2 | 物理    |    79 | https://www.baidu.com/14 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 14 |          2 | 化学    |    79 | https://www.baidu.com/15 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 15 |          2 | 历史    |    90 | https://www.baidu.com/16 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 16 |          2 | 生物    |    90 | https://www.baidu.com/17 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 17 |          2 | 地理    |    83 | https://www.baidu.com/18 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 18 |          2 | 综合    |    87 | https://www.baidu.com/19 | 继续加油哦 |      0 | 2023-12-27 20:55:33.05008  |           | 
 19 |          3 | 语文    |    87 | https://www.baidu.com/1  | 继续加油哦 |  37599 | 2023-12-27 20:59:05.924116 |           | 
 20 |          3 | 数学    |    93 | https://www.baidu.com/2  | 继续加油哦 |  58432 | 2023-12-27 20:59:05.924116 |           | 
 21 |          3 | 英语    |    81 | https://www.baidu.com/3  | 继续加油哦 |  37939 | 2023-12-27 20:59:05.924116 |           | 
 22 |          3 | 物理    |    79 | https://www.baidu.com/4  | 继续加油哦 |  53015 | 2023-12-27 20:59:05.924116 |           | 
 23 |          3 | 化学    |    86 | https://www.baidu.com/5  | 继续加油哦 |  17065 | 2023-12-27 20:59:05.924116 |           | 
 24 |          3 | 历史    |    78 | https://www.baidu.com/6  | 继续加油哦 |  34399 | 2023-12-27 20:59:05.924116 |           | 
 25 |          3 | 生物    |    92 | https://www.baidu.com/7  | 继续加油哦 |  50566 | 2023-12-27 20:59:05.924116 |           | 
 26 |          3 | 地理    |    81 | https://www.baidu.com/8  | 继续加油哦 |  77329 | 2023-12-27 20:59:05.924116 |           | 
 27 |          3 | 综合    |    84 | https://www.baidu.com/9  | 继续加油哦 |  41049 | 2023-12-27 20:59:05.924116 |           | 
 28 |          4 | 语文    |    91 | https://www.baidu.com/21 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 29 |          4 | 数学    |    88 | https://www.baidu.com/2  | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 30 |          4 | 英语    |    87 | https://www.baidu.com/23 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 31 |          4 | 物理    |    79 | https://www.baidu.com/24 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 32 |          4 | 化学    |    76 | https://www.baidu.com/25 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 33 |          4 | 历史    |    81 | https://www.baidu.com/26 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 34 |          4 | 生物    |    88 | https://www.baidu.com/27 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 35 |          4 | 地理    |    86 | https://www.baidu.com/28 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
 36 |          4 | 综合    |    86 | https://www.baidu.com/29 | 继续加油哦 |      0 | 2023-12-27 21:01:26.373209 |           | 
(36 rows)


postgres=# select * from t_student;
-[ RECORD 1 ]-----------------------------------------------
id          | 2
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:55:33.05008
modify_id   | 
modify_time | 
-[ RECORD 2 ]-----------------------------------------------
id          | 1
name        | 张三
class       | 一年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {87,93,81,79,86,78,92,81,84}
gross_score | 761
last_exam   | 1
add_id      | 0
add_time    | 2023-12-27 20:50:55.38127
modify_id   | 3985
modify_time | 2023-12-27 20:59:05.924116
-[ RECORD 3 ]-----------------------------------------------
id          | 4
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {91,88,87,79,76,81,88,86,85}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 21:01:26.373209
modify_id   | 
modify_time | 
-[ RECORD 4 ]-----------------------------------------------
id          | 3
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 1
add_id      | 0
add_time    | 2023-12-27 20:59:05.924116
modify_id   | 32806
modify_time | 2023-12-27 21:01:26.373209

postgres=# 
~~~



如果需要更新一张表的多条记录，比如t_subjects，

id=1的score改为88
id=3的score改为86
id=4的score改为80
id=6的score改为81

~~~sql
UPDATE t_subjects AS s 
SET score = TEMP.score 
FROM
	( VALUES ( 1, 88 ), ( 3, 86 ), ( 4, 80 ), ( 6, 81 ) ) AS TEMP ( ID, score ) 
WHERE
	s.ID = TEMP.ID;
~~~



数组的操作，有array-cat(array,array)数组与数组拼接运算,但并没有 数组与数组云除运算，可用以下语句执行。

~~~sql
UPDATE t_student 
SET subjects = (
	SELECT
		"array_agg" ( TEMP ) 
	FROM
		"unnest" ( ( SELECT subjects FROM t_student WHERE ID = 2 ) :: INTEGER [] ) AS TEMP 
	WHERE
		TEMP NOT IN ( 89, 5, 83 ) 
	) 
WHERE
	"id" = 2;


-- 结果
postgres=# select * from t_student;
-[ RECORD 1 ]-----------------------------------------------
id          | 1
name        | 张三
class       | 一年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {87,93,81,79,86,78,92,81,84}
gross_score | 761
last_exam   | 1
add_id      | 0
add_time    | 2023-12-27 20:50:55.38127
modify_id   | 3985
modify_time | 2023-12-27 20:59:05.924116
-[ RECORD 2 ]-----------------------------------------------
id          | 4
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {91,88,87,79,76,81,88,86,85}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 21:01:26.373209
modify_id   | 
modify_time | 
-[ RECORD 3 ]-----------------------------------------------
id          | 3
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {89,91,85,79,79,78,90,83,87}
gross_score | 761
last_exam   | 1
add_id      | 0
add_time    | 2023-12-27 20:59:05.924116
modify_id   | 32806
modify_time | 2023-12-27 21:01:26.373209
-[ RECORD 4 ]-----------------------------------------------
id          | 2
name        | 李四
class       | 四年级
course      | {语文,数学,英语,物理,化学,历史,生物,地理,综合}
subjects    | {91,85,79,79,78,90,87}
gross_score | 761
last_exam   | 0
add_id      | 0
add_time    | 2023-12-27 20:55:33.05008
modify_id   | 
modify_time | 

postgres=# 
~~~





## 查询表中某个字段的值为xxx的列名

```sql
drop table if exists test_t;
create table test_t(id int,col1 text,col2 text,col3 text,col4 text,col5 text);
insert into test_t values
(0,'test','test','test','test','test'),
(1,'H80','test','test','test','test'),
(2,'H80','test','test','test','test'),
(3,'test','H80','H80','test','test'),
(4,'test','H80','test','test','test');

with tmp as (
select json_each_text(row_to_json(test_t))::text as info from test_t)
select distinct info from tmp
where tmp.info ~ ',H80\)$';

    info
------------
 (col1,H80)
 (col2,H80)
 (col3,H80)
(3 rows)


select split_part(translate(info,'()',''),',',1) as columns from (
with tmp as (
select json_each_text(row_to_json(test_t))::text as info from test_t)
select distinct info from tmp
where tmp.info ~ ',H80\)$') t;

 columns
---------
 col1
 col2
 col3
(3 rows)
```





## 构造结果集

**方法1：union all**

```sql
with tmp as (
select 'zhangsan' as name union all
select 'lisi' as name union all
select 'wangwu' as name union all
select 'zhaoliu' as name)
select tmp.name from tmp;
```

**方法2：values表达式**

```sql
with tmp as (
SELECT * FROM (VALUES
 ('zhangsan')
,('lisi')
,('wangwu')
,('zhaoliu')
) AS t(name))
select tmp.name from tmp;
```

**方法3：数组**

```sql
with tmp as (
select unnest(ARRAY['zhangsan','lisi','wangwu','zhaoliu']) as name)
select tmp.name from tmp;
```

