#!/bin/bash
#==============================================================#
# File       :  OracleShellInstall
# Ctime      :  2022-06-18 12:32:09
# Mtime      :  2024-04-26 12:38:18
# Desc       :  Oracle Database Install for single/standlone/rac
# Path       :  /soft/OracleShellInstall
# Version    :  4.0.0
# Author     :  Lucifer(pc1107750981@163.com)
# Copyright (C) 2022-2099 Pengcheng Liu
#==============================================================#

#==============================================================#
#                         全局变量定义                           #
#==============================================================#
# 获取安装软件以及脚本目录（当前目录）
software_dir=$(dirname "$(readlink -f "$0")")
# 删除脚本生成的LOG日志文件
[[ $(find "$software_dir" -name "print_ora_install_*.log" 2>/dev/null) ]] && rm -rf "$software_dir"/print_ora_install_*.log
[[ $(find "$software_dir" -name "shell_install_output_*.log" 2>/dev/null) ]] && rm -rf "$software_dir"/shell_install_output_*.log
# 当前执行脚本系统时间
current=$(date +%Y%m%d%H%M%S)
# 定义操作系统标识
os_flag=OS1
# 操作系统类型
os_type=rhel
# 操作系统默认版本
os_version=7
# 脚本安装日志文件
oracleinstalllog=$software_dir/print_ora_install_$current.log
# 脚本输出日志文件
oracleprintlog=$software_dir/shell_install_output_$current.log
# 物理内存（KB）
os_memory_total=$(awk '/MemTotal/{print $2}' /proc/meminfo)
# 主机名称，默认值为 orcl
hostname=orcl
# 数据库名称，默认值为 orcl，支持多个实例，传参以逗号隔开：orcl,oradb
db_name=orcl
# 是否 CDB 架构
declare -l iscdb=false
# PDB 名称，如果 PDB 名称有值，则默认为 CDB 架构，默认值为 pdb01，如果传入多个 PDB 名称，则创建多个 PDB，传参以逗号隔开：pdb01,pdb02,pdb03
pdbname=pdb01
# 系统用户 oracle 密码，默认值为 oracle
oracle_passwd=oracle
# 数据库用户 sys/system 密码, 默认值为 oracle
database_passwd=oracle
# 数据库软件安装根目录，默认值为 /u01
env_base_dir=/u01
# 单机数据库参数，数据文件目录，默认值为 /oradata
oradata_dir=/oradata
# 数据库备份目录，默认值为 /backup
backup_dir=/backup
# 数据库脚本目录，默认值为 /home/oracle/scripts
scripts_dir=/home/oracle/scripts
# 数据库字符集，默认值为 AL32UTF8
declare -u db_characterset=AL32UTF8
# 数据库国家字符集，默认值为 AL16UTF16
declare -u nation_characterset=AL16UTF16
# 数据库在线重做日志大小，默认值为 1024，单位 MB
redosize=1024
# 数据库是否开启归档模式
declare -l enable_arch=true
# 仅配置操作系统，默认值为 N，包括配置操作系统以及解压软件安装包
declare -u only_conf_os=N
# 安装到 Grid 软件结束，默认值为 N
declare -u install_until_grid=N
# 安装到 Oracle 软件结束，默认值为 N
declare -u install_until_db=N
# 是否优化数据库参数，默认值为 N
declare -u optimize_db=N
# 数据库安装架构，分为单机和RAC
declare -l oracle_install_mode
# 是否安装图形化界面，默认值为 N
declare -u isgui=N
# 是否挂载 ISO 镜像，默认值为 Y，如果不需要脚本配置 YUM 源，则无需挂载 ISO
declare -u iso=Y
#==============================================================#
#                      RAC 模式全局变量定义                       #
#==============================================================#
# RAC 节点号，默认为 1
node_num=1
# 定义一个存放所有IP的数组
declare -a allips
# 定义一个存放公网IP的数组
declare -a rac_public_ips
# 定义一个存放主机名的数组
declare -a rac_hostnames
# 定义一个存放virtual ip的数组
declare -a rac_virtual_ips
# 定义一个存放心跳网卡名称的数组
declare -a rac_priv_ifnames
# 定义一个存放 scan ip 的数组
declare -a rac_scan_ips
# 定义一个用于保存 root 用户需要设置 SSH 信任的 IP 地址
declare -a ssh_ips
# 定义用于保存心跳IP的关联数组
declare -A rac_priv_ips
# 定义数组 rac_priv_ifnames_sorted 用于存放排序后的 rac_priv_ifnames 数组
declare -a rac_priv_ifnames_sorted
# 用于存放grid静默文件 networkinterfacelist 数组
declare -a networkinterfacelist_array
# 存放SSH互信IP数组
declare -a hosts_array
# 系统用户 grid 密码，默认值为 oracle
grid_passwd=oracle
# 是否配置 DNS 解析，默认值为 N
declare -u dns=N
# 是否配置 multipath 多路径，默认值为 Y
declare -u multipath=Y
# asm diskstring，默认值为 /dev/asm*
asmdisk_string="/dev/asm*"
# 是否配置 ASM 磁盘 UDEV 绑盘，默认值为 Y
declare -u asm_disk_conf=Y
# ASM 磁盘组名称，默认为 DATA,OCR,ARCH
declare -u ocr_asm_group=OCR
declare -u data_asm_group=DATA
declare -u arch_asm_group=ARCH
# ASM 磁盘组冗余度，默认值为 EXTERNAL，可选值为 [EXTERNAL|NORMAL|HIGH]
declare -u ocr_redun=EXTERNAL
declare -u data_redun=EXTERNAL
declare -u arch_redun=EXTERNAL
# 是否配置 AFD，默认值为 false
declare -l afd=false
# 修复 VBOX BUG，如果使用 VBOX 划盘安装 RAC，则需要设置为 Y，默认值为 N
declare -u virtualbox=N
#==============================================================#
#                          Logo 打印                            #
#==============================================================#
function logo_print() {
  cat <<-EOF

   ███████                             ██          ████████ ██               ██  ██ ██                    ██              ██  ██
  ██░░░░░██                           ░██         ██░░░░░░ ░██              ░██ ░██░██                   ░██             ░██ ░██
 ██     ░░██ ██████  ██████    █████  ░██  █████ ░██       ░██       █████  ░██ ░██░██ ███████   ██████ ██████  ██████   ░██ ░██
░██      ░██░░██░░█ ░░░░░░██  ██░░░██ ░██ ██░░░██░█████████░██████  ██░░░██ ░██ ░██░██░░██░░░██ ██░░░░ ░░░██░  ░░░░░░██  ░██ ░██
░██      ░██ ░██ ░   ███████ ░██  ░░  ░██░███████░░░░░░░░██░██░░░██░███████ ░██ ░██░██ ░██  ░██░░█████   ░██    ███████  ░██ ░██
░░██     ██  ░██    ██░░░░██ ░██   ██ ░██░██░░░░        ░██░██  ░██░██░░░░  ░██ ░██░██ ░██  ░██ ░░░░░██  ░██   ██░░░░██  ░██ ░██
 ░░███████  ░███   ░░████████░░█████  ███░░██████ ████████ ░██  ░██░░██████ ███ ███░██ ███  ░██ ██████   ░░██ ░░████████ ███ ███
  ░░░░░░░   ░░░     ░░░░░░░░  ░░░░░  ░░░  ░░░░░░ ░░░░░░░░  ░░   ░░  ░░░░░░ ░░░ ░░░ ░░ ░░░   ░░ ░░░░░░     ░░   ░░░░░░░░ ░░░ ░░░ 

EOF
}
#==============================================================#
#                          大写函数                             #
#==============================================================#
function upper() {
  echo "${1^^}"
}
#==============================================================#
#                           小写函数                            #
#==============================================================#
function lower() {
  echo "${1,,}"
}
#==============================================================#
#                           颜色打印                            #
#==============================================================#
function color_printf() {
  # green 是标题色，blue 是提示色，red 是错误色
  declare -A color_map=(
    ["red"]='\E[1;31m'
    ["green"]='\E[1;32m'
    ["blue"]='\E[1;34m'
    ["yellow"]='\E[1;33m'
    ["light_blue"]='\E[1;94m'
  )
  local res='\E[0m'
  local default_color='\E[1;32m'
  local color=${color_map[$1]:-"$default_color"}
  case "$1" in
  "red")
    printf "\n${color}%-20s %-30s %-50s\n${res}\n" "$2" "$3" "$4"
    exit 1
    ;;
  "green" | "light_blue")
    printf "${color}%-20s %-30s %-50s\n${res}" "$2" "$3" "$4"
    ;;
  *)
    printf "${color}%-20s %-30s %-50s\n${res}\n" "$2" "$3" "$4"
    ;;
  esac
}
#==============================================================#
#                          日志打印                             #
#==============================================================#
function log_print() {
  echo
  color_printf green "#==============================================================#"
  color_printf green "$1"
  color_printf green "#==============================================================#"
  echo
}
#==============================================================#
#                         执行命令并打印                         #
#==============================================================#
function print_and_run_command() {
  local command_to_run="$1"
  # 打印命令
  color_printf light_blue "执行命令: $command_to_run"
  # 执行命令
  eval "$command_to_run"
}
#==============================================================#
#                      执行命令并输出日志文件                      #
#==============================================================#
function execute_and_log() {
  # 提示信息
  local prompt="$1"
  # 要执行的命令
  local cmd="$2"
  # 日志文件路径
  local log_file="$oracleinstalllog"
  # 存储命令的进程ID
  local pid
  # 记录命令开始执行的时间
  local start_time
  # 记录命令执行完成的时间
  local end_time
  local execution_time
  # 输出提示信息
  echo -e "\e[1;34m${prompt}\e[0m\c"
  # 输出六个点
  printf "......"
  start_time=$(date +%s)
  # 在后台运行命令并记录其进程ID
  eval "$cmd" >>"$log_file" 2>&1 &
  pid=$!
  # 循环显示闪烁的点，直到命令执行完成
  while ps -p $pid >/dev/null; do
    printf "."
    sleep 0.5
    printf "\b"
    sleep 0.5
  done
  end_time=$(date +%s)
  execution_time=$((end_time - start_time))
  # 等待命令执行完成并获取其退出状态
  wait $pid
  local status=$?
  # 根据命令的执行状态输出相应的信息（防火墙等服务关闭后查看状态会返回 3）
  if [[ $status = 0 || $status = 3 ]]; then
    printf "已完成 (耗时: %s 秒)\n" "$execution_time"
  # rpm_install 中有些包没有源无法安装，所有会返回 1，忽略
  elif [[ $status != 0 && $cmd = "rpm_install" ]]; then
    printf "已完成 (耗时: %s 秒)\n" "$execution_time"
  else
    printf "执行出错，请检查日志 %s\n" "$oracleinstalllog"
    exit 1
  fi
}
#==============================================================#
#                           写文件                              #
#==============================================================#
function write_file() {
  local flag=$1
  local file_name=$2
  local content=$3
  if [[ $flag = "Y" ]]; then
    cat <<-EOF >"$file_name"
$content
EOF
  elif [[ $flag = "N" ]]; then
    cat <<-EOF >>"$file_name"
$content
EOF
  fi
}
#==============================================================#
#                         BAK FILE                             #
#==============================================================#
# 定义名为 bak_file 的函数，用于备份指定文件
function bak_file() {
  # 获取第一个传入参数作为要备份的文件路径
  local file_path=$1
  # 如果文件存在则备份
  if check_file "$file_path"; then
    # 检查文件中是否包含 "# OracleBegin" 字符串
    if [[ $(grep -E -c "# OracleBegin" "$file_path") = 0 ]]; then
      # 如果不包含，备份该文件并附加 .original 后缀
      /bin/cp -f "$file_path"{,.original}
    else
      # 如果文件中包含 "# OracleBegin" 字符串，则先备份当前文件，再恢复原始文件
      # 备份当前文件，将其保存为原来的名称加上当前时间戳的形式
      /bin/cp -f "$file_path"{,."$current"}
      # 恢复原始文件，将其替换回原始的备份文件
      /bin/cp -f "$file_path"{.original,}
    fi
  else
    touch "$file_path".original
  fi
}
#==============================================================#
#                        执行 sqlplus 命令                       #
#==============================================================#
function execute_sqlplus() {
  local dbname="$1"
  local format="$2"
  local sql="$3"
  su - oracle <<-SOF
source /home/oracle/.$dbname
sqlplus -S / as sysdba<<-\EOF
set line2222 pages1000 tab off feedback off
$format
$sql
exit;
EOF
SOF
}
#==============================================================#
#                          GET UUID                            #
#==============================================================#
# 定义内部函数以获取 UUID 并将其添加到输出文件中
function get_uuid() {
  local uuid
  # 根据操作系统版本选择要使用的 scsi_id 工具路径
  local scsi_id
  if [[ $os_version = "6" ]]; then
    scsi_id="/sbin/scsi_id"
  else
    scsi_id="/usr/lib/udev/scsi_id"
  fi
  uuid=$("$scsi_id" -g -u "$1")
  echo "$uuid"
}
#==============================================================#
#                       Clean Disk                             #
#==============================================================#
# 定义名为 clean_disk_and_get_uuid 的函数
function clean_disk_and_get_uuid() {
  local uuid_list
  local uuid
  local uuid_string
  local identifier=$2
  # 将磁盘路径字符串分割成数组
  IFS=',' read -ra disks <<<"$1"
  for disk in "${disks[@]}"; do
    if [[ -n "$disk" ]]; then
      # 清理磁盘头
      dd if=/dev/zero of="$disk" bs=1024 count=1 >/dev/null 2>&1
      # 获取 UUID
      uuid=$(get_uuid "$disk")
      if [[ -z "$uuid" ]]; then
        color_printf red "磁盘 $disk 的 UUID 未获取到，请检查磁盘！"
      fi
      # 添加 UUID 到列表
      uuid_list+=("$uuid")
    fi
  done
  # 连接数组元素，并设置 IFS 为逗号
  uuid_string=$(
    IFS=,
    echo "${uuid_list[*]}"
  )
  case "$identifier" in
  "OCR")
    ocr_disk_uuid="$uuid_string"
    ;;
  "DATA")
    data_disk_uuid="$uuid_string"
    ;;
  "ARCH")
    arch_disk_uuid="$uuid_string"
    ;;
  esac
}
#==============================================================#
#                   Conf Disk && GET UUID                      #
#==============================================================#
function conf_disk_uuid() {
  # 如果已经提前配置好 ASM 磁盘，则直接获取 ASM 磁盘路径
  if [[ $asm_disk_conf = "N" ]]; then
    datadisk=$data_base_disk
    ocrdisk=${ocr_base_disk:+"$ocr_base_disk"}
    archdisk=${arch_base_disk:+"$arch_base_disk"}
    # 获取asmdisk_string，截图磁盘名称的前三位作为前缀，例如 /dev/asm-data1，截取后为 /dev/asm*
    asmdisk_string="$(dirname "${data_base_disk##*,}")/$(echo "${data_base_disk##*/}" | cut -c1-3)""*"
  else
    # 解析 ASN 磁盘，获取 UUID，做了判断单机 ASM
    log_print "获取 ASM 磁盘 UUID && 格式化磁盘头" >>"$oracleinstalllog"
    # 定义磁盘类型数组
    local disk_types=("OCR" "DATA" "ARCH")
    # 循环遍历磁盘类型数组
    for disk_type in "${disk_types[@]}"; do
      # 根据磁盘类型构造对应的变量名
      local base_disk="${disk_type,,}_base_disk"
      # 构造保存磁盘 UUID 的变量名
      local disk_uuid_var="${disk_type,,}_disk_uuid"
      # 检查磁盘组是否传值
      if [[ "${!base_disk}" ]]; then
        echo >>"$oracleinstalllog"
        color_printf blue "格式化 $disk_type 磁盘：${!base_disk}" >>"$oracleinstalllog"
        clean_disk_and_get_uuid "${!base_disk}" "$disk_type"
        color_printf green "$disk_type 磁盘组的磁盘 UUID：" "${!disk_uuid_var}" >>"$oracleinstalllog"
      fi
    done
  fi
}
#==============================================================#
#                         过滤唯一uuid磁盘                       #
#==============================================================#
function filter_disk() {
  local fil_disk=$1
  local all_disks
  local disk
  local disk_list=()
  declare -A uuids
  declare -A sizes
  # 获取磁盘容量
  disk_storage() {
    lsblk -b -o SIZE,TYPE "${1}" | awk '$2 == "disk" {print $1/1024/1024/1024 "G"}'
  }
  # 获取所有磁盘设备，筛选出以 sd 或 vd 开头的设备名
  all_disks=$(lsblk -n -o NAME | awk '/^sd|vd/ { print $1 }')
  # 读取 fil_disk 参数到数组，使用逗号分隔
  IFS=',' read -ra fil_disk_arr <<<"$fil_disk"
  # 排除不需要的磁盘
  for disk in $all_disks; do
    if ! [[ "${fil_disk_arr[*]}" =~ $disk ]]; then
      disk_list+=("/dev/$disk")
    fi
  done
  # 处理每个磁盘的循环
  for disk in "${disk_list[@]}"; do
    # 保存磁盘容量大小到关联数组中
    sizes[$disk]=$(disk_storage "$disk")
    # 获取磁盘的 UUID
    local uuid
    uuid=$(get_uuid "$disk")
    # 如果磁盘有 UUID 并且它还没有添加到数组中，就将其添加到数组中
    if [[ -n $uuid && ! "${uuids[*]}" =~ $uuid ]]; then
      uuids[$disk]=$uuid
    fi
  done
  # 遍历存储磁盘 UUID 的关联数组并打印每个磁盘的 UUID、名称和容量大小
  color_printf light_blue "Disk UUID" "Disk Name" "Size"
  for disk in "${!uuids[@]}"; do
    color_printf green "${uuids[$disk]}" "$disk" "${sizes[$disk]}"
  done | sort -k3,3n -k2,2
}
#==============================================================#
#                         SSH Check                            #
#==============================================================#
function ssh_check() {
  # 检查 ssh 连接是否正常
  local user=$1
  local all_connections_ok=true
  # 远程主机 IP 地址数组
  declare -a ips=("${@:2}")
  # 遍历所有 IP 地址，逐个进行 SSH 连接测试
  for ip in "${ips[@]}"; do
    # 利用 su 命令切换至指定用户执行 ssh 命令，测试连接是否正常
    if su -s /bin/bash -c "ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no $ip date" "$user" >/dev/null 2>&1; then
      all_connections_ok=true
    else
      # 如果某个连接失败，则标识 all_connections_ok 置为 false，并跳出循环
      all_connections_ok=false
      break
    fi
  done
  # 输出整体连接状态
  echo $all_connections_ok
}
#==============================================================#
#                         SSH Trust                            #
#==============================================================#
# 函数：创建并分发 SSH 密钥对，以实现 SSH 免密登录
function ssh_trust() {
  # 远程主机登录用户名
  local dest_user=$1
  # 远程主机登录密码
  local passwd=$2
  local ssh_dir
  # 远程主机 IP 地址数组
  declare -a host_ips=("${@:3}")
  # 根据不同用户设置 SSH 目录
  [[ $dest_user = "root" ]] && ssh_dir="/root/.ssh" || ssh_dir="/home/$dest_user/.ssh"
  # 准备 SSH 目录
  if [[ -e "$ssh_dir" ]]; then
    rm -rf "$ssh_dir"
  fi
  mkdir -p "$ssh_dir" && chmod 755 "$ssh_dir"
  # 生成 SSH 密钥对，并将公钥添加到 authorized_hosts 文件
  ssh-keygen -t rsa -P '' -f "$ssh_dir/id_rsa"
  cat "$ssh_dir/id_rsa.pub" >>"$ssh_dir/authorized_keys" && chmod 644 "$ssh_dir/authorized_keys"
  # 将主机密钥添加到 known_hosts 文件
  if [[ ! -f "$ssh_dir/known_hosts" ]]; then
    # 如果 known_hosts 文件不存在，则创建它
    touch "$ssh_dir/known_hosts"
  fi
  # 互信加密认证
  local encryption_para
  encryption_para=$([[ "$os_version" = 6 ]] && echo "rsa,dsa" || echo "rsa,dsa,ecdsa,ed25519")
  for ip in "${host_ips[@]}"; do
    # openEuler 22.03 需要增加 ed25519 认证
    ssh-keygen -F "$ip" >/dev/null || ssh-keyscan -t "$encryption_para" "$ip" >>"$ssh_dir/known_hosts" 2>/dev/null
  done
  # 将 SSH 目录分发到远程主机，并设置 SSH 无密码登录
  for ip in "${host_ips[@]}"; do
    # 传输文件
    /usr/bin/expect <<EOF >/dev/null 2>&1
spawn scp -q -r $ssh_dir $dest_user@$ip:~
expect "password:" { sleep 1; send "$passwd\r"; exp_continue } eof { exit }
EOF
    # 恢复上下文
    if [[ "$os_version" = 6 ]]; then
      /usr/bin/expect <<EOF >/dev/null 2>&1
spawn ssh -q $dest_user@$ip restorecon -RF $ssh_dir
expect "password:" { sleep 1; send "$passwd\r"; exp_continue } eof { exit }
}
EOF
    fi
  done
  # 等待所有任务完成
  wait
}
#==============================================================#
#                          参数值判断                            #
#==============================================================#
function checkpara_NULL() {
  if [[ -z $2 || $2 = -* ]]; then
    color_printf red "参数 [ $1 ] 的值为空，请检查!"
  fi
}
# 判断参数值是否为 Y/N
function checkpara_YN() {
  if ! [[ $2 =~ ^[YN]$ ]]; then
    color_printf red "参数 [ $1 ] 的值必须为 Y 或者 N，请检查!"
  fi
}
# 判断磁盘组冗余度
function checkpara_REDUN() {
  local REDUN="EXTERNAL|NORMAL|HIGH"
  if ! [[ $2 =~ ^($REDUN)$ ]]; then
    color_printf red "RAC 参数 [ $1 ] 的值必须为 EXTERNAL，NORMAL 或者 HIGH，请检查!"
  fi
}
# 判断密码复杂度
check_password() {
  local password="$2"
  local regex="^[a-zA-Z0-9]+$" # 正则表达式，只允许数字和字母

  if ! [[ $password =~ $regex ]]; then
    color_printf red "参数 [ $1 ] 的密码 $2 不符合要求，请使用数字和字母，不要使用特殊字符，请检查!"
  fi
}
# 判断所需文件是否存在的函数
function check_file {
  if [[ -e "$1" ]]; then
    return 0
  else
    return 1
  fi
}
# 封装 oracle 用户执行函数
function run_as_oracle() {
  local command="$1"
  su - oracle -c "$command"
}
# 封装 grid 用户执行函数
function run_as_grid() {
  local command="$1"
  su - grid -c "$command"
}
# 检查 IP 地址的有效性
function check_ip() {
  local ip=$1
  # 使用正则表达式和 awk 判断 IP 地址是否有效
  if echo "$ip" | grep -Eq "^([0-9]{1,3}\.){3}[0-9]{1,3}$"; then
    # 如果是有效的 IPv4 地址
    return 0
  else
    # 如果不是有效的 IPv4 地址
    return 1
  fi
}
# 检查 IP 是否重复
function isunique_ip() {
  declare -A ip_count
  # 计数每个 IP 出现的次数
  for ip in "${allips[@]}"; do
    ((ip_count[$ip]++))
  done
  # 检查是否有重复的 IP
  for ip in "${!ip_count[@]}"; do
    if ((ip_count[$ip] > 1)); then
      color_printf red "IP地址 $ip 存在重复，请检查！"
    fi
  done
}
# 检查 IP 连通性
function check_ip_connectivity() {
  local ip=$1
  if ! ping -c 1 "$ip" >/dev/null 2>&1; then
    color_printf red "IP地址 $ip 无法 ping 通，请检查！"
  fi
}
# 检查是否开通外网
check_internet_connectivity() {
  if ! ping -c 1 www.baidu.com >/dev/null 2>&1; then
    color_printf red "当前主机未连接到互联网，本脚本在 Fedora 安装 Oracle 数据库必须连接外网！"
  fi
}
#==============================================================#
#                           校验传参                            #
#==============================================================#
function check_para() {
  while [[ $1 ]]; do
    case $1 in
    # 当前节点号，脚本内部参数，仅用于脚本识别当前执行的节点
    -node | --node_num)
      node_num=$2
      # 通过shift 2将已经处理过的参数（-node和其对应的值）从参数列表中移除，让接下来处理参数的代码只处理剩余的参数
      shift 2
      ;;
    # 是否挂载ISO镜像，脚本外部参数，用于判断脚本是否需要配置YUM源，默认值为Y，代表已经挂载ISO镜像，脚本会自动配置YUM源
    -iso | --iso)
      # 判断ISO参数的值是否为空，如果为空则提示报错退出执行
      checkpara_NULL "$1" "$2"
      # 判断ISO参数的值是否为Y/N，如果不是则提示报错退出执行
      checkpara_YN "$1" "$2"
      iso=$2
      shift 2
      ;;
    -o | --db_name)
      checkpara_NULL "$1" "$2"
      db_name=$2
      shift 2
      ;;
    # 单机时作为主机名传参，RAC时作为主机名前缀传参
    -n | --hostname)
      checkpara_NULL "$1" "$2"
      hostname=$2
      shift 2
      ;;
    -hn | --rac_hostname)
      checkpara_NULL "$1" "$2"
      rac_hostname=$2
      # 转为数组
      IFS=',' read -ra rac_hostnames <<<"$rac_hostname"
      if [[ ${#rac_hostnames[@]} -lt 2 ]]; then
        color_printf red "RAC 参数 [ -hn ] 至少需要包含 2 个节点的主机名!"
      fi
      shift 2
      ;;
    -sn | --scan_name)
      checkpara_NULL "$1" "$2"
      scan_name=$2
      shift 2
      ;;
    -cn | --cluster_name)
      checkpara_NULL "$1" "$2"
      cluster_name=$2
      shift 2
      ;;
    -d | --env_base_dir)
      checkpara_NULL "$1" "$2"
      env_base_dir=$2
      # 检查脚本软件目录是否为oracle安装根目录
      if [[ $software_dir = "$env_base_dir" ]]; then
        color_printf red "Oracle 软件安装包以及脚本不能放在 $env_base_dir，建议创建 /soft 目录存放!"
      fi
      shift 2
      ;;
    -ord | --oradata_dir)
      checkpara_NULL "$1" "$2"
      oradata_dir=$2
      shift 2
      ;;
    -rp | --root_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      root_passwd=$2
      shift 2
      ;;
    -gp | --grid_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      grid_passwd=$2
      shift 2
      ;;
    -op | --oracle_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      oracle_passwd=$2
      shift 2
      ;;
    -dp | --database_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      database_passwd=$2
      shift 2
      ;;
    -lf | --local_ifname)
      checkpara_NULL "$1" "$2"
      local_ifname=$2
      # 通过网卡名称获取网卡对应的IP地址，如果获取不到说明网络没有配置
      local_ip=$(ip addr show dev "$local_ifname" | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
      if [[ $local_ip ]]; then
        # 检查IP地址是否合法
        if check_ip "$local_ip"; then
          check_ip_connectivity "$local_ip"
        else
          color_printf red "参数 [ -lf ] 网卡名称：$local_ifname 对应的 IP：$local_ip 不合规，请检查!"
        fi
      else
        color_printf red "参数 [ -lf ] 网卡名称：$local_ifname 不存在或者未配置 IP 信息，请检查!"
      fi
      shift 2
      ;;
    -pf | --rac_priv_ifname)
      checkpara_NULL "$1" "$2"
      rac_priv_ifname=$2
      # 将参数值转化为数组形式
      IFS=',' read -ra rac_priv_ifnames <<<"$rac_priv_ifname"
      # 判断RAC心跳数不超过2个
      if [[ ${#rac_priv_ifnames[@]} -gt 2 ]]; then
        color_printf red "RAC 参数 [ -pf ] 心跳网卡不建议超过 2 组!"
      fi
      shift 2
      ;;
    -ri | --rac_public_ip)
      checkpara_NULL "$1" "$2"
      rac_public_ip=$2
      # 将参数值转化为数组形式
      IFS=',' read -ra rac_public_ips <<<"$rac_public_ip"
      # 判断RAC节点数不少于2个
      if [[ ${#rac_public_ips[@]} -lt 2 ]]; then
        color_printf red "RAC 参数 [ -ri ] 至少需要包含 2 个节点的公网 IP 地址!"
      fi
      # 拆分公网IP进行判断
      for public_ip in "${rac_public_ips[@]}"; do
        if check_ip "$public_ip"; then
          allips+=("$public_ip")
          ssh_ips+=("$public_ip")
          check_ip_connectivity "$public_ip"
        else
          color_printf red "RAC 参数 [ -ri ] 中的 IP：$public_ip 不合规，请检查!"
        fi
      done
      shift 2
      ;;
    -vi | --rac_virtual_ip)
      checkpara_NULL "$1" "$2"
      rac_virtual_ip=$2
      # 将参数值转化为数组形式
      IFS=',' read -ra rac_virtual_ips <<<"$rac_virtual_ip"
      # 判断RAC节点数不少于2个
      if [[ ${#rac_virtual_ips[@]} -lt 2 ]]; then
        color_printf red "RAC 参数 [ -vi ] 至少包含 2 个节点的虚拟IP!"
      fi
      # 拆分虚拟IP进行判断
      for virtual_ip in "${rac_virtual_ips[@]}"; do
        if check_ip "$virtual_ip"; then
          allips+=("$virtual_ip")
        else
          color_printf red "RAC 参数 [ -vi ] 中的 IP：$virtual_ip 不合规，请检查!"
        fi
      done
      shift 2
      ;;
    -si | --rac_scan_ip)
      checkpara_NULL "$1" "$2"
      rac_scan_ip=$2
      # 将参数值转化为数组形式
      IFS=',' read -ra rac_scan_ips <<<"$rac_scan_ip"
      # 拆分SCANIP进行判断
      for ((i = 0; i < ${#rac_scan_ips[@]}; i++)); do
        ((scan_count = i + 1))
        if check_ip "${rac_scan_ips[i]}"; then
          allips+=("${rac_scan_ips[i]}")
        else
          color_printf red "RAC 参数 [ -si ] 中的 IP 地址：${rac_scan_ips[i]} 不合规，请检查!"
        fi
      done
      shift 2
      ;;
    -ds | --db_characterset)
      checkpara_NULL "$1" "$2"
      db_characterset=$2
      shift 2
      ;;
    -ns | --nation_characterset)
      checkpara_NULL "$1" "$2"
      nation_characterset=$2
      shift 2
      ;;
    -redo | --redosize)
      checkpara_NULL "$1" "$2"
      redosize=$2
      shift 2
      ;;
    -er | --enable_arch)
      checkpara_NULL "$1" "$2"
      if [[ $2 != "true" && $2 != "false" ]]; then
        color_printf red "参数 [ -er ] 的值：$2 必须配置为 true 或者 false，请检查!"
      else
        enable_arch=$2
      fi
      shift 2
      ;;
    -pdb | --pdbname)
      checkpara_NULL "$1" "$2"
      pdbname=$2
      # 如果传入pdb参数，则默认创建为CDB架构
      iscdb=true
      shift 2
      ;;
    -dnsn | --dns_name)
      checkpara_NULL "$1" "$2"
      dns_name=$2
      shift 2
      ;;
    -dnsi | --dns_ip)
      checkpara_NULL "$1" "$2"
      dns_ip=$2
      if check_ip "$dns_ip"; then
        check_ip_connectivity "$dns_ip"
      else
        color_printf red "RAC 参数 [ -dsi ] IP 地址：$dns_ip 不合规，请检查!"
      fi
      shift 2
      ;;
    -dns | --dns)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      dns=$2
      shift 2
      ;;
    -on | --ocr_asm_group)
      checkpara_NULL "$1" "$2"
      ocr_asm_group=$2
      shift 2
      ;;
    -dn | --data_asm_group)
      checkpara_NULL "$1" "$2"
      data_asm_group=$2
      shift 2
      ;;
    -an | --arch_asm_group)
      checkpara_NULL "$1" "$2"
      arch_asm_group=$2
      shift 2
      ;;
      # 是否需要配置多路径 Multipath，不配置多路径则直接绑定UDEV
    -mp | --multipath)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      multipath=$2
      shift 2
      ;;
    -adc | --asm_disk_conf)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      asm_disk_conf=$2
      shift 2
      ;;
    -od | --ocr_base_disk)
      checkpara_NULL "$1" "$2"
      ocr_base_disk=$2
      shift 2
      ;;
    -dd | --data_base_disk)
      checkpara_NULL "$1" "$2"
      data_base_disk=$2
      shift 2
      ;;
    -ad | --arch_base_disk)
      checkpara_NULL "$1" "$2"
      arch_base_disk=$2
      shift 2
      ;;
    -or | --ocr_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      ocr_redun=$2
      shift 2
      ;;
    -dr | --data_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      data_redun=$2
      shift 2
      ;;
    -ar | --arch_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      arch_redun=$2
      shift 2
      ;;
    -tsi | --timeserver_ip)
      checkpara_NULL "$1" "$2"
      timeserver_ip=$2
      if check_ip "$timeserver_ip"; then
        check_ip_connectivity "$timeserver_ip"
      else
        color_printf red "RAC 参数 [ -tsi ] IP 地址：$timeserver_ip 不合规，请检查!"
      fi
      shift 2
      ;;
    -gui | --isgui)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      isgui=$2
      shift 2
      ;;
    -vbox | --virtualbox)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      virtualbox=$2
      shift 2
      ;;
    -gpa | --grid_patch)
      checkpara_NULL "$1" "$2"
      grid_patch=$2
      grid_patch_name=$(find "$software_dir" -type f -name "*$grid_patch*zip")
      # 检查 Grid 补丁包是否已上传至指定目录
      if ! check_file "$grid_patch_name"; then
        color_printf red "RAC 参数 [-gpa] 对应的 Grid 补丁包：$grid_patch_name 是否已上传至目录：$software_dir，请检查并上传!"
      fi
      shift 2
      ;;
    -opa | --oracle_patch)
      checkpara_NULL "$1" "$2"
      oracle_patch=$2
      db_patch_name=$(find "$software_dir" -type f -name "*$oracle_patch*zip")
      # 检查 Oracle 补丁包是否已上传至指定目录
      if ! check_file "$db_patch_name"; then
        color_printf red "参数 [ -opa ] 对应的 Oracle 补丁包：$db_patch_name 是否已上传至目录：$software_dir，请检查并上传!"
        exit 1
      fi
      shift 2
      ;;
    -jpa | --ojvm_patch)
      checkpara_NULL "$1" "$2"
      ojvm_patch=$2
      ojvm_patch_name=$(find "$software_dir" -type f -name "*$ojvm_patch*zip")
      # 检查 OJVM 补丁包是否已上传至指定目录
      if ! check_file "$ojvm_patch_name"; then
        color_printf red "参数 [ -jpa ] 对应的 OJVM 补丁包：$ojvm_patch_name 是否已上传至目录：$software_dir，请检查并上传!"
      fi
      shift 2
      ;;
    -m | --only_conf_os)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      only_conf_os=$2
      shift 2
      ;;
    -ug | --install_until_grid)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      install_until_grid=$2
      shift 2
      ;;
    -ud | --install_until_db)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      install_until_db=$2
      shift 2
      ;;
    -opd | --optimize_db)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      optimize_db=$2
      shift 2
      ;;
    -install_mode | --oracle_install_mode)
      checkpara_NULL "$1" "$2"
      oracle_install_mode=$2
      shift 2
      ;;
    -giv | --gi_version)
      checkpara_NULL "$1" "$2"
      gi_version=$2
      shift 2
      ;;
    -dbv | --db_version)
      checkpara_NULL "$1" "$2"
      db_version=$2
      shift 2
      ;;
    -fd | --filter_disk)
      checkpara_NULL "$1" "$2"
      # 如果传参，则直接过滤多路径磁盘
      filter_disk "$2"
      exit 0
      ;;
    -h | --help)
      help
      exit 0
      ;;
    *)
      color_printf red "脚本执行命令中的参数 [ $1 ] 传参不正确，请使用 'sh OracleShellInstall --help' 以获取更多帮助信息!"
      ;;
    esac
  done
}
#==============================================================#
#                             Usage                            #
#==============================================================#
function help() {
  # 打印参数
  print_options() {
    local options=("$@")
    # 调用 color_printf 函数，输出绿色字体
    # ${option%% *} 表示从 option 变量中删除最后一个空格及其后面的字符，保留前面的部分
    # ${option#* } 表示从 option 变量中删除第一个空格及其前面的字符，保留后面的部分
    for option in "${options[@]}"; do
      color_printf green "${option%% *}" "${option#* }"
    done
  }
  echo
  # 单机模式
  color_printf blue "用法: OracleShellInstall [选项] 对象 { 命令 | help }"
  color_printf blue "单机模式："
  options=(
    "-iso 不需要配置本地YUM源时，请配置该参数为：N，默认值：[Y]"
    "-lf [必填] 公网 IP 的网卡名称"
    "-n 主机名，默认值：[orcl]"
    "-op 系统 oracle 用户密码，默认值：[oracle]"
    "-d Oracle 软件安装根目录，默认值：[/u01]"
    "-ord Oracle 数据文件目录，默认值：[/oradata]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-dp Oracle 数据库 sys/system 密码，默认值：[oracle]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
  )
  print_options "${options[@]}"
  # 单机 ASM 模式
  echo
  color_printf blue "单机 ASM 模式："
  options=(
    "-iso 不需要配置本地YUM源时，请配置该参数为：N，默认值：[Y]"
    "-lf [必填] 公网 IP 的网卡名称"
    "-n 主机名，默认值：[orcl]"
    "-op 系统 oracle 用户密码，默认值：[oracle]"
    "-d Oracle 软件安装根目录，默认值：[/u01]"
    "-ord Oracle 数据文件目录，默认值：[/oradata]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-gp 系统 grid 用户密码，建议不要包含特殊字符，默认值：[oracle]"
    "-dp Oracle 数据库 sys/system 密码，默认值：[oracle]"
    "-adc 是否需要脚本配置 ASM 磁盘，如果不需要配置，则需要自行提前配置好，默认值：[Y]"
    "-mp 是否需要脚本配置 multipath 多路径，如果不需要配置多路径，则使用UDEV直接绑盘，默认值：[Y]"
    "-dd [必填] ASM DATA 磁盘组的磁盘列表，默认传参为(sd名称)：-dd /dev/sdb：若设置参数 -adc N，则传入已配置好的磁盘列表：-dd /dev/asm_data1"
    "-dn ASM DATA 磁盘组名称，默认值：[DATA]"
    "-dr ASM DATA 磁盘组冗余度，默认值：[EXTERNAL]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-gpa Grid PSU/RU 补丁编号"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
    "-vbox 在虚拟机 virtualbox 上安装 RAC 时需要设置 -vbox Y，用于修复 BUG，默认值：[N]"
    "-fd 过滤多路径磁盘，去除重复路径，获取唯一盘符：参数值为非ASM盘符（系统盘等），例如：-fd /dev/sda，多个盘符用逗号拼接：-fd /dev/sda,/dev/sdb"
  )
  print_options "${options[@]}"
  # RAC 集群模式
  echo
  color_printf blue "RAC 模式："
  options=(
    "-iso 不需要配置本地YUM源时，请配置该参数为：N，默认值：[Y]"
    "-lf [必填] RAC 所有节点公网 IP 的网卡名称，所有节点需要保持一致，例如：-lf team0"
    "-pf [必填] RAC 所有节点心跳 IP 的网卡名称，最多支持2组心跳，所有节点需要保持一致，例如：-pf eth3,eth4"
    "-n [必填] RAC 所有节点主机名前缀，参数值必须按照节点顺序排序，例如主机名为 orcl01,orcl02，则参数传值：-n orcl，默认值：[orcl]"
    "-hn [必填] RAC 所有节点主机名，参数值必须按照节点顺序排序，例如：-hn orcl01,orcl02"
    "-ri [必填] RAC 所有节点公网 IP 地址，参数值必须按照节点顺序排序，例如：-ri 10.211.55.100,10.211.55.101"
    "-vi [必填] RAC 所有节点虚拟 IP 地址，参数值必须按照节点顺序排序，例如：-ri 10.211.55.102,10.211.55.103"
    "-si [必填] RAC scan IP 地址，单个scan ip无需配置 DNS，3个scan ip则必须配置 DNS，例如：-si 10.211.55.105,10.211.55.106,10.211.55.107"
    "-d Oracle 数据库软件安装根目录 [/u01]"
    "-rp [必填] 系统 root 用户密码，所有节点必须保持一致，用于建立互信，建议不要包含特殊字符"
    "-gp 系统 grid 用户密码，建议不要包含特殊字符，默认值：[oracle]"
    "-op 系统 oracle 用户密码，建议不要包含特殊字符，默认值：[oracle]"
    "-cn RAC 集群名称，长度不能超过15位，可自定义，默认值：主机名前缀(-n参数)-cluser [orcl-cluster]"
    "-sn RAC scan名称，可自定义，默认值：主机名前缀(-n参数)-scan [orcl-scan]"
    "-adc 是否需要脚本配置 ASM 磁盘，如果不需要配置，则需要自行提前配置好，默认值：[Y]"
    "-mp 是否需要脚本配置 multipath 多路径，如果不需要配置多路径，则使用UDEV直接绑盘，默认值：[Y]"
    "-od [必填] ASM OCR 磁盘组的磁盘列表，默认传参为(sd名称)：-od /dev/sdb：若设置参数 -adc N，则传入已配置好的磁盘列表：-od /dev/asm_ocr1"
    "-dd [必填] ASM DATA 磁盘组的磁盘列表，传参方式同 -od"
    "-ad ASM 归档日志磁盘组的磁盘列表，传参方式同 -od"
    "-on ASM OCR 磁盘组名称，默认值：[OCR]"
    "-dn ASM DATA 磁盘组名称，默认值：[DATA]"
    "-an ASM ARCH 磁盘组名称，默认值：[ARCH]"
    "-or ASM OCR 磁盘组冗余度，默认值：[EXTERNAL]"
    "-dr ASM DATA 磁盘组冗余度，默认值：[EXTERNAL]"
    "-ar ASM ARCH 磁盘组冗余度，默认值：[EXTERNAL]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-dp Oracle 数据库 sys/system 密码，默认值：[oracle]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-tsi RAC CTSS 的时间服务器 IP 地址，用于配置所有节点间的时间同步"
    "-dns 是否配置 DNS，如果配置多个scan ip，则需要配置 -dns Y，默认值：[N]"
    "-dnsn DNS 服务器名称"
    "-dnsi DNS 服务器 IP 地址"
    "-gpa Grid PSU/RU 补丁编号"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ug 安装到 Grid 软件结束，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
    "-vbox 在虚拟机 virtualbox 上安装 RAC 时需要设置 -vbox Y，用于修复 BUG，默认值：[N]"
    "-fd 过滤多路径磁盘，去除重复路径，获取唯一盘符：参数值为非ASM盘符（系统盘等），例如：-fd /dev/sda，多个盘符用逗号拼接：-fd /dev/sda,/dev/sdb"
  )
  print_options "${options[@]}"
  echo
  color_printf yellow "注意：本脚本仅用于新服务器上实施部署数据库使用，严禁在已运行数据库的主机上执行，以免发生数据丢失或者损坏，造成不可挽回的损失！！！"
}
#==============================================================#
#                         选择数据库安装模式                      #
#==============================================================#
function select_install_mode() {
  while :; do
    read -rep "$(echo -e "\033[1;34m请选择安装模式 [单机(si)/单机ASM(sa)/集群(rac)] : \E[0m")" oracle_install_mode
    echo
    case "$oracle_install_mode" in
    si) oracle_install_mode=single ;;
    sa) oracle_install_mode=standalone ;;
    esac
    if [[ "$oracle_install_mode" =~ ^(single|standalone|rac)$ ]]; then
      color_printf green "数据库安装模式:" "$oracle_install_mode"
      break
    else
      color_printf yellow "数据库安装模式输入错误，请重新选择!"
    fi
  done
}
#==============================================================#
#                         选择数据库版本                         #
#==============================================================#
function select_db_version() {
  while :; do
    echo
    read -rep "$(echo -e "\033[1;34m请选择数据库版本 [11/12/19/21] : \E[0m")" db_version
    echo
    if [[ "$db_version" =~ ^(11|12|19|21)$ ]]; then
      color_printf green "数据库版本:" "$db_version"
      echo
      break
    else
      color_printf yellow "数据库版本输入错误，请重新选择!"
    fi
  done
  # 判断 standalone/rac GI 版本和 DB 版本，只针对传入了 -giv 参数情况进行判断
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    # gi_version 未传参，则代表 GI 和 DB 版本相同
    if [[ -z "$gi_version" ]]; then
      gi_version=$db_version
    else
      # 判断 gi 版本需要大于 db 版本
      if [[ "$gi_version" < "$db_version" ]]; then
        color_printf red "参数 [ -giv ] 的值：GI 版本 $gi_version 必须必须大于等于 DB 版本 $db_version，请检查!"
      fi
    fi
  fi
}
#==============================================================#
#                       获取 Grid 安装包信息                     #
#==============================================================#
function get_grid_soft() {
  case "$gi_version" in
  "11")
    cvu_name="cvuqdisk-1.0.9-1.rpm"
    ;;
  *)
    cvu_name="cvuqdisk-1.0.10-1.rpm"
    ;;
  esac
  declare -A gi_version_dirs=(
    ["11"]="$software_dir/p6880880_112000_Linux-x86-64.zip;$env_base_dir/app/11.2.0/grid;$software_dir/p13390677_112040_Linux-x86-64_3of7.zip;$software_dir/grid/rpm/$cvu_name;11.2.0.4.0"
    ["12"]="$software_dir/p6880880_122010_Linux-x86-64.zip;$env_base_dir/app/12.2.0/grid;$software_dir/LINUX.X64_122010_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;12.2.0.1.0"
    ["19"]="$software_dir/p6880880_190000_Linux-x86-64.zip;$env_base_dir/app/19.3.0/grid;$software_dir/LINUX.X64_193000_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;19.0.0.0.0"
    ["21"]="$software_dir/p6880880_210000_Linux-x86-64.zip;$env_base_dir/app/21.3.0/grid;$software_dir/LINUX.X64_213000_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;21.0.0.0.0"
    ["23"]="$software_dir/p6880880_230000_Linux-x86-64.zip;$env_base_dir/app/23.3.0/grid;$software_dir/LINUX.X64_233000_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;23.0.0.0.0"
  )
  # 根据选择的 Grid 数据库版本
  IFS=";" read -r grid_opatch_name env_grid_home grid_soft_name cvuqdisk gi_compatible <<<"${gi_version_dirs[$gi_version]}"
  if [[ $node_num = 1 ]]; then
    # 主节点检查 GRID 安装包是否存在
    if ! check_file "$grid_soft_name"; then
      color_printf red "请检查 Grid 软件安装包 $grid_soft_name 是否已上传至 $software_dir 目录下!"
    fi
    # 检查 GI OPatch 补丁包是否已上传至指定目录
    if [[ $grid_patch ]]; then
      if ! check_file "$grid_opatch_name"; then
        color_printf red "OPatch 补丁包：$grid_opatch_name 不存在，请检查并上传!"
      fi
    fi
  fi
}
#==============================================================#
#                      获取 Oracle 安装包信息                    #
#==============================================================#
function get_db_soft() {
  declare -A db_version_dirs=(
    ["11"]="$software_dir/p6880880_112000_Linux-x86-64.zip;$env_oracle_base/product/11.2.0/db;$software_dir/p13390677_112040_Linux-x86-64_1of7.zip;$software_dir/p13390677_112040_Linux-x86-64_2of7.zip;;11.2.0.4.0"
    ["12"]="$software_dir/p6880880_122010_Linux-x86-64.zip;$env_oracle_base/product/12.2.0/db;$software_dir/LINUX.X64_122010_db_home.zip;;$iscdb;12.2.0.1.0"
    ["19"]="$software_dir/p6880880_190000_Linux-x86-64.zip;$env_oracle_base/product/19.3.0/db;$software_dir/LINUX.X64_193000_db_home.zip;;$iscdb;19.0.0.0.0"
    ["21"]="$software_dir/p6880880_210000_Linux-x86-64.zip;$env_oracle_base/product/21.3.0/db;$software_dir/LINUX.X64_213000_db_home.zip;;true;21.0.0.0.0"
    ["23"]="$software_dir/p6880880_230000_Linux-x86-64.zip;$env_oracle_base/product/23.3.0/db;$software_dir/LINUX.X64_233000_db_home.zip;;true;23.0.0.0.0"
  )
  # 根据选择的 Oracle 数据库版本
  IFS=";" read -r db_opatch_name env_oracle_home db_soft_name db_soft_name1 iscdb db_compatible <<<"${db_version_dirs[$db_version]}"
  # 检查数据库软件安装包是否存在
  if [[ $node_num = 1 ]]; then
    if [[ "$db_version" = "11" ]]; then
      if ! check_file "$db_soft_name" && ! check_file "$db_soft_name1"; then
        color_printf red "请检查 Oracle 软件安装包 $db_soft_name,$db_soft_name1 是否已上传至 $software_dir 目录下。"
      fi
    else
      if ! check_file "$db_soft_name"; then
        color_printf red "请检查 Oracle 软件安装包 $db_soft_name 是否已上传至 $software_dir 目录下。"
      fi
    fi
    # 检查 DB/OJVM OPatch 补丁包是否已上传至指定目录
    if [[ $oracle_patch || $ojvm_patch ]]; then
      if ! check_file "$db_opatch_name"; then
        color_printf red "OPatch 补丁包：$db_opatch_name 不存在，请检查并上传!"
      fi
    fi
  fi
}
#==============================================================#
#                         获取操作系统信息                        #
#==============================================================#
function get_os_info() {
  local os_file
  if [[ -e /etc/os-release ]]; then
    os_type=$(grep -oP '^ID="?(\K[^"]+|[^"]+$)' /etc/os-release)
    if [[ "$os_type" =~ ^(kylin|neokylin)$ ]]; then
      os_version=$(grep -oP '(?<=VERSION_ID=").*(?=")' /etc/os-release)
    else
      os_version=$(grep -oP '^VERSION_ID="?(\K[0-9]+|[0-9]+$)' /etc/os-release)
    fi
  else
    os_file=$(if [[ -f "/etc/system-release" ]]; then echo /etc/system-release; else echo /etc/redhat-release; fi)
    os_type=$(grep -oP '^[A-Za-z]+' "$os_file")
    os_version=$(grep -oP '(?<=release\s|V)[[:digit:]]+' "$os_file")
  fi
  # 针对 Fedora 版本
  if [[ "$os_type" = "fedora" ]]; then
    # 调用函数来检查互联网连接
    check_internet_connectivity
    local versions=(12 19 28 34 50)
    for ((i = 0; i < ${#versions[@]} - 1; i++)); do
      if [[ $os_version -ge ${versions[i]} && $os_version -lt ${versions[i + 1]} ]]; then
        case $i in
        0) os_version=6 ;;
        1) os_version=7 ;;
        2) os_version=8 ;;
        3) os_version=9 ;;
        esac
      else
        color_printf red "Fedora 版本太低，本脚本不支持安装 Oracle 数据库！"
      fi
    done
  fi
  # 获取 profile 名称
  if [[ "$os_type" = "sles" ]]; then
    profile_name=.profile
  else
    profile_name=.bash_profile
  fi
}
#==============================================================#
#                     检查操作系统版本是否符合要求                  #
#==============================================================#
function check_os_version() {
  # 根据不同的操作系统和版本进行适配和优化
  case "$os_type-$os_version" in
  "openEuler-20")
    # 检查 openEuler 20 版本是否为 20.03 LTS SP4，否则给出提示并退出
    if [[ $(grep -oP '(?<=VERSION=").*(?=")' /etc/os-release) != "20.03 (LTS-SP4)" ]]; then
      if ! check_file "$software_dir"/glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm; then
        color_printf red "本脚本在 openEuler 20.03 非 LTS SP4 版本安装 Oracle 数据库需要上传 glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm 到 $software_dir 目录下！
                下载地址：https://mirrors.aliyun.com/openeuler/openEuler-20.03-LTS-SP4/everything/x86_64/Packages/glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm"
      else
        rpm -ivh "$software_dir"/glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm >/dev/null 2>&1
      fi
    fi
    ;;
  "openEuler-21")
    if ! check_file "/usr/lib64/libpthread_nonshared.a"; then
      if ! check_file "$software_dir"/libpthread_nonshared.a; then
        color_printf red "本脚本在 openEuler 21.03 版本安装 Oracle 数据库需要上传 libpthread_nonshared.a 到 $software_dir 目录下！
                下载地址：https://www.modb.pro/doc/130342"
      else
        if ! check_file "/usr/lib64/libpthread_nonshared.a"; then
          /bin/mv "$software_dir"/libpthread_nonshared.a /usr/lib64/ >/dev/null 2>&1
        fi
      fi
    fi
    ;;
  "openEuler-22" | "kylin-V10")
    if [[ "$os_type" = "openEuler" ]]; then
      # 12CR2 不管 GI 和 DB 都需要上传 compat-glibc-2.12-4.el7.centos.x86_64.rpm
      if [[ "$gi_version" = 12 || "$db_version" = 12 ]]; then
        ## openEuler 22.03 LTS SP3 安装 12CR2 报错 jskm.c:(.text+0x4081): undefined reference to `stat'，eobtl.c:(.text+0x3ba): undefined reference to `fstat' 解决方案
        if ! check_file "$software_dir"/compat-glibc-2.12-4.el7.centos.x86_64.rpm; then
          color_printf red "本脚本在 openEuler 22.03 安装 12CR2 单机/RAC 需要上传 compat-glibc-2.12-4.el7.centos.x86_64.rpm 到 $software_dir 目录下！
                下载地址：https://mirrors.ustc.edu.cn/centos/7/os/x86_64/Packages/compat-glibc-2.12-4.el7.centos.x86_64.rpm"
        else
          # 解压并提取软件包内容
          rpm2cpio "$software_dir"/compat-glibc-2.12-4.el7.centos.x86_64.rpm | cpio -idmvu -D "$software_dir" >/dev/null 2>&1
          # 创建并进入目录
          mkdir -p "$software_dir"/oS
          cd "$software_dir/oS" || return 1
          # 提取对象文件
          ar x "$software_dir"/usr/lib/x86_64-redhat-linux6E/lib64/libc_nonshared.a
          # 添加特定的对象文件到 libc_nonshared.a 中
          ar r /usr/lib64/libc_nonshared.a stat*.oS
          ar r /usr/lib64/libc_nonshared.a fstat*.oS
          # 返回 /soft 目录
          cd ..
          # 删除不必要的文件夹和文件
          if check_file "$software_dir/usr"; then
            rm -rf "${software_dir:?}/usr"
          fi
          if check_file "$software_dir"/oS; then
            rm -rf "${software_dir:?}/oS"
          fi
        fi
      fi
      # openEuler 22.03 LTS SP3 单机安装 19C 必须要上传补丁包版本大于 19
      if [[ $node_num = 1 ]]; then
        if [[ "$oracle_install_mode" = "single" ]]; then
          if [[ "$db_version" = 19 ]]; then
            if [[ $oracle_patch ]]; then
              # 如果传了 -opa 参数，则提示 -opa 参数对应的PSU补丁包必须大于 35643107
              if ((oracle_patch < 35643107)); then
                color_printf red "openEuler 22.03 LTS SP3 安装 Oracle 19C 必须安装 19.21(35643107) 或者之后的 RU 版本，请正确设置 [ -opa ] 参数!"
              fi
            else
              color_printf red "openEuler 22.03 LTS SP3 安装 Oracle 19C 必须安装 19.21(35643107) 或者之后的 RU 版本，必须设置 [ -opa ] 参数!"
            fi
          fi
        fi
      fi
    fi
    if [[ $node_num = 1 ]]; then
      case $gi_version in
      # 检查是否安装 Oracle 11GR2 RAC
      11)
        color_printf red "本脚本不支持在 openEuler 22.03 LTS SP3/Kylin V10 SP3 版本安装 11GR2 Grid!"
        ;;
      # 检查 12CRAC 是否设置 -opa 参数
      12)
        if [[ $grid_patch ]] && [[ -z $oracle_patch ]]; then
          color_printf red "在 openEuler 22.03 SP3/Kylin V10 SP3 版本安装 Oracle 12CR2 RAC 存在 opatchauto BUG，设置 [ -gpa ] 参数的同时必须设置 [ -opa ] 参数!"
        fi
        ;;
      19)
        if [[ $grid_patch ]]; then
          if ((grid_patch < 35642822)); then
            color_printf red "openEuler 22.03 LTS SP3/Kylin V10 SP3 安装 Oracle 19C RAC 必须安装 19.21(35642822) 或者之后的 RU 版本，请正确设置 [ -gpa ] 参数!"
          fi
        else
          color_printf red "openEuler 22.03 LTS SP3/Kylin V10 SP3 安装 Oracle 19C RAC 必须安装补丁号为 19.21(35642822) 或者之后的 RU 版本，必须设置 [ -gpa ] 参数!"
        fi
        ;;
      esac
    fi
    ;;
  "openEuler-23")
    if [[ "$db_version" =~ ^(11|12|21)$ ]]; then
      color_printf red "本脚本目前不支持在 openEuler 23.09 安装 Oracle 11G/12C/21C 版本!"
    fi
    ;;
  "anolis-7")
    # 检查 anolis 7.9 版本是否符合条件，否则给出提示并退出
    if ! check_file "$software_dir"/compat-libcap1-1.10-7.el7.x86_64.rpm; then
      color_printf red "本脚本在 anolis 7.9 安装 Oracle 需要上传 compat-libcap1-1.10-7.el7.x86_64.rpm 到 $software_dir 目录下！
              下载地址：https://mirrors.ustc.edu.cn/centos/7.9.2009/os/x86_64/Packages/compat-libcap1-1.10-7.el7.x86_64.rpm"
    else
      rpm -Uvh --quiet "$software_dir"/compat-libcap1-1.10-7.el7.x86_64.rpm >/dev/null 2>&1
    fi
    if ! [[ "$db_version" = 11 ]]; then
      # 检查 12C/19C 版本是否符合条件，否则给出提示并退出
      if ! check_file "/usr/lib64/libc-2.17.so"; then
        if ! check_file "$software_dir"/libc-2.17.so; then
          color_printf red "本脚本在 anolis 7.9 安装 Oracle 12C/19C 需要上传 libc-2.17.so 到 $software_dir 目录下！
              下载地址：https://www.modb.pro/doc/129426"
        else
          /bin/mv -f "$software_dir"/libc-2.17.so /usr/lib64/libc-2.17.so
          chmod 755 /usr/lib64/libc-2.17.so
        fi
      fi
    fi
    ;;
  "uos-20")
    # 统信 UOS V20 分为 1060a 和 1060e，分别对应 Anolis 8 和 openEuler 22.03 LTS SP3
    local os_issue
    os_issue=$(grep -oP '\d{4}[a-zA-Z]+' /etc/issue)
    # 统信 UOS V20 1060(a) 是基于 Anolis 8 发布，支持安装 Oracle 数据库
    if ! [[ "$os_issue" =~ ^(1060a|1070a)$ ]]; then
      color_printf red "统信 UOS V20 目前只适配 Oracle 数据库在 1060/1070(a) 版本安装，请使用 1060/1070(a)！"
    fi
    ;;
  "fedora-9")
    # Fedora 9 安装 compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm
    if check_file "$software_dir/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm"; then
      rpm -Uvh --quiet "$software_dir"/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm >/dev/null 2>&1
    fi
    ;;
  esac
}
#==============================================================#
#                     适配 RHEL 8 系操作系统类型                  #
#==============================================================#
function adapt_os_version() {
  case "$os_type-$os_version" in
  "kylin-V10" | "openEuler-20" | "openEuler-21" | "openEuler-22" | "openEuler-23" | "sles-15" | "uos-20" | "fedora-8")
    # 将系统版本调整为对应的 Red Hat 版本
    os_version=8
    # 修改系统版本信息为 Red Hat Enterprise Linux Server release 7.9 (Maipo)
    write_file "Y" "/etc/redhat-release" "Red Hat Enterprise Linux Server release 7.9 (Maipo)"
    # 修复 libnsl
    if ! check_file /usr/lib64/libnsl.so.1; then
      ln -s /usr/lib64/libnsl.so.2.0.1 /usr/lib64/libnsl.so.1 >/dev/null 2>&1
    fi
    ;;
  "fedora-9")
    # 将系统版本调整为对应的 Red Hat 版本
    os_version=9
    # 修改系统版本信息为 Red Hat Enterprise Linux Server release 8.9 (Ootpa)
    write_file "Y" "/etc/redhat-release" "Red Hat Enterprise Linux Server release 8.9 (Ootpa)"
    # 修复 libnsl
    if ! check_file /usr/lib64/libnsl.so.1; then
      ln -s /usr/lib64/libnsl.so.3.0.0 /usr/lib64/libnsl.so.1 >/dev/null 2>&1
    fi
    if ! check_file /usr/lib/libnsl.so.1; then
      ln -s /usr/lib/libnsl.so.3.0.0 /usr/lib/libnsl.so.1 >/dev/null 2>&1
    fi
    ;;
  "sles-12" | "neokylin-V7")
    # 将系统版本调整为对应的 Red Hat 版本
    os_version=7
    ;;
  esac
  # 定义 OS 标记
  case $os_type in
  # 红帽系列系统，版本是 8，9 的系统，定义 os_flag 为 OS2
  Red | CentOS | rhel | centos | ol | rocky | anolis | uos)
    if [[ "$os_version" = 8 || "$os_version" = 9 ]]; then
      os_flag=OS2
    fi
    ;;
  openEuler)
    os_flag=OS3
    ;;
  *)
    # 如果系统是 centos6 | centos7 | fedora | kylinV10 | neokylin 等其他系统定义 os_flag 值是：OS1
    os_flag=OS1
    ;;
  esac
}
#==============================================================#
#                         检查 YUM 源                           #
#==============================================================#
function check_iso() {
  # 获取ISO镜像挂载路径，排除光盘挂载的路径 iso9660
  mountPath=$(mount | awk '/iso9660/ && !/run\/media/ && !/\/media/ {print $3}')
  if [[ $mountPath ]]; then
    # 配置 YUM 源(提前配置YUM源，确保 RAC 安装 root ssh 互信需要安装 expect 软件)
    execute_and_log "正在配置 YUM 源" conf_yum
  else
    # 如果没有挂载路径，则输出错误信息并退出程序。
    echo
    color_printf red "ISO 镜像未挂载，请先挂载!"
  fi
}
#==============================================================#
#                         配置 YUM 源                           #
#==============================================================#
function conf_yum() {
  log_print "配置本地 YUM 源"
  case "$os_type" in
  "sles")
    # 备份原有YUM配置文件
    mkdir /etc/zypp/repos.d/bak -p && nohup mv /etc/zypp/repos.d/* /etc/zypp/repos.d/bak >/dev/null 2>&1
    case "$os_version" in
    "7")
      zypper ar -f "$mountPath" sles
      ;;
    "8")
      zypper ar -f "$mountPath"/Module-Basesystem sles
      zypper ar -f "$mountPath"/Module-Legacy sles-Legacy
      zypper ar -f "$mountPath"/Module-Development-Tools sles-Tools
      ;;
    esac
    ;;
  "fedora")
    color_printf blue "Fedora 无需配置本地 YUM 源！"
    ;;
  *)
    # 避免Linux主机提示注册
    [[ -e /etc/yum/pluginconf.d/subscription-manager.conf ]] && sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/subscription-manager.conf
    # 避免Kyli/openEuler主机提示注册
    [[ -e /etc/yum/pluginconf.d/debuginfo-install.conf ]] && sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/debuginfo-install.conf
    # 备份原有YUM配置文件
    mkdir /etc/yum.repos.d/bak -p && nohup mv /etc/yum.repos.d/* /etc/yum.repos.d/bak >/dev/null 2>&1
    # 适配各种 OS 系统配置 YUM 源
    case $os_flag in
    OS1)
      write_file "Y" "/etc/yum.repos.d/local.repo" "[server]
name=server
baseurl=file://$mountPath
enabled=1
gpgcheck=0"
      ;;
    OS2)
      write_file "Y" "/etc/yum.repos.d/local.repo" "[BaseOS]
name=BaseOS
baseurl=file://$mountPath/BaseOS
enabled=1
gpgcheck=0
[AppStream]
name=AppStream
baseurl=file://$mountPath/AppStream
enabled=1
gpgcheck=0"
      ;;
    OS3)
      write_file "Y" "/etc/yum.repos.d/local.repo" "[openEuler]
name=openEuler
baseurl=file://$mountPath
enabled=1
gpgcheck=1
gpgkey=file://$mountPath/RPM-GPG-KEY-openEuler"
      ;;
    esac
    # 打印 yum 配置文件内容
    cat /etc/yum.repos.d/local.repo
    ;;
  esac
}
#==============================================================#
#                        去除密码复杂度设置                       #
#==============================================================#
function remove_password_complexity() {
  # 切换用户时不显示 Last Login 信息
  sed -i 's/^session\+[[:space:]]\+include[[:space:]]\+postlogin/#&/g' /etc/pam.d/su
  # 去除密码复杂度设置
  case "$os_type" in
  "sles")
    sed -i 's/^password\+[[:space:]]\+requisite[[:space:]]\+pam_cracklib.so/#&/g' /etc/pam.d/common-password
    sed -i '/^password.*pam_unix\.so/s/use_authtok //' /etc/pam.d/common-password
    ;;
  "uos")
    sed -i 's/^password    requisite     pam_deepin_pw_check.so try_first_pass local_users_only retry=1 enforce_for_root authtok_type=/#&/' /etc/pam.d/system-auth
    sed -i 's/use_authtok$//' /etc/pam.d/system-auth
    ;;
  "kylin" | "openEuler" | "neokylin")
    sed -i 's/^password\+[[:space:]]\+requisite[[:space:]]\+pam_pwquality.so/#&/g' /etc/pam.d/system-auth
    sed -i 's/use_authtok$//' /etc/pam.d/system-auth
    ;;
  esac
  if [[ $oracle_install_mode = "rac" ]]; then
    # 避免ssh连接远程主机输入 yes/no
    if [[ $(grep -E -c "StrictHostKeyChecking no" /etc/ssh/ssh_config) = 0 ]]; then
      echo "StrictHostKeyChecking no" >>/etc/ssh/ssh_config
    fi
  fi
}
#==============================================================#
#                            杀进程                             #
#==============================================================#
function kill_process() {
  local process_name=$1
  pgrep -f "$process_name" | awk '{system("kill -9 "$1)}'
}
#==============================================================#
#                        级联删除文件夹内容                       #
#==============================================================#
function cascade_del_file() {
  local file_path=$1
  if check_file "$file_path" && (($(find "$file_path" -mindepth 1 | wc -l) > 0)); then
    find "$file_path" -mindepth 1 -delete
  fi
}
#==============================================================#
#                     清理 Oracle 安装旧环境                     #
#==============================================================#
function clean_old_envir() {
  # 关闭数据库进程
  kill_process "ora_pmon_"
  kill_process "ora_"
  # 关闭监听进程
  kill_process "tnslsnr"
  # 清理旧文件
  find /etc /opt /tmp -maxdepth 1 -type f -name "ora*" ! -name "oracle-release" -exec rm -f {} +
  rm -rf /etc/oracle/
  # 删除用户
  userdel -r oracle
  # 删除用户组
  groupdel oinstall
  groupdel dba
  groupdel oper
  groupdel dgdba
  groupdel backupdba
  groupdel kmdba
  groupdel racdba
  # 针对单机 ASM/RAC 模式
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    # 关闭集群进程
    kill_process "asm_pmon_"
    kill_process "crs_"
    # 关闭 ahf 进程
    kill_process "ahf"
    # 删除用户
    userdel -r grid
    # 删除用户组
    groupdel asmdba
    groupdel asmoper
    groupdel asmadmin
  fi
}
#==============================================================#
#                       检查和配置主节点                          #
#==============================================================#
function check_and_conf_local_node() {
  # 针对所有模式，包括单机/单机ASM 和 RAC 主节点
  case "$os_version" in
  # 6 版本的操作系统官方不支持 19C 以后的版本
  6)
    if [[ "$gi_version" =~ ^(19|21|23)$ ]] || [[ "$db_version" =~ ^(19|21|23)$ ]]; then
      color_printf red "Oracle 19C/21C/23ai 官方不支持 Linux 6 版本!"
    fi
    ;;
  7)
    if [[ "$gi_version" = "11" ]]; then
      # 7 版本操作系统安装 11GR2 RAC 存在 bug 18370031，必须上传 p18370031_112040_Linux-x86-64.zip 补丁包
      if ! check_file "$software_dir"/p18370031_112040_Linux-x86-64.zip; then
        color_printf red "在 Linux 7 安装 11GR2 RAC 时，必须应用补丁 18370031，请上传补丁包 p18370031_112040_Linux-x86-64.zip 到 $software_dir 目录下!"
      fi
    fi
    ;;
  8)
    # 8以后版本官方支持 11GR2 版本安装，但是需要安装补丁包
    if [[ "$db_version" = "11" ]]; then
      # 8以后版本官方支持 11GR2 RAC 版本数据库安装，需要安装 19.14 之后的 Grid 版本
      if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
        if [[ "$gi_version" = "19" ]]; then
          if [[ $grid_patch ]]; then
            # 如果传了 -gpa 参数，则提示 -gpa 参数对应的PSU补丁包必须大于 33509923
            if ((grid_patch < 33509923)); then
              color_printf red "Linux 8 安装 Oracle 11GR2 RAC 必须安装 Grid 补丁号为 19.14(33509923) 或者之后的 RU 版本，必须设置 [ -gpa ] 参数!"
            fi
          else
            color_printf red "Linux 8 安装 Oracle 11GR2 RAC 必须安装 Grid 补丁号为 19.14(33509923) 或者之后的 RU 版本，必须设置 [ -gpa ] 参数!"
          fi
        else
          color_printf red "Linux 8 安装 Oracle 11GR2 RAC 需要设置 [ -giv ] 参数，安装 19C（19.14之后版本） Grid!"
        fi
      fi
      # 11GR2 在 Linux8 安装必须要上传补丁包
      if [[ $oracle_patch ]]; then
        # 如果传了 -opa 参数，则提示 -opa 参数对应的PSU补丁包必须大于 33477185
        if ((oracle_patch < 33477185)); then
          color_printf red "Oracle 11GR2 在 Linux 8 版本安装必须安装补丁号为 33477185 或者之后的 PSU 版本，请正确设置 [ -opa ] 参数!"
        fi
      else
        color_printf red "Oracle 11GR2 在 Linux 8 版本安装必须安装补丁号为 33477185 或者之后的 PSU 版本，必须设置 [ -opa ] 参数!"
      fi
      # 检查 33991024 补丁是否上传
      if ! check_file "$software_dir"/p33991024_11204220118_Generic.zip; then
        color_printf red "Oracle 11GR2 在 Linux 8 版本安装需要上传补丁包：p33991024_11204220118_Generic.zip!"
      fi
    fi
    ;;
  9)
    if [[ "$db_version" =~ ^(11|12)$ ]]; then
      color_printf red "Oracle 11G/12C 官方不支持 Linux 9 版本!"
    fi
    if [[ "$os_type" = "fedora" ]]; then
      # Fedora 9 不管 GI 和 DB 都需要上传 compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm
      if ! check_file "$software_dir"/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm; then
        color_printf red "本脚本在 Fedora(34 以上版本) 安装 19C/21C 需要上传 compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm 到 $software_dir 目录下！
              下载地址：https://rpmfind.net/linux/fedora/linux/development/rawhide/Everything/x86_64/os/Packages/c/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm"
      fi
    fi
    ;;
  esac
  # 针对 RAC 和 单机ASM
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    # 安装 12CR2 RAC 存在 bug，必须上传 GRID RU 补丁包
    if [[ "$gi_version" = "12" ]]; then
      if [[ $grid_patch ]]; then
        # 如果传了 -gpa 参数，则提示 -gpa 参数对应的PSU补丁包必须大于 28828733
        if ((grid_patch < 28828733)); then
          color_printf red "本脚本安装 12CR2 RAC/STANDALONE 时，必须安装 Grid PSU 补丁号为 12.2.0.1.190115(28828733) 或者之后的 PSU 版本，请使用参数 [ -gpa ] 安装补丁!"
        fi
      else
        color_printf red "本脚本安装 12CR2 RAC/STANDALONE 时，必须先应用 Grid PSU 补丁，否则无法进行安装，请使用参数 [ -gpa ] 安装补丁!"
      fi
    fi
    # 清除 ASM 磁盘头以及获取 UUID
    conf_disk_uuid
  fi
  # 判断不同安装模式下参数个数
  case "$oracle_install_mode" in
  "single")
    # 单实例必传参数检查
    if [[ -z $local_ifname ]]; then
      color_printf red "Oracle 单机数据库必须设置参数：-lf，请运行命令 'sh OracleShellInstall --help' 以获取更多帮助信息!"
    fi
    HOSTNAME=$hostname
    oracle_sids=()
    for ((i = 0; i < ${#db_names[@]}; i++)); do
      oracle_sids+=("${db_names[i]}" "${db_names[i]}")
    done
    ;;
  "standalone")
    # 单机ASM必传参数检查
    if [[ -z $local_ifname || -z $data_base_disk ]]; then
      color_printf red "Oracle 单机 ASM 模式必须设置以下参数: -lf,-dd，否则无法进行安装。可以使用 'sh OracleShellInstall --help' 查看脚本的帮助文档!"
    fi
    HOSTNAME=$hostname
    oracle_sids=()
    for ((i = 0; i < ${#db_names[@]}; i++)); do
      oracle_sids+=("${db_names[i]}" "${db_names[i]}")
    done
    grid_sid=+ASM
    ;;
  "rac")
    # 检查所有IP是否存在重复项
    isunique_ip
    # 检查主节点 local_ip 是否为 rac 公网IP的第一个IP
    if [[ "$local_ip" != "${rac_public_ips[0]}" ]]; then
      color_printf red "参数 [ -ri ] 的值：${rac_public_ips[0]} 第一个 IP 不是主节点的 IP，请检查参数！"
    fi
    # 主节点检查RAC是否缺少必传参数
    if [[ -z $hostname || -z $rac_hostname || -z $root_passwd || -z $local_ifname || -z $rac_public_ip || -z $rac_virtual_ip || -z $rac_priv_ifname || -z $rac_scan_ip || -z $ocr_base_disk || -z $data_base_disk ]]; then
      color_printf red "安装 RAC 模式必须设置以下参数: -n,-hn,-rp,-lf,-ri,-vi,-pf,-si,-od,-dd，否则无法进行安装。可以使用 'sh OracleShellInstall --help' 查看脚本的帮助文档!"
    fi
    if [[ -z $cluster_name ]]; then
      if ((${#hostname} > 7)); then
        color_printf red "RAC 参数 [ -cn ] 未配置，但是参数 [ -n ] 的值：$hostname 已超过 7 位，组成的集群名称将超过 15 位，不符合官方要求，请检查!"
      else
        cluster_name=$hostname-cluster
      fi
    else
      if ((${#cluster_name} > 15)); then
        color_printf red "RAC 参数 [ -cn ] 集群名称：$cluster_name 已超过 15 位，不符合官方要求，请检查!"
      fi
    fi
    if [[ $dns = "Y" ]]; then
      if [[ -z $dns_name || -z $dns_ip ]]; then
        color_printf red "RAC 参数 [ -dns ] 已传参，但是级联参数 [ -dnsn ] 和 [ -dnsi ] 没有传参，请检查!"
      fi
    else
      if ((scan_count > 1)); then
        color_printf red "RAC 参数 [ -si ] SCAN IP 数量超过 1 个，需要配置 DNS，但是配置 DNS 参数 [ -dns ] 没有传参，请检查!"
      fi
    fi
    execute_and_log "配置 root 用户互信" root_ssh_trust
    # 检查主机时间是否一致，相差超过10s则更新其他主机节点为本节点时间
    execute_and_log "正在检查并更新 RAC 主机时间" check_and_update_date
    # 针对主节点，生成其他节点参数并且分发shell脚本
    # 创建其他节点的脚本执行命令，将内容保存在变量中
    local node_cmd="sh $software_dir/OracleShellInstall -lf $local_ifname -pf $rac_priv_ifname -ri $rac_public_ip \
              -vi $rac_virtual_ip -n $hostname -hn $rac_hostname -o $db_name -d $env_base_dir -rp $root_passwd \
              -gp $grid_passwd -op $oracle_passwd -mp $multipath -dns $dns -si $rac_scan_ip \
              -adc $asm_disk_conf -or $ocr_redun -dr $data_redun -install_mode $oracle_install_mode \
              -dbv $db_version -giv $gi_version -gui $isgui -iso $iso -vbox $virtualbox -sn $scan_name"
    # 判断是否存在 ASM 磁盘配置
    if [[ $asm_disk_conf = "N" ]]; then
      node_cmd+=" -od $ocr_base_disk -dd $data_base_disk"
    else
      node_cmd+=" -od $ocr_disk_uuid -dd $data_disk_uuid"
    fi
    # 判断是否存在 ARCH ASM 磁盘组
    if [[ $arch_base_disk ]]; then
      if [[ $asm_disk_conf = "N" ]]; then
        node_cmd+=" -an $arch_asm_group -ad $data_base_disk -ar $arch_redun"
      else
        node_cmd+=" -an $arch_asm_group -ad $arch_disk_uuid -ar $arch_redun"
      fi
    fi
    # 判断是否需要时间服务器
    if [[ $timeserver_ip ]]; then
      node_cmd+=" -tsi $timeserver_ip"
    fi
    # 判断是否需要配置DNS
    if [[ $dns_ip && $dns_name ]]; then
      node_cmd+=" -dnsn $dns_name -dnsi $dns_ip"
    fi
    # 将命令以重定向的方式保存到文件中
    echo -n "$node_cmd" >"$software_dir"/racnode.sh
    # 发送脚本和安装程序到其他节点
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      # ssh 连接到其他节点并创建目录
      ssh -q "${rac_public_ips[i]}" "[[ -f $software_dir || -d $software_dir ]] && rm -rf $software_dir ; mkdir -p $software_dir"
      # 将脚本发送到其他节点
      scp -q "$software_dir"/racnode.sh "${rac_public_ips[i]}":"$software_dir"
      # 将节点编号写入脚本中
      ssh -q "${rac_public_ips[i]}" "echo -n ' -node $((i + 1))' >> $software_dir/racnode.sh"
      # 将安装程序发送到其他节点
      scp -q "$software_dir"/OracleShellInstall "${rac_public_ips[i]}":"$software_dir"
      # 拷贝 Grid OPatch 到其他节点
      if check_file "$grid_opatch_name"; then
        scp -q "$grid_opatch_name" "${rac_public_ips[i]}":"$software_dir"
      fi
      # 如果 GI 和 DB 版本不一致，则需要分别拷贝 OPatch 补丁包
      if [[ "$gi_version" != "$db_version" ]]; then
        # 拷贝 DB OPatch 到其他节点
        if check_file "$db_opatch_name"; then
          scp -q "$db_opatch_name" "${rac_public_ips[i]}":"$software_dir"
        fi
      fi
      ## openEuler 22.03 安装 12CR2 报错 jskm.c:(.text+0x4081): undefined reference to `stat'，eobtl.c:(.text+0x3ba): undefined reference to `fstat' 解决方案
      # openEuler 22.02 拷贝 compat-glibc-2.12-4.el7.centos.x86_64.rpm 到其他节点
      case "$os_type-$os_version" in
      "openEuler-8")
        # 针对 openEuler 20.03 非 LTS SP4 版本
        if check_file "$software_dir"/glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm; then
          scp -q "$software_dir"/glibc-compat-2.17-2.28-98.oe2003sp4.x86_64.rpm "${rac_public_ips[i]}":"$software_dir"
        fi
        # 针对 openEuler 21 版本
        if check_file "/usr/lib64/libpthread_nonshared.a"; then
          scp -q "$software_dir"/libpthread_nonshared.a "${rac_public_ips[i]}":"$software_dir"
        fi
        # 针对 openEuler 22.03 LTS SP3 安装 12C RAC 版本
        if [[ "$gi_version" = 12 ]]; then
          if check_file "$software_dir"/compat-glibc-2.12-4.el7.centos.x86_64.rpm; then
            scp -q "$software_dir"/compat-glibc-2.12-4.el7.centos.x86_64.rpm "${rac_public_ips[i]}":"$software_dir"
          fi
        fi
        ;;
      "fedora-9")
        # Fedora 9 拷贝 compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm 到其他节点
        if check_file "$software_dir"/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm; then
          scp -q "$software_dir"/compat-libpthread-nonshared-2.39.9000-10.fc41.x86_64.rpm "${rac_public_ips[i]}":"$software_dir"
        fi
        ;;
      "anolis-7")
        # 龙蜥 7.9 拷贝 compat-libcap1-1.10-7.el7.x86_64.rpm 到其他节点
        if check_file "$software_dir"/compat-libcap1-1.10-7.el7.x86_64.rpm; then
          scp -q "$software_dir"/compat-libcap1-1.10-7.el7.x86_64.rpm "${rac_public_ips[i]}":"$software_dir"
        fi
        if check_file "$software_dir"/libc-2.17.so; then
          scp -q "$software_dir"/libc-2.17.so "${rac_public_ips[i]}":"$software_dir"
        fi
        ;;
      esac
      # 如果是 RAC 安装并且存在多个节点，则将 rlwrap 复制到其他节点上
      if ls "$software_dir"/rlwrap-*.gz 1>/dev/null 2>&1; then
        find "$software_dir" -name "rlwrap-*.gz" -exec scp -q {} "${rac_public_ips[i]}":"$software_dir" \;
      fi
    done
    # 删除本地脚本
    if check_file "$software_dir"/racnode.sh; then
      rm -rf "$software_dir"/racnode.sh
    fi
    ;;
  esac
}
#==============================================================#
#                    检查并更新 RAC 主机时间                      #
#==============================================================#
function check_and_update_date() {
  log_print "检查并更新 RAC 主机时间"
  color_printf green "当前主机时间: $(date)"
  echo
  # 远程主机的IP地址或主机名
  for ((j = 1; j < ${#rac_public_ips[@]}; j++)); do
    local host=${rac_public_ips[j]}
    # 比较时间差异的阈值（秒）
    local time_diff_threshold=10
    # 获取当前主机的时间
    local local_time
    local_time=$(date +%s)
    # 获取远程主机的时间
    local remote_time
    remote_time=$(ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no "${host}" "date +%s")
    # 计算时间差
    local time_diff=$((remote_time - local_time))
    # 将时间差转换为绝对值
    time_diff=${time_diff#-}
    # 检查时间是否在阈值内
    if ((time_diff > time_diff_threshold)); then
      color_printf blue "目标主机 (${host}) 时间误差: ${time_diff} 秒超过 10 秒，正在自动调整目标主机时间："
      # 通过 SSH 将远程主机时间调整为当前主机时间
      ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no "${host}" "date -s '@${local_time}'"
      echo
      color_printf blue "主机 (${host}) 时间已经更新。"
    else
      color_printf blue "目标主机 (${host}) 时间误差: ${time_diff} 秒小于 10 秒，无需调整！"
    fi
  done
}
#==============================================================#
#                      ROOT SSH Trust                          #
#==============================================================#
function root_ssh_trust() {
  #  对所有未互信的IP进行互信配置
  if [[ $(ssh_check root "${ssh_ips[@]}") = "false" ]]; then
    log_print "配置 root 用户互信"
    # 主节点 root ssh互信，只需要公网IP
    ssh_trust root "$root_passwd" "${ssh_ips[@]}"
    # 互信完成后检查互信是否成功
    if [[ $(ssh_check root "${ssh_ips[@]}") = "false" ]]; then
      color_printf red "root 用户互信失败，请检查参数 [ -rp ] 传入的 root 密码： $root_passwd 是否正确！"
    fi
  fi
}
#==============================================================#
#                     检查和配置 RAC 所有节点                     #
#==============================================================#
function check_and_conf_all_node() {
  # 存放集群节点数组
  declare -a clusternodes_array
  # 其他节点获取ASM磁盘UUID
  if [[ $asm_disk_conf = "Y" && $node_num != 1 ]]; then
    # 通过主节点传过来的 ocr_base_disk,data_base_disk.arch_base_disk 参数实际为UUID
    ocr_disk_uuid=$ocr_base_disk
    data_disk_uuid=$data_base_disk
    [[ $arch_base_disk ]] && arch_disk_uuid=$arch_base_disk
  fi
  # 所有节点的local_ip都是主节点IP
  local_ip=${rac_public_ips[0]}
  # 获取ASM实例和DB实例名称
  grid_sid=+ASM$node_num
  # 获取实例名
  for ((i = 0; i < ${#db_names[@]}; i++)); do
    # 将数组元素与对应索引的 oracle_sids 元素连接，并保存到新数组中
    oracle_sids+=("${db_names[i]}" "${db_names[i]}$node_num")
  done
  # 获取 clusternodes
  for ((i = 0; i < ${#rac_hostnames[@]}; i++)); do
    if [[ "$db_version" = "11" ]]; then
      # 11GR2 RAC 安装主机名不能有大写字符
      if [[ "${rac_hostnames[i]}" = *[[:upper:]]* ]]; then
        echo
        color_printf red "11GR2 RAC 安装主机名不能包含大写字母，请检查主机名: ${rac_hostnames[i]}!"
      fi
    fi
    # rac主机名和vip名写入clusternodes数组
    if [[ "$db_version" = "12" ]]; then
      clusternodes_array+=("${rac_hostnames[i]}:${rac_hostnames[i]}-vip:HUB")
    else
      clusternodes_array+=("${rac_hostnames[i]}:${rac_hostnames[i]}-vip")
    fi
  done
  clusternodes=$(printf "%s," "${clusternodes_array[@]}")
  # 去掉最后一个逗号
  clusternodes=${clusternodes%?}
  # rac节点主机名，当数组下标加1等于当前节点号，则配置主机名为当前节点号对应主机名
  HOSTNAME=${rac_hostnames[$((node_num - 1))]}
  # 获取所有节点心跳网卡对应的心跳IP地址
  # 获取子网地址
  local local_ipmask
  local_ipmask=$(ip route show dev "$local_ifname" | awk '/kernel/ && /proto/ {print $1}' | cut -d'/' -f1 | head -n 1)
  networkinterfacelist_array=("$local_ifname:$local_ipmask:1")
  # 循环遍历所有节点和网卡组合
  for public_ip in "${rac_public_ips[@]}"; do
    for priv_ifname in "${rac_priv_ifnames[@]}"; do
      # 使用ssh免密连接获取当前节点和网卡对应的心跳IP
      local priv_ip
      priv_ip=$(ssh -q "$public_ip" ip addr show dev "$priv_ifname" | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
      # 校验心跳IP地址是否合规
      if check_ip "$priv_ip"; then
        check_ip_connectivity "$priv_ip"
      else
        color_printf red "RAC 节点 $public_ip 参数 [ -pf ] 的网卡名称：$priv_ifname 对应的 IP：$priv_ip 不合规，请检查!"
      fi
      # 只需要主节点网卡信息即可
      if [[ $public_ip = "$local_ip" ]]; then
        # 获取子网地址
        local rac_priv_ipmask
        rac_priv_ipmask=$(ip route show dev "$priv_ifname" | awk '/kernel/ && /proto/ {print $1}' | cut -d'/' -f1 | head -n 1)
        # rac主机名和vip名写入clusternodes数组
        if [[ "$gi_version" = "11" ]]; then
          networkinterfacelist_array+=("$priv_ifname:$rac_priv_ipmask:2")
        else
          networkinterfacelist_array+=("$priv_ifname:$rac_priv_ipmask:5")
        fi
      fi
      # 将心跳IP存放到对应的节点数组中
      node_name="${public_ip}_${priv_ifname}"
      rac_priv_ips["$node_name"]=$priv_ip
      # 将 node_name 添加到 rac_priv_ifnames_sorted 数组中
      rac_priv_ifnames_sorted+=("$node_name")
    done
  done
  networkinterfacelist=$(printf "%s," "${networkinterfacelist_array[@]}")
  # 去掉最后一个逗号
  networkinterfacelist=${networkinterfacelist%?}
}
#==============================================================#
#                         打印环境信息                           #
#==============================================================#
function print_sysinfo() {
  log_print "打印系统信息"
  print_cpu_info() {
    # 保存当前语言环境
    local current_lang=$LANG
    # 切换到英文环境
    export LANG="en_US.UTF-8"
    # 定义关联数组的键的顺序
    local keys=("A" "B" "C" "D")
    # 保存要提取的信息的关键词
    declare -A keywords=(
      ["A"]="$(grep </proc/cpuinfo "model name" | head -n 1 | awk -F ': ' '{print $2}')"
      ["A_DESC"]="型号名称                "
      ["B"]="$(grep </proc/cpuinfo "physical id" | sort | uniq | wc -l)"
      ["B_DESC"]="物理 CPU 个数           "
      ["C"]="$(grep </proc/cpuinfo "core id" | sort -u | wc -l)"
      ["C_DESC"]="每个物理 CPU 的逻辑核数 "
      ["D"]="$(grep -c "processor" /proc/cpuinfo)"
      ["D_DESC"]="系统的 CPU 线程数       "
    )
    # 循环提取信息并按顺序打印
    for key in "${keys[@]}"; do
      local desc="${keywords[${key}_DESC]}"
      local value="${keywords[$key]}"
      color_printf white "$desc ：$value"
    done
    # 恢复原来的语言环境
    export LANG="$current_lang"
  }
  ## 服务器时间
  color_printf blue "服务器时间: "
  date
  ## 操作系统版本
  echo
  color_printf blue "操作系统版本: "
  if check_file /etc/os-release; then
    cat /etc/os-release
  elif check_file /etc/system-release; then
    cat /etc/system-release
  elif check_file /etc/redhat-release; then
    cat /etc/redhat-release
  fi
  ## 内核信息
  echo
  color_printf blue "内核信息: "
  cat /proc/version
  ## cpu信息
  echo
  color_printf blue "cpu信息: "
  print_cpu_info
  ## 内存信息
  echo
  color_printf blue "内存信息: "
  free -m
  ## 挂载信息
  echo
  color_printf blue "挂载信息: "
  grep </etc/fstab -E -v '^#|^*#|^$'
  ## 目录信息
  echo
  color_printf blue "目录信息: "
  df -h
}
#==============================================================#
#                         configure swap                       #
#==============================================================#
# 定义名为 conf_swap 的函数，用于配置交换空间
function conf_swap() {
  # 获取swap大小
  local swap_total
  swap_total=$(awk '/^SwapTotal:/ { print $2; }' /proc/meminfo)
  # 确定需要的交换空间大小
  local swap_need
  ((swap_need = os_memory_total > 16777216 ? 16777216 : os_memory_total > 2097152 ? os_memory_total : os_memory_total * 3 / 2))
  # 计算额外需要的交换空间大小
  ((swap_count = swap_need - swap_total))
  # 如果需要额外交换空间，则创建并启用 swap
  if ((swap_count > 0)); then
    # 判断 /etc/fstab 文件中是否存在 /swapfile 文件这行，如果没有则添加
    if ! grep -q '/swapfile swap swap defaults 0 0' /etc/fstab; then
      log_print "配置 SWAP 交换空间"
      if check_file "/swapfile"; then
        rm -rf /swapfile
      fi
      # 创建指定大小的空文件 /swapfile，并将其格式化为交换分区
      dd if=/dev/zero of=/swapfile bs=1K count=$swap_count
      # 设置文件权限为 0600
      chmod 600 /swapfile
      # 格式化文件为 Swap 分区
      mkswap /swapfile
      # 启用 Swap 分区
      swapon /swapfile
      # 将 Swap 分区信息添加到 /etc/fstab 文件中，以便系统重启后自动加载
      write_file "N" "/etc/fstab" "/swapfile swap swap defaults 0 0"
      free -m
    fi
  fi
}
#==============================================================#
#                         configure firewall                   #
#==============================================================#
function conf_firewall() {
  log_print "禁用防火墙"
  # CentOS/RHEL 6
  case "$os_version" in
  "6")
    chkconfig iptables off
    chkconfig ip6tables off
    if service iptables status >/dev/null; then
      service iptables stop
      service ip6tables stop
      service iptables status
    else
      color_printf blue "防火墙服务未启动，无需禁用。"
    fi
    ;;
  *)
    # sles 12 版本
    if [[ $os_type = "sles" && "$os_version" = "7" ]]; then
      service SuSEfirewall2 stop
      SuSEfirewall2 off
      service SuSEfirewall2 status
    else
      # 包含 sles 15 版本
      systemctl disable firewalld.service -q
      if systemctl is-active firewalld.service >/dev/null; then
        systemctl stop firewalld.service
        systemctl status firewalld
      else
        color_printf blue "防火墙服务未启动，无需禁用。"
      fi
    fi
    ;;
  esac
}
#==============================================================#
#                         禁用 Selinux                          #
#==============================================================#
function conf_selinux() {
  log_print "禁用 SELinux"
  # 检查 SELinux 是否已经被禁用
  if [[ $(getenforce) != "Disabled" ]]; then
    /usr/sbin/setenforce 0 # 临时关闭 SELinux
  fi
  # 更新配置文件中的 SELINUX 配置
  sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
  # 记录更新后的 SELINUX 配置
  sestatus
}
#==============================================================#
#                       配置 nsysctl.conf                       #
#==============================================================#
function conf_nsysctl() {
  # 检查是否已经存在 NOZEROCONF=yes 的配置选项，如果不存在则添加之
  if ! grep -q "^NOZEROCONF=yes$" /etc/sysconfig/network; then
    log_print "配置 nsysctl.conf"
    # 备份原始配置文件
    bak_file /etc/sysconfig/network
    # 追加 NOZEROCONF=yes 配置选项
    write_file "N" "/etc/sysconfig/network" "NOZEROCONF=yes"
    # 记录更改前后的差异到日志中
    grep -v "^\s*\(#\|$\)" /etc/sysconfig/network
  fi
}
#==============================================================#
#                         GUI Install                          #
#==============================================================#
function install_gui() {
  color_printf green "正在安装图形化界面："
  # 如果需要图形界面，则安装 GUI 软件包
  if [[ "$os_type" = "rhel" ]]; then
    case "$os_version" in
    "6")
      install_packages_if_not_present "tigervnc-server"
      yum groupinstall -y -q "Server with GUI" --skip-broken >/dev/null 2>&1
      ;;
    "7" | "8" | "9")
      install_packages_if_not_present "nautilus-open-terminal" "tigervnc-server"
      yum groupinstall -y -q "X Window System" "Desktop" --skip-broken >/dev/null 2>&1
      ;;
    esac
  fi
}
#==============================================================#
#                         RPM Install                          #
#==============================================================#
# 安装软件包（如果未安装）
function install_packages_if_not_present() {
  for package in "$@"; do
    if ! rpm -q "$package" >/dev/null; then
      if [[ "$os_type" = "sles" ]]; then
        zypper in -y "$package" >/dev/null 2>&1
      else
        yum install -y -q "$package" --skip-broken >/dev/null 2>&1
      fi
    fi
  done
}
#==============================================================#
#                          安装 rpm                            #
#==============================================================#
function rpm_install() {
  log_print "获取安装所需依赖包"
  if [[ $isgui = "Y" ]]; then
    install_gui
  fi
  # 安装软件包
  local packages=(
    bc
    binutils
    glibc
    glibc-devel
    make
    net-tools
    smartmontools
    sysstat
    tar
    unzip
  )
  case "$os_type" in
  "openEuler" | "kylin")
    packages+=(
      e2fsprogs
      elfutils
      elfutils-devel
      fontconfig-devel
      gcc
      gcc-c++
      ksh
      libX11
      libXau
      libXi
      libXrender
      libXrender-devel
      libXtst
      libaio
      libaio-devel
      libgcc
      libstdc++
      libstdc++-devel
      libxcb
      nfs-utils
      policycoreutils
      policycoreutils-python-utils
      psmisc
      rdma-core
      readline
      readline-devel
      libcap-devel
      xorg-x11-utils
      xorg-x11-xauth
    )
    case "$os_type" in
    "openEuler")
      packages+=(
        libnsl
        libnsl2-devel
        glibc-compat-2.17
      )
      ;;
    esac
    ;;
  "sles")
    packages+=(
      bc
      binutils
      gcc
      glibc
      libX11-6
      libXau6
      libXrender1
      libXtst6
      libaio-devel
      libaio1
      libcap-ng-utils
      libcap-ng0
      libcap-progs
      libcap1
      libcap2
      libgcc_s1
      libpcap1
      libpcre1
      libpng16-16
      libstdc++6
      libtiff5
      mksh
      nfs-kernel-server
      pixz
      rdma-core
      xorg-x11
      xorg-x11-Xvnc
      xorg-x11-driver-video
      xorg-x11-essentials
      xorg-x11-fonts
      xorg-x11-fonts-core
      xorg-x11-libs
      xorg-x11-server
      xorg-x11-server-extra
      xz
    )
    case "$os_version" in
    # 实际是 sles 12，没有 readline-devel 包，不支持 rlwrap
    "7")
      packages+=(
        gcc-c++
        gcc-info
        gcc-locale
        gcc48
        gcc48-c++
        gcc48-info
        gcc48-locale
        libelf-devel
        libgfortran3
        libjpeg-turbo
        libjpeg62
        libjpeg62-turbo
        libpcre16-0
        libstdc++-devel
        libstdc++48-devel
      )
      ;;
    # 实际是 sles 15
    "8")
      packages+=(
        insserv-compat
        libXext-devel
        libXext6
        libXi-devel
        libXi6
        libXrender-devel
        libelf1
        libgfortran4
        libjpeg8
        rdma-core-devel
        libreadline7
        readline-devel
      )
      ;;
    esac
    ;;
  "Red" | "CentOS" | "rhel" | "centos" | "ol" | "rocky" | "anolis" | "uos" | "neokylin")
    # 安装软件包
    packages+=(
      gcc
      gcc-c++
      ksh
      libX11
      libXau
      libXi
      libXrender
      libXtst
      libaio
      libgcc
      libstdc++
      libxcb
      nfs-utils
      readline
      readline-devel
    )
    # 根据不同的操作系统版本安装不同的软件包
    case "$os_version" in
    "6")
      packages+=(
        compat-libcap1
        e2fsprogs
        e2fsprogs-libs
        libXrender-devel
        libaio-devel
        libstdc++-devel
      )
      ;;
    "7")
      packages+=(
        compat-libcap1
        elfutils-libelf
        elfutils-libelf-devel
        fontconfig-devel
        libXrender-devel
        libaio-devel
        libstdc++-devel
        libvirt-libs
        policycoreutils
        policycoreutils-python
        python
        python-configshell
        python-rtslib
        python-six
        targetcli
      )
      ;;
    "8")
      packages+=(
        compat-openssl10
        elfutils-libelf
        elfutils-libelf-devel
        fontconfig-devel
        libaio-devel
        libibverbs
        libnsl
        libnsl2
        librdmacm
        libstdc++-devel
        libvirt-libs
        policycoreutils
        policycoreutils-python-utils
      )
      ;;
    "9")
      packages+=(
        compat-openssl11
        elfutils-libelf
        fontconfig
        libasan
        liblsan
        libxcrypt-compat
        libibverbs
        libnsl
        librdmacm
        libvirt-libs
        policycoreutils
        policycoreutils-python-utils
        glibc-headers
        libnsl2
      )
      ;;
    esac
    ;;
  esac
  local packages_display
  packages_display=$(printf '%s \\\n' "${packages[@]}" | sed '$s/\\$//')
  color_printf blue "$packages_display"
  log_print "静默安装依赖包"
  install_packages_if_not_present "${packages[@]}"
  color_printf blue "检查依赖包安装情况："
  rpm -q "${packages[@]}"
}
#==============================================================#
#                           配置主机名                           #
#==============================================================#
function conf_hostname() {
  log_print "配置主机名"
  if [[ "$os_type" = "sles" ]]; then
    local hostname_file="/etc/hostname"
  else
    case "$os_version" in
    "6")
      local hostname_file="/etc/sysconfig/network"
      ;;
    *)
      local hostname_file="/etc/hostname"
      ;;
    esac
  fi
  # 检查新主机名是否已设置，并且不存在于相应的主机名文件中
  if ! grep -Fxq "$HOSTNAME" "$hostname_file"; then
    # 备份主机名文件
    bak_file "$hostname_file"
    # 设置新主机名
    case "$os_version" in
    "6")
      /bin/hostname "$HOSTNAME"
      sysctl kernel.hostname="$HOSTNAME"
      write_file "Y" "/proc/sys/kernel/hostname" "$HOSTNAME"
      sed -i "s/^HOSTNAME=.*/HOSTNAME=$HOSTNAME/" "$hostname_file"
      # 记录日志
      hostname
      ;;
    *)
      # 包含了 sles 版本
      /usr/bin/hostnamectl set-hostname "$HOSTNAME"
      write_file "Y" "$hostname_file" "$HOSTNAME"
      # 记录日志
      hostnamectl
      ;;
    esac
  else
    cat "$hostname_file"
  fi
}
#==============================================================#
#                      配置 /etc/hosts 文件                     #
#==============================================================#
function conf_hosts() {
  log_print "配置 /etc/hosts 文件" >>"$oracleinstalllog"
  # 备份 /etc/hosts 文件
  bak_file /etc/hosts
  # 配置 RAC hosts 文件
  if [[ "$oracle_install_mode" = "rac" ]]; then
    # 将集群节点信息写入 hosts 文件中
    write_file "N" "/etc/hosts" "
## OracleBegin"
    local node
    for i in "${!rac_hostnames[@]}"; do
      ((node = i + 1))
      local priv_count=0
      # 将PublicIP和主机名写入互信数组
      hosts_array+=("${rac_public_ips[i]}" "${rac_hostnames[i]}")
      write_file "N" "/etc/hosts" "
## RAC$node IP's: ${rac_hostnames[i]}

## RAC$node Public IP
${rac_public_ips[i]} ${rac_hostnames[i]}
## RAC$node Virtual IP
${rac_virtual_ips[i]} ${rac_hostnames[i]}-vip
## RAC$node Private IP"
      # 遍历心跳IP排序数组，按顺序输出心跳地址
      for node_name in "${rac_priv_ifnames_sorted[@]}"; do
        # 遍历心跳关联数组列表，找到属于当前节点的私有 IP，并将其写入 hosts 文件中
        for ifname in "${!rac_priv_ips[@]}"; do
          # 心跳IP按顺序输出
          if [[ $ifname = *"$node_name"* ]]; then
            # 用公网IP地址来匹配心跳
            if [[ $ifname = *"${rac_public_ips[i]}"* ]]; then
              ((priv_count++))
              # 根据私有 IP 数量添加相应的后缀，用于区分不同的私有 IP
              if ((priv_count > 1)); then
                # 将心跳IP和心跳主机名写入互信数组
                hosts_array+=("${rac_priv_ips[$ifname]}" "${rac_hostnames[i]}-priv1")
                write_file "N" "/etc/hosts" "${rac_priv_ips[$ifname]} ${rac_hostnames[i]}-priv1"
              else
                # 将心跳IP和心跳主机名写入互信数组
                hosts_array+=("${rac_priv_ips[$ifname]}" "${rac_hostnames[i]}-priv")
                write_file "N" "/etc/hosts" "${rac_priv_ips[$ifname]} ${rac_hostnames[i]}-priv"
              fi
            fi
          fi
        done
      done
    done
    # 如果有 SCAN IP，则将其写入到 hosts 文件中
    if ((scan_count == 1)); then
      write_file "N" "/etc/hosts" "
## SCAN IP
${rac_scan_ips[0]} $scan_name"
    fi
  else
    # 配置单实例 hosts 文件
    # sles 不需要配置主机名，自动配置
    if [[ "$os_type" != "sles" ]]; then
      write_file "N" "/etc/hosts" "
## OracleBegin
## Public IP
$local_ip	$hostname"
    fi
  fi
  grep -v "^\s*\(#\|$\)" /etc/hosts >>"$oracleinstalllog" 2>&1 &
}
#==============================================================#
#                        创建用户和组                            #
#==============================================================#
function create_users_groups() {
  log_print "创建用户和组"
  # 定义标记空值标记
  local flag
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    flag="true"
  fi
  # 定义os用户组
  local group_groups=("oinstall:54321" "dba:54322" "oper:54323" "backupdba:54324" "dgdba:54325" "kmdba:54326" "racdba:54330" ${flag:+"asmdba:54327"} ${flag:+"asmoper:54328"} ${flag:+"asmadmin:54329"})
  local user_groups=(oracle ${flag:+grid})
  # 定义os用户密码数组
  declare -A passwd_groups=(
    [oracle]=$oracle_passwd
    [grid]=$grid_passwd
  )
  # 循环创建组
  for group in "${group_groups[@]}"; do
    local groupname=${group%%:*}
    local gid=${group##*:}
    # 如果不存在，则创建新组
    if ! grep -E -q "^$groupname:" /etc/group; then
      groupadd -g "$gid" "$groupname"
    fi
  done
  for group in "${user_groups[@]}"; do
    local uid
    uid=$([[ $group = "oracle" ]] && echo "54321" || echo "11012")
    local primary_group=oinstall
    local other_groups=dba,oper,backupdba,dgdba,kmdba,racdba${flag:+",asmdba"}${flag:+",asmoper"}${flag:+",asmadmin"}
    if ! id -u "$group" >/dev/null 2>&1; then
      useradd -u "$uid" -g $primary_group -G "$other_groups" "$group"
    else
      usermod -g $primary_group -G "$other_groups" "$group"
    fi
    # 为用户设置密码
    echo "$group:${passwd_groups[$group]}" | chpasswd
    # 记录日志，输出创建的grid和oracle用户信息
    color_printf blue "$group 用户："
    id "$group"
    echo
  done
}
#==============================================================#
#                         创建安装目录                           #
#==============================================================#
function create_dir() {
  # 清理安装文件
  cascade_del_file "$env_base_dir"
  cascade_del_file "$env_oracle_home"
  cascade_del_file "$oradata_dir"
  # 创建 Oracle 环境所需目录
  mkdir -p "$env_oracle_home" "$env_oracle_inven" "$backup_dir" "$scripts_dir"
  # 如果安装模式是 "RAC" (Real Application Clusters)
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    cascade_del_file "$env_grid_home"
    # 创建额外的目录，并设置属性
    mkdir -p "$env_grid_base" "$env_grid_home" &&
      chown -R grid:oinstall {$env_base_dir,"$env_grid_home","$env_oracle_inven"} &&
      chown -R oracle:oinstall {"$scripts_dir","$backup_dir","$env_oracle_base"}
  else
    # 在 oradata 目录内创建 archivelog 目录，并设置属性
    mkdir -p $oradata_dir/archivelog &&
      chown -R oracle:oinstall {"$scripts_dir","$oradata_dir","$backup_dir","$env_base_dir"}
  fi
  chmod -R 775 "$env_base_dir"
}
#==============================================================#
#                        配置 avahi deamon                      #
#==============================================================#
# 安装并配置 Avahi 服务
function conf_avahi() {
  log_print "配置 Avahi-daemon 服务"
  install_packages_if_not_present "avahi"
  case "$os_version" in
  "6")
    # 如果 avahi-daemon 已经启用，则停止并禁用它
    if (($(chkconfig --list | grep avahi-daemon | grep -c '3:on') > 0)); then
      service avahi-daemon stop
      chkconfig avahi-daemon off
    fi
    # 记录 avahi-daemon 状态
    service avahi-daemon status
    ;;
  *)
    # 停止 avahi-daemon 服务，并使用 "pgrep" 命令杀死任何残留进程
    if (($(systemctl status avahi-daemon | grep -c running) > 0)); then
      systemctl stop avahi-daemon.socket >/dev/null 2>&1
      systemctl stop avahi-daemon.service >/dev/null 2>&1
      kill_process "avahi-daemon"

      # 禁用 avahi-daemon 服务
      systemctl disable avahi-daemon.service >/dev/null 2>&1
      systemctl disable avahi-daemon.socket >/dev/null 2>&1
    fi
    # 记录 avahi-daemon 状态
    systemctl status avahi-daemon
    ;;
  esac
}
#==============================================================#
#               配置 THP && numa && ASM I/O scheduler           #
#==============================================================#
function set_kernel_option() {
  local option="$1"
  if grubby --info=ALL | grep -q "$option"; then
    return 0
  fi
  grubby --update-kernel=ALL --args="$option"
}
function conf_grub() {
  log_print "配置透明大页 && NUMA && 磁盘 IO 调度器"
  if [[ "$os_type" = "sles" ]]; then
    sed -i 's/quiet/quiet transparent_hugepage=never numa=off tsx=off elevator=deadline/' /etc/default/grub
    sed -i 's/GRUB_DISABLE_OS_PROBER="true"/GRUB_DISABLE_OS_PROBER="false"/' /etc/default/grub
    grub2-mkconfig -o /boot/grub2/grub.cfg
  else
    local options=("numa=off" "transparent_hugepage=never" "elevator=deadline")
    for option in "${options[@]}"; do
      set_kernel_option "$option"
    done
    grubby --info=ALL | awk '/numa/{print $0 "\n-" $(NR-1) "\n-" $(NR-2)}'
  fi
}
#==============================================================#
#                        配置 sysctl.conf                       #
#==============================================================#
function conf_sysctl() {
  log_print "配置 sysctl.conf"
  # 获取系统页面大小，用于计算内存总量
  local pagesize
  pagesize=$(getconf PAGE_SIZE)
  # min_free_kbytes = os_memory_total * 0.004
  local min_free_kbytes
  ((min_free_kbytes = os_memory_total / 250))
  # 计算内存总量（以 KB 或字节为单位）
  local shmall
  local shmmax
  ((shmall = (os_memory_total - 1) * 1024 / pagesize))
  ((shmmax = os_memory_total * 1024 - 10))
  # 如果 shmall 小于 2097152，则将其设为 2097152
  ((shmall < 2097152)) && shmall=2097152
  # 如果 shmmax 小于 4294967295，则将其设为 4294967295
  ((shmmax < 4294967295)) && shmmax=4294967295
  # 备份 sysctl 配置文件
  bak_file /etc/sysctl.conf
  # 使用 Here Document 来追加配置参数到 sysctl.conf 文件中
  write_file "Y" "/etc/sysctl.conf" "# OracleBegin
fs.aio-max-nr = 1048576
fs.file-max = 6815744
kernel.shmall = $shmall
kernel.shmmax = $shmmax
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576
vm.min_free_kbytes=$min_free_kbytes
net.ipv4.conf.$local_ifname.rp_filter = 1
vm.swappiness = 10
kernel.panic_on_oops = 1
kernel.randomize_va_space = 2
kernel.numa_balancing = 0"
  # 如果在 RAC 模式下安装，追加 RAC 参数
  for priv_ifname in "${rac_priv_ifnames[@]}"; do
    if [[ $priv_ifname ]]; then # 检查非空
      write_file "N" "/etc/sysctl.conf" "net.ipv4.conf.$priv_ifname.rp_filter = 2"
    fi
  done
  # 重新加载 sysctl 配置，并将结果输出到日志中
  color_printf blue "查看 sysctl.conf 配置情况 ：sysctl -p"
  sysctl -p
}
#==============================================================#
#                         配置 RemoveIPC                        #
#==============================================================#
function conf_ipc() {
  log_print "配置 RemoveIPC"
  # redhat6 版本无需配置
  # 检查是否需要设置 RemoveIPC=no。如果不需要设置则直接返回。
  if grep -Fq "#RemoveIPC=no" /etc/systemd/logind.conf; then
    # 备份原始配置文件
    bak_file /etc/systemd/logind.conf
    # Failed Install of RAC with ASM: ORA-27300 ORA-27302 ORA-27300 ORA-27301 ORA-27302 (文档 ID 2099563.1)
    # ORA-27300 ORA-27301 ORA-27302 ORA-27157 Database Crash (文档 ID 438205.1)
    if [[ "$os_type" = "sles" && "$os_version" = "8" ]]; then
      sed -i 's/#RemoveIPC=yes/RemoveIPC=no/' /etc/systemd/logind.conf
    else
      # 将 "#RemoveIPC=no" 行替换为 "RemoveIPC=no"
      sed -i 's/#RemoveIPC=no/RemoveIPC=no/' /etc/systemd/logind.conf
    fi
    # 重新加载 systemd 守护进程并重启 systemd-logind 服务
    (systemctl daemon-reload && systemctl restart systemd-logind) >/dev/null 2>&1
  fi
  # 检查是否已修改成功
  color_printf blue "查看 RemoveIPC ：/etc/systemd/logind.conf"
  grep "RemoveIPC" /etc/systemd/logind.conf
}
#==============================================================#
#                         配置 limits.conf                     #
#==============================================================#
function conf_limits() {
  log_print "配置 /etc/security/limits.conf 和 /etc/pam.d/login"
  # 备份 /etc/security/limits.conf 文件
  bak_file /etc/security/limits.conf
  # 在 /etc/security/limits.conf 文件末尾添加 Oracle 的配置
  write_file "N" "/etc/security/limits.conf" "# OracleBegin
oracle soft nofile 1024
oracle hard nofile 65536
oracle soft stack 10240
oracle hard stack 32768
oracle soft nproc 2047
oracle hard nproc 16384
oracle hard memlock unlimited
oracle soft memlock unlimited"
  # 如果 Oracle 安装模式为 RAC，则添加额外的配置
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    write_file "N" "/etc/security/limits.conf" "grid soft nofile 1024
grid hard nofile 65536
grid soft stack 10240
grid hard stack 32768
grid soft nproc 2047
grid hard nproc 16384"
  fi
  # 记录 /etc/security/limits.conf 文件的输出到日志中
  color_printf blue "查看 /etc/security/limits.conf："
  grep -v "^\s*\(#\|$\)" /etc/security/limits.conf
  # 备份 /etc/pam.d/login 文件
  bak_file /etc/pam.d/login
  # 在 /etc/pam.d/login 文件末尾添加 Oracle 的配置
  write_file "N" "/etc/pam.d/login" "# OracleBegin
session required pam_limits.so
session required /lib64/security/pam_limits.so
# OracleEnd"
  # 记录 /etc/pam.d/login 文件的输出到日志中
  echo
  color_printf blue "查看 /etc/pam.d/login 文件："
  grep -v "^\s*\(#\|$\)" /etc/pam.d/login
}
#==============================================================#
#                         配置 /dev/shm                        #
#==============================================================#
function conf_shm() {
  log_print "配置 /dev/shm"
  local shm_total
  shm_total=$(df -k /dev/shm | awk 'NR==2 {print $2}')
  # 检查是否将 /dev/shm 添加到了 /etc/fstab 文件中
  if ! grep -qE "/dev/shm" /etc/fstab; then
    # 如果没有添加，则将其添加进去
    bak_file /etc/fstab
    write_file "N" "/etc/fstab" "tmpfs /dev/shm tmpfs size=${os_memory_total}k 0 0"
  elif ((shm_total < os_memory_total)); then
    # 如果已经添加了 /dev/shm，检查共享内存总大小是否小于操作系统内存总量
    # 如果共享内存总大小小于操作系统内存总量，则将其设置为相同的值
    bak_file /etc/fstab
    sed -i "/\/dev\/shm/d" /etc/fstab
    write_file "N" "/etc/fstab" "tmpfs /dev/shm tmpfs size=${os_memory_total}k 0 0"
  fi
  # 重新挂载 /dev/shm
  mount -o remount /dev/shm
  color_printf blue "查看 Linux 挂载情况：/etc/fstab"
  grep -v "^\s*\(#\|$\)" /etc/fstab
}
#==============================================================#
#                       安装 rlwrap 插件                        #
#==============================================================#
function install_rlwrap() {
  # 检查 rlwrap 压缩包是否存在
  if check_file "$software_dir"/rlwrap-*.gz; then
    # 如果压缩包存在则开始安装 rlwrap
    log_print "安装 rlwrap 插件"
    # 创建并进入目录
    mkdir -p "$software_dir"/rlwrap && cd "$software_dir"/rlwrap || return 1
    # 解压缩文件
    tar -xf "$software_dir"/rlwrap-*.gz --strip-components 1 -C "$software_dir"/rlwrap
    # 配置、编译和安装软件，并将日志重定向到/dev/null以避免输出干扰
    (./configure -q && make -s && make install -s prefix=/usr/local libdir=/usr/local/libexec) >/dev/null 2>&1
    # 返回 /soft 目录
    cd ..
    # 删除不必要的文件夹和文件
    if check_file "$software_dir/rlwrap"; then
      rm -rf "${software_dir:?}/rlwrap"
    fi
    # 检查 rlwrap 是否已成功安装
    if hash rlwrap 2>/dev/null; then
      # 如果已成功安装，则输出信息
      color_printf green "成功安装 rlwrap：" "$(rlwrap -v)"
    else
      # 如果未成功安装，则输出错误信息
      color_printf yellow "未能成功安装 rlwrap，请检查安装日志。"
    fi
  fi
}
#==============================================================#
#                         配置 profile                          #
#==============================================================#
function conf_profile() {
  log_print "Root 用户环境变量"
  # 配置root用户环境变量
  bak_file /root/"$profile_name"
  write_file "N" "/root/$profile_name" "# OracleBegin
alias so='su - oracle'
export PS1="[\`whoami\`@\`hostname\`:"'\$PWD]# '"
  # 增加历史命令时间显示以及一些优化项
  bak_file /etc/profile
  write_file "N" "/etc/profile" "# OracleBegin
## history命令时间显示
export HISTSIZE=1000
export HISTTIMEFORMAT=\"%F %T \"
if [ \"\$HISTCONTROL\" = \"ignorespace\" ] ; then
    export HISTCONTROL=ignoreboth
else
    export HISTCONTROL=ignoredups
fi
## 主机语言
export LANG=\"en_US.UTF-8\""
  # RAC模式增加集群相关
  if [[ $oracle_install_mode =~ ^(rac|standalone)$ ]]; then
    write_file "N" "/root/$profile_name" "alias sg='su - grid'
alias crsctl='$env_grid_home/bin/crsctl'
alias srvctl='$env_grid_home/bin/srvctl'"
  fi
  color_printf blue "查看 root 用户环境变量：/root/$profile_name"
  grep -v "^\s*\(#\|$\)" /root/"$profile_name"

  for ((i = 0; i < ${#oracle_sids[@]}; i += 2)); do
    # 配置oracle用户环境变量
    log_print "Oracle 用户环境变量，实例名：${oracle_sids[i + 1]}"
    # Patching fails during relink , with error code 102 :: Fatal error: Command failed for target `javavm_refresh' (Doc ID 2002334.1)
    bak_file /home/oracle/"$profile_name"
    write_file "N" "/home/oracle/$profile_name" "# OracleBegin
umask 022
export TMP=/tmp
export TMPDIR=\$TMP
export NLS_LANG=AMERICAN_AMERICA.$db_characterset
export ORACLE_BASE=$env_oracle_base
export ORACLE_HOME=$env_oracle_home
export ORACLE_TERM=xterm
export TNS_ADMIN=\$ORACLE_HOME/network/admin
export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib
export ORACLE_SID=${oracle_sids[i + 1]}
export PATH=/usr/sbin:\$PATH
export PATH=\$ORACLE_HOME/bin:\$ORACLE_HOME/OPatch:\$ORACLE_HOME/perl/bin:\$PATH
export PERL5LIB=\$ORACLE_HOME/perl/lib
alias sas='sqlplus / as sysdba'
alias awr='sqlplus / as sysdba @?/rdbms/admin/awrrpt'
alias ash='sqlplus / as sysdba @?/rdbms/admin/ashrpt'
alias alert='vi \$ORACLE_BASE/diag/rdbms/*/\$ORACLE_SID/trace/alert_\$ORACLE_SID.log'
export PS1=\"[\`whoami\`@\`hostname\`:\"'\$PWD]\$ '"
    # Users are strongly recommended to go with 19.9 DB RU (or later) to minimize the number of Patches to be installed.19.9 OJVM & OCW RU Patches are also recommended to be applied,during/after the Installation.
    if [[ ("$os_version" = "7" && "$os_type" = "neokylin") || ("$os_version" = "8" || "$os_version" = "9") ]]; then
      write_file "N" "/home/oracle/$profile_name" "export CV_ASSUME_DISTID=OL7"
    fi
    # 检查 rlwrap 是否已经安装，并显示无误信息
    if hash rlwrap 2>/dev/null; then
      write_file "N" "/home/oracle/$profile_name" "alias sqlplus='rlwrap sqlplus'
alias rman='rlwrap rman'
alias adrci='rlwrap adrci'"
    fi
    # sles 授予目录权限
    if [[ "$os_type" = "sles" ]]; then
      chown -R oracle:oinstall /home/oracle/
    fi
    color_printf blue "查看 Oracle 用户环境变量：/home/oracle/$profile_name"
    grep -v "^\s*\(#\|$\)" /home/oracle/"$profile_name"
    # 创建一个与实例名同名的环境变量
    /bin/cp -f /home/oracle/"$profile_name" /home/oracle/."${oracle_sids[i]}"
    chown -R oracle:oinstall "/home/oracle/$profile_name"
  done

  # grid
  if [[ $oracle_install_mode =~ ^(rac|standalone)$ ]]; then
    log_print "Grid 用户环境变量"
    bak_file /home/grid/"$profile_name"
    write_file "N" "/home/grid/$profile_name" "# OracleBegin
umask 022
export TMP=/tmp
export TMPDIR=\$TMP
export NLS_LANG=AMERICAN_AMERICA.$db_characterset
export ORACLE_BASE=$env_grid_base
export ORACLE_HOME=$env_grid_home
export ORACLE_TERM=xterm
export TNS_ADMIN=\$ORACLE_HOME/network/admin
export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib
export ORACLE_SID=$grid_sid
export PATH=/usr/sbin:\$PATH
export PATH=\$ORACLE_HOME/bin:\$ORACLE_HOME/OPatch:\$PATH
alias sas='sqlplus / as sysasm'
export PS1=\"[\`whoami\`@\`hostname\`:\"'\$PWD]\$ '"
    # Users are strongly recommended to go with 19.9 DB RU (or later) to minimize the number of Patches to be installed.19.9 OJVM & OCW RU Patches are also recommended to be applied,during/after the Installation.
    if [[ ("$os_version" = "7" && "$os_type" = "neokylin") || ("$os_version" = "8" || "$os_version" = "9") ]]; then
      write_file "N" "/home/grid/$profile_name" "export CV_ASSUME_DISTID=OL7"
    fi
    # sles 授予目录权限
    if [[ "$os_type" = "sles" ]]; then
      chown -R grid:oinstall /home/grid/
    fi
    color_printf blue "查看 Grid 用户环境变量：/home/grid/$profile_name"
    grep -v "^\s*\(#\|$\)" /home/grid/"$profile_name"
    chown -R oracle:oinstall "/home/grid/$profile_name"
  fi
}
#==============================================================#
#                       配置 ntp timeserver                     #
#==============================================================#
# 定义函数：配置 ntp 服务
function conf_ntp() {
  case "$os_version" in
  6 | 7)
    # 备份 ntp 配置文件和 sysconfig 配置文件
    bak_file /etc/ntp.conf
    bak_file /etc/sysconfig/ntpd
    # 将容忍时钟偏差修改至30，单位为S，该值默认为1.5. 当偏差大于此限定值时,ntp不会同步时钟。
    write_file "N" "/etc/ntp.conf" "tos maxdist 30"
    # 当服务器时钟与本地时钟偏差大于1000时，ntp客户端会视为此偏差过大，不会同步时钟，且会退出ntpd服务，设置为0可忽略此限制。
    write_file "N" "/etc/ntp.conf" "tinker panic 0"
    # 删除 ntp 配置文件中已有的时间服务器信息，并添加新的时间服务器信息
    sed -i '/^server/d' /etc/ntp.conf
    write_file "N" "/etc/ntp.conf" "server $timeserver_ip iburst"
    # 创建 ntpd 进程ID文件
    touch /var/run/ntpd.pid
    # 编辑 sysconfig 文件来配置 ntpd 服务
    write_file "Y" "/etc/sysconfig/ntpd" "OPTIONS=\"-g -x -p /var/run/ntpd.pid\"
SYNC_HWCLOCK=yes"
    ;;
  *)
    # 备份 chrony 配置文件
    bak_file /etc/chrony.conf
    # 删除 ntp 配置文件中已有的时间服务器信息，并添加新的时间服务器信息
    sed -i '/^server/d' /etc/chrony.conf
    write_file "N" "/etc/chrony.conf" "server $timeserver_ip iburst"
    ;;
  esac
}
#==============================================================#
#                         配置时间同步                           #
#==============================================================#
function conf_timesync() {
  log_print "配置时间同步"
  # 如果存在时间服务器 IP，则配置 NTP/chrony 服务
  if [[ $timeserver_ip ]]; then
    case "$os_version" in
    6)
      install_packages_if_not_present "ntp"
      # 启动和开机启动 ntpd 服务
      service ntpd start
      chkconfig ntpd on
      # 配置 ntp
      conf_ntp
      # 重启 ntpd 服务，并检查其状态及时间同步情况
      service ntpd restart
      # 记录时间同步后的日期和时间
      ntpstat
      echo
      ntpq -p -n
      ;;
    7)
      # 关闭并禁用 chrony 服务，备份 chrony 配置文件
      install_packages_if_not_present "ntp" "chrony"
      systemctl disable chronyd.service
      if systemctl is-active --quiet chronyd.service; then
        systemctl stop chronyd.service
        mv /etc/chrony.conf /etc/chrony.conf.bak
      fi
      # 启动和开机启动 ntpd 服务
      systemctl start ntpd.service
      systemctl enable ntpd.service
      # 配置 ntp
      conf_ntp
      # 重启 ntpd 服务，并检查其状态及时间同步情况
      systemctl restart ntpd.service
      # 记录时间同步后的日期和时间
      ntpstat
      echo
      ntpq -p -n
      ;;
    *)
      # 关闭并禁用 ntpd 服务，备份 ntpd 配置文件
      systemctl disable ntpd.service
      install_packages_if_not_present "ntp" "chrony"
      if systemctl is-active --quiet ntpd.service; then
        systemctl stop ntpd.service
        mv /etc/ntpd.conf /etc/ntpd.conf.bak
      fi
      # 启动和开机启动 chronyd 服务
      systemctl start chronyd.service
      systemctl enable chronyd.service
      # 配置 ntp
      conf_ntp
      # 重启 chrony 服务，并检查其状态及时间同步情况
      systemctl restart chronyd.service
      chronyc tracking
      echo
      chronyc sources -v
      ;;
    esac
  fi
}
#==============================================================#
#                        配置 DNS 解析                          #
#==============================================================#
function conf_dns() {
  # 记录日志
  log_print "配置 DNS 解析"
  # 检查是否已安装 bind，如果未安装则安装相关软件包
  if ! rpm -q bind >/dev/null; then
    install_packages_if_not_present "bind-libs" "bind" "bind-utils"
  fi
  # 配置 DNS 文件
  write_file "Y" "/etc/resolv.conf" "search $dns_name  
nameserver $dns_ip
options rotate
options timeout:2
options attempts:5"
  # 检查 DNS 解析是否可用
  if nslookup "$scan_name"."$dns_name"; then
    # 如果解析成功，则输出提示信息
    color_printf green "DNS 配置成功！域名解析正常！"
  else
    # 如果解析失败，则输出错误信息
    color_printf yellow "DNS 配置成功！但域名无法正常解析，请检查网络连接或者 DNS 设置！"
  fi
}
#==============================================================#
#                    Configure Oracle ASM                      #
#==============================================================#
# 配置asm磁盘
function conf_asmdisk() {
  local uuid=$1
  local symlink=$2
  if [[ $multipath = "Y" ]]; then
    # 多路径udev绑盘
    local udev_rule="KERNEL==\"dm-*\",ENV{DM_UUID}==\"$uuid\",SYMLINK+=\"$symlink\",OWNER=\"grid\",GROUP=\"asmadmin\",MODE=\"0660\""
  else
    # 没有多路径udev绑盘,版本不同，scsi_id 路径不同
    if [[ "$os_version" = "6" ]]; then
      udev_rule="KERNEL==\"sd*\", BUS==\"scsi\", PROGRAM==\"/sbin/scsi_id -g -u -d /dev/\$name\", RESULT==\"$uuid\", SYMLINK+=\"$symlink\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""
    else
      udev_rule="KERNEL==\"sd*\", SUBSYSTEM==\"block\", PROGRAM==\"/usr/lib/udev/scsi_id -g -u -d /dev/\$name\", RESULT==\"$uuid\", SYMLINK+=\"$symlink\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""
    fi
  fi
  # 写入udev规则文件
  write_file "N" "/etc/udev/rules.d/99-oracle-asmdevices.rules" "$udev_rule"
}
#==============================================================#
#                         配置 asm disk                         #
#==============================================================#
function conf_asm() {
  # 如果 udev 规则文件存在则删除
  [[ -e /etc/udev/rules.d/99-oracle-asmdevices.rules ]] && rm -rf /etc/udev/rules.d/99-oracle-asmdevices.rules
  # 配置多路径
  if [[ $multipath = "Y" ]]; then
    if [[ "$os_type" = "openEuler" ]]; then
      install_packages_if_not_present "multipath-tools"
    else
      install_packages_if_not_present "device-mapper-multipath"
    fi
    log_print "配置 multipath 多路径和 UDEV 绑盘" >>"$oracleinstalllog"
    # 启用多路径
    mpathconf --enable --with_multipathd y >/dev/null 2>&1
    # 配置多路径开机自启和获取根目录磁盘
    case "$os_version" in
    "6")
      chkconfig multipathd.service on >/dev/null 2>&1
      local boot_disk
      boot_disk=$(findmnt -n -o SOURCE /boot | cut -d '/' -f 3 | sed 's/[0-9]*$//')
      ;;
    *)
      systemctl enable multipathd.service >/dev/null 2>&1
      boot_disk=$(lsblk -no PKNAME "$(findmnt -n -o SOURCE /boot)")
      ;;
    esac
    bak_file /etc/multipath.conf
    # 配置 multipath.conf
    write_file "Y" "/etc/multipath.conf" "defaults {
  user_friendly_names yes
}

blacklist {
  devnode \"^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*\"
  devnode \"^asm/*\"
  devnode \"ofsctl\"
  devnode \"^$boot_disk\"
}

multipaths {"
  fi
  # 将磁盘 UUID 和磁盘组名称存放在关联数组变量中
  declare -A DISK_INFOS=(
    ["ocr"]="$ocr_disk_uuid"
    ["data"]="$data_disk_uuid"
    ["arch"]="$arch_disk_uuid"
  )
  # 循环ASM磁盘信息数组
  for NAME in "${!DISK_INFOS[@]}"; do
    # 获取当前磁盘组中的磁盘 UUID 列表
    local UUID_LIST=${DISK_INFOS[$NAME]}
    # 定义一个间接变量用于存放asm磁盘路径，用逗号拼接
    local asm_disks="${NAME}disk"
    # 当前磁盘组存在 UUID 时解析
    if [[ -n $UUID_LIST ]]; then
      # 将逗号分隔的 UUID 转换成 UUID 数组
      #declare -a UUIDS=("${UUID_LIST//,/ }")
      IFS=',' read -ra UUIDS <<<"$UUID_LIST"
      # 遍历 UUID 数组，为每个 UUID 添加别名
      for ((i = 0; i < ${#UUIDS[@]}; i++)); do
        # 获取当前循环的 UUID 值
        local WID="${UUIDS[i]}"
        # 根据当前索引计算出别名编号
        local NUM
        ((NUM = i + 1))
        local ALIAS=asm_${NAME}_$NUM
        local UUID=$WID
        # 需要配置多路径时，写入多路径配置文件
        if [[ $multipath = "Y" ]]; then
          # 构造磁盘管理器使用的 UUID 和别名
          UUID=mpath-$WID
          # 将当前磁盘的 UUID 和别名写入 multipath.conf
          write_file "N" "/etc/multipath.conf" "multipath {
wwid $WID
alias $ALIAS
}"
        fi
        local ALIAS_STR=/dev/$ALIAS
        # 针对udev的规则配置ASM磁盘
        conf_asmdisk "$UUID" "$ALIAS"
        # 拼接asm磁盘组磁盘路径
        eval "${asm_disks}=\"\${${asm_disks}}${ALIAS_STR},\""
      done
    fi
    # 去掉最后一个逗号
    eval "${asm_disks}=\${${asm_disks}%?}"
  done
  if [[ $multipath = "Y" ]]; then
    write_file "N" "/etc/multipath.conf" "}"
    # 解决 VirtualBox 的一个 bug
    if [[ $virtualbox =~ ^[yY] ]]; then
      sed -i 's/1ATA_//' /etc/multipath.conf
      sed -i 's/1ATA_//' /etc/udev/rules.d/99-oracle-asmdevices.rules
    fi
    # 启用及查看多路径服务状态
    case "$os_version" in
    "6")
      service multipathd restart >/dev/null 2>&1
      ;;
    *)
      systemctl restart multipathd.service >/dev/null 2>&1
      ;;
    esac
    color_printf blue "检查 Mulltipath 多路径情况：" >>"$oracleinstalllog"
    multipath -ll >>"$oracleinstalllog"
  fi
  # 打印 UDEV 配置信息
  {
    echo
    color_printf blue "UDEV 配置信息："
    cat /etc/udev/rules.d/99-oracle-asmdevices.rules
    echo
  } >>"$oracleinstalllog"
  # 启动 UDEV
  while true; do
    if [[ "$os_version" = "6" ]]; then
      # 在 CentOS 6上启动 UDEV 服务
      start_udev >/dev/null 2>&1
    else
      # 在 CentOS 7/8/9 上启动 UDEV 服务
      # 重新加载udev规则
      /sbin/udevadm control --reload-rules >/dev/null 2>&1
      # 触发设备变化事件
      /sbin/udevadm trigger --type=devices --action=change >/dev/null 2>&1
    fi
    # 睡眠 5s，防止 UDEV 加载慢问题
    sleep 5s
    if [[ $(find /dev -name "asm*" 2>/dev/null) ]]; then
      {
        color_printf blue "检查 UDEV 绑定磁盘情况："
        ls -lcm /dev/asm_*
        echo
        color_printf blue "UDEV 配置完成!"
      } >>"$oracleinstalllog"
      break
    fi
  done
}
#==============================================================#
#                         配置其他节点                           #
#==============================================================#
function other_node_shell() {
  # 发送脚本和安装程序到其他节点
  for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
    log_print "配置 RAC 节点：${rac_public_ips[i]}" ""
    color_printf blue "正在节点：${rac_public_ips[i]} 上执行脚本："
    ssh -t -q "${rac_public_ips[i]}" "cd $software_dir && sh $software_dir/racnode.sh"
    echo
    color_printf blue "配置 RAC 节点：${rac_public_ips[i]} 结束!"
  done
}
#==============================================================#
#                         配置 SSH 互信                         #
#==============================================================#
function rac_ssh() {
  # 定义用户列表
  local users=(grid oracle)
  # 导出函数以供其他进程使用
  export -f ssh_trust
  # 对于每个用户
  for user in "${users[@]}"; do
    # 如果尚未配置SSH互信，则开始处理
    if [[ $(ssh_check "$user" "${hosts_array[@]}") = "false" ]]; then
      # 输出正在配置哪个用户的SSH互信
      log_print "配置 ${user^^} 用户 SSH 互信"
      case $user in
      grid)
        # 配置 Oracle Grid Infrastructure 的 SSH
        su grid -c "ssh_trust grid $grid_passwd ${hosts_array[*]}"
        ;;
      oracle)
        # 配置 Oracle Database 软件的SSH
        su oracle -c "ssh_trust oracle $oracle_passwd ${hosts_array[*]}"
        ;;
      esac
    fi
  done
}
#==============================================================#
#                        解压 Grid 软件包                        #
#==============================================================#
function unzip_gridsoft() {
  # 执行日志输出函数
  log_print "静默解压缩 Grid 软件包"
  # 修改软件目录的所有者和所属组为GRID
  chown -R grid:oinstall "$software_dir"
  color_printf blue "正在静默解压缩 Grid 软件包，请稍等："
  # 解压缩 Grid 安装包
  if [[ "$gi_version" = 11 ]]; then
    # 如果 Grid 软件目录不存在，则解压缩 Grid 安装包到指定目录中
    if ! check_file "$software_dir"/grid; then
      cascade_del_file "$software_dir/grid"
    fi
    color_printf green "静默解压 Grid 软件安装包： $grid_soft_name"
    run_as_grid "unzip -oq \"$grid_soft_name\" -d \"$software_dir\""
  else
    echo
    color_printf green "静默解压 Grid 软件安装包： $grid_soft_name"
    run_as_grid "unzip -oq \"$grid_soft_name\" -d \"$env_grid_home\""
  fi
  # 修改 Kylin 10 安装 12CR2 报错 unzip 问题，Grid 内置 unzip 版本太低
  if [[ "$os_type" = "kylin" ]]; then
    if [[ "$gi_version" = 12 ]]; then
      mv "$env_grid_home"/bin/unzip "$env_grid_home"/bin/unzipbak
      ln -s /usr/bin/unzip "$env_grid_home"/bin/unzip
    fi
  fi
  # 解压缩 Grid 补丁包
  if [[ $grid_patch ]]; then
    # 解压缩 opatch，11G 需要在 Grid 软件被安装后解压缩
    if [[ "$gi_version" != "11" ]]; then
      if check_file "$grid_opatch_name"; then
        echo
        color_printf green "静默解压 OPatch 软件补丁包： $grid_opatch_name"
        run_as_grid "unzip -oq \"$grid_opatch_name\" -d \"$env_grid_home\""
      fi
    fi
    # 如果 Grid 补丁目录不存在，则解压缩 Grid 补丁包到指定目录中
    if ! check_file "$software_dir"/"$grid_patch"; then
      echo
      color_printf green "静默解压 Grid 软件补丁包： $grid_patch_name"
      run_as_grid "unzip -oq \"$grid_patch_name\" -d \"$software_dir\""

      # 拷贝 gi opatch/patch 到其他节点
      if [[ "$gi_version" =~ ^(11|12)$ ]]; then
        for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
          # 将 Grid 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组
          scp -q "$grid_patch_name" "${rac_public_ips[i]}":"$software_dir"
          ssh -q "${rac_public_ips[i]}" "chown -R grid:oinstall \"$software_dir\" && su - grid -c \"unzip -oq '$grid_patch_name' -d '$software_dir'\""
        done
      fi
    fi
  fi
  # 安装 cvuqdisk
  if [[ $(rpm -q cvuqdisk) = 0 ]]; then
    # 安装 cvuqdisk，并将安装文件拷贝到其他节点指定的目录下，然后在其他节点上执行安装
    if check_file "$cvuqdisk"; then
      echo
      color_printf green "静默安装 cvu 软件：$cvu_name"
      echo
      rpm -Uvh --quiet "$cvuqdisk" >/dev/null 2>&1
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        scp -q "$cvuqdisk" "${rac_public_ips[i]}":"$software_dir" >/dev/null 2>&1
        ssh -q "${rac_public_ips[i]}" "rpm -Uvh --quiet $software_dir/$cvu_name" >/dev/null 2>&1
        ssh -q "${rac_public_ips[i]}" "rm -rf $software_dir/$cvu_name" >/dev/null 2>&1
      done
    fi
  fi
}
#==============================================================#
#                       配置 grid 静默文件                       #
#==============================================================#
function conf_gridrsp() {
  log_print "Grid 安装静默文件"
  # rac 和 standalone 选项赋值
  case "$oracle_install_mode" in
  rac)
    local gridrsp_array=(
      "INVENTORY_LOCATION=$env_oracle_inven"
      "oracle.install.option=CRS_CONFIG"
      "ORACLE_BASE=$env_grid_base"
      "oracle.install.asm.OSDBA=asmdba"
      "oracle.install.asm.OSOPER=asmoper"
      "oracle.install.asm.OSASM=asmadmin"
      "oracle.install.crs.config.gpnp.scanName=$scan_name"
      "oracle.install.crs.config.gpnp.scanPort=1521"
      "oracle.install.crs.config.clusterName=$cluster_name"
      "oracle.install.crs.config.gpnp.configureGNS=false"
      "oracle.install.crs.config.clusterNodes=$clusternodes"
      "oracle.install.crs.config.networkInterfaceList=$networkinterfacelist"
      "oracle.install.crs.config.useIPMI=false"
      "oracle.install.asm.SYSASMPassword=$database_passwd"
      "oracle.install.asm.diskGroup.name=$ocr_asm_group"
      "oracle.install.asm.diskGroup.redundancy=$ocr_redun"
      "oracle.install.asm.diskGroup.disks=$ocrdisk"
      "oracle.install.asm.diskGroup.diskDiscoveryString=$asmdisk_string"
      "oracle.install.asm.monitorPassword=$database_passwd"
    )
    ;;
  standalone)
    gridrsp_array=(
      "INVENTORY_LOCATION=$env_oracle_inven"
      "oracle.install.option=HA_CONFIG"
      "ORACLE_BASE=$env_grid_base"
      "oracle.install.asm.OSDBA=asmdba"
      "oracle.install.asm.OSOPER=asmoper"
      "oracle.install.asm.OSASM=asmadmin"
      "oracle.install.crs.config.gpnp.configureGNS=false"
      "oracle.install.crs.config.useIPMI=false"
      "oracle.install.asm.SYSASMPassword=$database_passwd"
      "oracle.install.asm.diskGroup.name=$data_asm_group"
      "oracle.install.asm.diskGroup.redundancy=$data_redun"
      "oracle.install.asm.diskGroup.disks=$datadisk"
      "oracle.install.asm.diskGroup.diskDiscoveryString=$asmdisk_string"
      "oracle.install.asm.monitorPassword=$database_passwd"
    )
    ;;
  esac
  # 根据不同的版本向grid.rsp文件追加配置
  case "$gi_version" in
  "11")
    gridrsp_array+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v11_2_0"
      "SELECTED_LANGUAGES=en"
      "ORACLE_HOME=$env_grid_home"
      "oracle.install.crs.config.storageOption=ASM_STORAGE"
      "oracle.install.asm.diskGroup.AUSize=1"
      "oracle.installer.autoupdates.option=SKIP_UPDATES"
    )
    ;;
  "12" | "19" | "21" | "23")
    gridrsp_array+=(
      "oracle.install.crs.config.ClusterConfiguration=STANDALONE"
      "oracle.install.crs.config.configureAsExtendedCluster=false"
      "oracle.install.crs.configureGIMR=false"
      "oracle.install.asm.storageOption=ASM"
      "oracle.install.asm.diskGroup.AUSize=4"
      "oracle.install.asm.configureAFD=$afd"
      "oracle.install.crs.config.ignoreDownNodes=false"
      "oracle.install.config.managementOption=NONE"
      "oracle.install.crs.rootconfig.executeRootScript=false"
    )
    case "$gi_version" in
    "12")
      gridrsp_array+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v12.2.0")
      ;;
    "19")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v19.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
      )
      ;;
    "21")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v21.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
      )
      ;;
    "23")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v23.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
      )
      ;;
    esac
    ;;
  esac
  # 将Oracle软件安装相关配置写入grid.rsp文件
  if check_file "$software_dir"/grid.rsp; then
    rm -rf "$software_dir"/grid.rsp
  fi
  printf '%s\n' "${gridrsp_array[@]}" >>"$software_dir"/grid.rsp
  # 记录grid.rsp文件内容到日志中
  cat "$software_dir"/grid.rsp
}
#==============================================================#
#                      获取安装 grid 命令                        #
#==============================================================#
function get_gridinstall_cmd() {
  log_print "静默安装 Grid 软件命令"
  case "$gi_version" in
  "11")
    gridinstall_cmd=$(echo -e "$software_dir/grid/runInstaller \\
-silent \\
-showProgress \\
-ignoreSysPrereqs \\
-ignorePrereq \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp")
    ;;
  "12" | "19" | "21" | "23")
    if [[ -z "$grid_patch" ]]; then
      gridinstall_cmd=$(echo -e "$env_grid_home/gridSetup.sh \\
-silent \\
-skipPrereqs \\
-ignorePrereqFailure \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp")
    else
      case "$gi_version" in
      "12")
        # [INS-42505] The installer has detected that the Oracle Grid Infrastructure home software at (/oracle/GRID/12201) is not complete. (Doc ID 2697235.1)
        mv "$env_grid_home"/install/files.lst "$env_grid_home"/install/files.lst.bak
        local patch_str="-applyPSU $software_dir/$grid_patch"
        ;;
      "19" | "21" | "23")
        patch_str="-applyRU $software_dir/$grid_patch"
        ;;
      esac
      gridinstall_cmd=$(echo -e "$env_grid_home/gridSetup.sh \\
-silent \\
-skipPrereqs \\
-ignorePrereqFailure \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp \\
$patch_str")
    fi
    ;;
  esac
  color_printf blue "$gridinstall_cmd"
}
#==============================================================#
#                        检查 OPatch 版本                       #
#==============================================================#
function check_opatch_version() {
  local opatch_path=$1/OPatch/opatch
  $opatch_path version
}
#==============================================================#
#                         安装 Grid 软件                        #
#==============================================================#
function install_gridsoft() {
  # 配置 grid 静默安装文件
  conf_gridrsp
  # 获取安装 grid 命令
  get_gridinstall_cmd
  # 修改软件目录的所有者和所属组为GRID
  chown -R grid:oinstall "$software_dir"
  # 打印日志
  log_print "静默安装 Grid 软件"
  if [[ "$db_version" != "11" ]]; then
    color_printf blue "检查 Grid 软件 OPacth 版本："
    check_opatch_version "$env_grid_home"
    echo
  fi
  color_printf blue "正在安装 Grid 软件："
  # 安装 Grid 软件
  run_as_grid "$gridinstall_cmd"
  # Grid 安装后操作
  after_grid_install "$@"
  # 打印日志
  log_print "Grid 软件版本"
  color_printf blue "查看 Grid 软件版本：sqlplus -V"
  run_as_grid "sqlplus -V"
  log_print "Grid 补丁信息"
  color_printf blue "查看 Grid 补丁信息：opatch lspatches"
  run_as_grid "opatch lspatches"
  log_print "Grid 资源检查"
  color_printf blue "查看 Grid 集群情况：crsctl stat res -t"
  run_as_grid "crsctl stat res -t"
}
#==============================================================#
#                      执行 root.sh 脚本                        #
#==============================================================#
# 执行 root.sh 脚本
function exec_root() {
  local root_path=$1
  log_print "执行 root 脚本"
  if [[ "$oracle_install_mode" = "rac" ]]; then
    color_printf blue "节点 $local_ip ："
  fi
  # 执行 orainstRoot.sh 脚本，不论 grid/oracle 安装都执行
  if check_file "$env_oracle_inven"/orainstRoot.sh; then
    color_printf blue "执行命令：$env_oracle_inven/orainstRoot.sh"
    "$env_oracle_inven"/orainstRoot.sh
  fi
  if check_file "$root_path"/root.sh; then
    echo
    color_printf blue "执行命令：$root_path/root.sh"
    "$root_path"/root.sh
  fi
  # 仅 rac 模式执行
  if [[ "$oracle_install_mode" = "rac" ]]; then
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      echo
      color_printf blue "节点 ${rac_public_ips[i]} ："
      color_printf blue "执行命令：$env_oracle_inven/orainstRoot.sh"
      ssh -q "${rac_public_ips[i]}" "$env_oracle_inven"/orainstRoot.sh
      echo
      color_printf blue "执行命令：$root_path/root.sh"
      ssh -q "${rac_public_ips[i]}" "$root_path"/root.sh
    done
  fi
}
#==============================================================#
#                      安装 Grid 软件后操作                      #
#==============================================================#
function after_grid_install() {
  case "$gi_version" in
  "11")
    # patch 18370031 补丁安装
    if [[ "$os_version" = "7" ]]; then
      log_print "静默安装 18370031 补丁"
      if [[ "$oracle_install_mode" = "rac" ]]; then
        color_printf blue "节点 $local_ip ："
      fi
      run_as_grid "unzip -oq $software_dir/p18370031_112040_Linux-x86-64.zip -d $software_dir"
      run_as_grid "$env_grid_home/OPatch/opatch napply -oh $env_grid_home -local $software_dir/18370031 -silent"
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        # 将 Grid 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组，执行安装
        echo
        color_printf blue "节点 ${rac_public_ips[i]} ："
        scp -r -q "$software_dir"/p18370031_112040_Linux-x86-64.zip "${rac_public_ips[i]}":"$software_dir"
        ssh -q "${rac_public_ips[i]}" "chown -R grid:oinstall $software_dir"
        run_as_grid "ssh -q ${rac_public_ips[i]} unzip -oq $software_dir/p18370031_112040_Linux-x86-64.zip -d $software_dir"
        # other node install 18370031 to grid
        run_as_grid "ssh -q ${rac_public_ips[i]} $env_grid_home/OPatch/opatch napply -oh $env_grid_home -local $software_dir/18370031 -silent"
      done
    fi
    # 执行 root 脚本
    exec_root "$env_grid_home"
    # 执行 configToolAllCommands 完成 GRID 基础配置
    # Complete Grid Infrastructure Configuration Assistant(Plug-in) if OUI is not Available (Doc ID 1360798.1)
    if ! check_file "$env_grid_home"/cfgtoollogs/configToolAllCommands; then
      run_as_grid "$env_grid_home/oui/bin/runConfig.sh ORACLE_HOME=$env_grid_home MODE=perform ACTION=configure RERUN=true $*" >/dev/null 2>&1
    fi
    # 添加 asm 账户密码信息到 cfgrsp.properties 文件中
    write_file "N" "/home/grid/cfgrsp.properties" "oracle.assistants.asm|S_ASMPASSWORD=$database_passwd
oracle.assistants.asm|S_ASMMONITORPASSWORD=$database_passwd"
    run_as_grid "$env_grid_home/cfgtoollogs/configToolAllCommands RESPONSE_FILE=/home/grid/cfgrsp.properties" >/dev/null 2>&1
    if check_file "/home/grid/cfgrsp.properties"; then
      rm -rf /home/grid/cfgrsp.properties
    fi
    # 11GR2 安装 grid 补丁
    if [[ $grid_patch ]]; then
      log_print "Grid 软件安装补丁"
      if [[ "$oracle_install_mode" = "rac" ]]; then
        color_printf blue "节点 $local_ip ："
      fi
      run_as_grid "unzip -oq $grid_opatch_name -d $env_grid_home"
      color_printf blue "检查 Grid 软件 OPacth 版本："
      check_opatch_version "$env_grid_home"
      echo
      color_printf blue "正在安装 Grid 软件补丁："
      "$env_grid_home"/OPatch/opatch auto "$software_dir"/"$grid_patch" -oh "$env_grid_home"
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        echo
        color_printf blue "节点 ${rac_public_ips[i]} ："
        run_as_grid "ssh -q ${rac_public_ips[i]} unzip -oq $grid_opatch_name -d $env_grid_home"
        ssh -q "${rac_public_ips[i]}" "$env_grid_home"/OPatch/opatch auto "$software_dir"/"$grid_patch" -oh "$env_grid_home"
      done
    fi
    ;;
  "12" | "19" | "21" | "23")
    if [[ "$gi_version" = "12" ]]; then
      # The command '/u01/app/12.2.0/grid/perl/bin/perl -I/u01/app/12.2.0/grid/perl/lib -I/u01/app/12.2.0/grid/crs/install /u01/app/12.2.0/grid/crs/install/rootcrs.pl ' execution failed
      /usr/bin/make -s -f "$env_grid_home"/rdbms/lib/ins_rdbms.mk client_sharedlib libasmclntsh12.ohso libasmperl12.ohso ORACLE_HOME="$env_grid_home" >/dev/null 2>&1
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        ssh -q "${rac_public_ips[i]}" "/usr/bin/make -s -f $env_grid_home/rdbms/lib/ins_rdbms.mk client_sharedlib libasmclntsh12.ohso libasmperl12.ohso ORACLE_HOME=$env_grid_home" >/dev/null 2>&1
      done
    fi
    # 执行 root 脚本
    exec_root "$env_grid_home"
    # Complete Grid Infrastructure Configuration Assistant(Plug-in) if OUI is not Available (Doc ID 1360798.1)
    run_as_grid "$env_grid_home/gridSetup.sh -executeConfigTools -responseFile $software_dir/grid.rsp -silent" >/dev/null 2>&1
    ;;
  esac
}
#==============================================================#
#                     获取创建 ASM 磁盘组命令                     #
#==============================================================#
# 创建ASM磁盘组
function get_asmca_cmd() {
  # 打印日志
  log_print "静默创建 ASM 磁盘组命令"
  # 操作Grid用户创建数据磁盘组
  data_asmca_cmd=$(echo -e "$env_grid_home/bin/asmca -silent \\
-createDiskGroup \\
-diskGroupName $data_asm_group \\
-diskList $datadisk \\
-redundancy $data_redun \\
-compatible.asm $gi_compatible \\
-compatible.rdbms $db_compatible")
  color_printf blue "$data_asmca_cmd"
  # 判断归档磁盘是否存在，并操作Grid用户创建归档磁盘组
  if [[ -n "$arch_base_disk" ]]; then
    arch_asmca_cmd=$(echo -e "$env_grid_home/bin/asmca -silent \\
-createDiskGroup \\
-diskGroupName $arch_asm_group \\
-diskList $archdisk \\\
-redundancy $arch_redun \\
-compatible.asm $gi_compatible \\
-compatible.rdbms $db_compatible")
    color_printf blue "$arch_asmca_cmd"
  fi
}
#==============================================================#
#                       创建 ASM 磁盘组                          #
#==============================================================#
# 创建ASM磁盘组
function create_asmgroup() {
  # 获取创建 ASM 磁盘组命令
  get_asmca_cmd
  # 打印日志
  log_print "ASM 磁盘组创建"
  color_printf blue "正在创建 ASM 磁盘组："
  # 操作Grid用户创建数据磁盘组
  run_as_grid "$data_asmca_cmd"
  # 判断归档磁盘是否存在，并操作Grid用户创建归档磁盘组
  if [[ -n "$arch_asmca_cmd" ]]; then
    run_as_grid "$arch_asmca_cmd"
  fi
  color_printf blue "查看 ASM 磁盘组：asmcmd lsdg"
  run_as_grid "asmcmd lsdg"
}
#==============================================================#
#                        解压 Oracle 软件                       #
#==============================================================#
function unzip_dbsoft() {
  # 执行日志输出函数
  log_print "静默解压 Oracle 软件包"
  # 修改软件目录的所有者和所属组为Oracle
  chown -R oracle:oinstall "$software_dir"
  color_printf blue "正在静默解压缩 Oracle 软件包，请稍等："
  # 安装Oracle数据库软件以及相关补丁
  case "$db_version" in
  "11" | "12")
    # 只有当数据库所需文件夹不存在时，才会解压文件到指定目录下
    if check_file "$software_dir"/database; then
      cascade_del_file "$software_dir/database"
    fi
    # 解压第一个文件到指定的目录下，-o选项可以覆盖原有文件，-q选项可以减少输出信息
    if [[ "$db_soft_name1" ]]; then
      color_printf green "静默解压 Oracle 软件安装包： $db_soft_name,$db_soft_name1"
      run_as_oracle "unzip -oq $db_soft_name -d $software_dir && unzip -oq $db_soft_name1 -d $software_dir"
    else
      color_printf green "静默解压 Oracle 软件安装包： $db_soft_name"
      run_as_oracle "unzip -oq $db_soft_name -d $software_dir"
    fi
    # 修改 Kylin 10 安装 11GR2 和 12CR2 报错 unzip 问题，Oralce 内置 unzip 版本太低
    if [[ "$os_type" = "kylin" ]]; then
      mv "$software_dir"/database/install/unzip "$software_dir"/database/install/unzipbak
      ln -s /usr/bin/unzip "$software_dir"/database/install/unzip
    fi
    ;;
  *)
    # 解压文件到Oracle Home文件夹中（$env_oracle_home）。
    echo
    color_printf green "静默解压 Oracle 软件安装包： $db_soft_name"
    run_as_oracle "unzip -oq $db_soft_name -d $env_oracle_home"
    ;;
  esac
  # 判断补丁
  if [[ $oracle_patch ]]; then
    # 任何模式，如果指定了 -opa 参数，则优先使用 -opa 指定的补丁
    patch_number=$oracle_patch
    local patch_name=$db_patch_name
  else
    # RAC 安装时，如果没有指定 -opa 参数，但是指定了 -gpa 参数，则默认使用 -gpa 指定的补丁
    if [[ $grid_patch ]]; then
      patch_number=$grid_patch
      patch_name=$grid_patch_name
    fi
  fi
  # 如果传入了oracle_patch参数，并且补丁所需文件夹不存在
  if [[ $patch_number ]]; then
    # 如果数据库版本不是11G/12C，则解压Opatch到Oracle Home文件夹中（$env_oracle_home）
    if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
      if check_file "$db_opatch_name"; then
        echo
        color_printf green "静默解压 OPatch 软件补丁包： $db_opatch_name"
        run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      fi
    fi
    if ! check_file "$software_dir"/"$patch_number"; then
      # 解压文件到指定目录下
      echo
      color_printf green "静默解压 Oracle 软件补丁包：$patch_name"
      run_as_oracle "unzip -oq $patch_name -d $software_dir"
    fi
    # 如果是 RAC 部署模式，需要在其他节点上也应用补丁
    if [[ "$oracle_install_mode" = "rac" ]]; then
      # 拷贝 oracle opatch/patch 到其他节点
      if [[ "$db_version" =~ ^(11|12)$ ]]; then
        for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
          # 将 oracle 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组
          scp -q "$patch_name" "${rac_public_ips[i]}":"$software_dir"
          # 修改远程主机上的文件所有权以便 oracle 用户可以操作
          ssh -q "${rac_public_ips[i]}" "chown -R oracle:oinstall $software_dir"
          run_as_oracle "ssh -q ${rac_public_ips[i]} unzip -oq $patch_name -d $software_dir"
        done
      fi
    fi
  fi
  # 如果 Linux8 安装 ORACLE 11GR2，需要解压必须补丁包
  if [[ "$os_version" = "8" && "$db_version" = "11" ]]; then
    if ! check_file "$software_dir"/33991024; then
      echo
      color_printf green "静默解压 Oracle 软件补丁包：$software_dir/p33991024_11204220118_Generic.zip"
      run_as_oracle "unzip -oq $software_dir/p33991024_11204220118_Generic.zip -d $software_dir"
    fi
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      # 将 oracle 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组
      scp -q "$software_dir"/p33991024_11204220118_Generic.zip "${rac_public_ips[i]}":"$software_dir"
      # 修改远程主机上的文件所有权以便 oracle 用户可以操作
      ssh -q "${rac_public_ips[i]}" "chown -R oracle:oinstall $software_dir"
      run_as_oracle "ssh -q ${rac_public_ips[i]} unzip -oq $software_dir/p33991024_11204220118_Generic.zip -d $software_dir"
    done
  fi
  # 检查是否需要安装 OJVM 补丁
  if [[ $ojvm_patch ]]; then
    if ! check_file "$software_dir"/"$ojvm_patch"; then
      echo
      color_printf green "静默解压 OJVM 软件补丁包： $ojvm_patch_name"
      # 如果 Oracle 数据库版本不是 11 或 12，需要先安装 OPatch
      if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
        # 在 oracle 用户下解压 OPatch 工具到 ORACLE_HOME 目录
        run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      fi
      # 解压 OJVM 补丁到指定目录
      run_as_oracle "unzip -oq $ojvm_patch_name -d $software_dir"
    fi
    # 如果是 RAC 部署模式，需要在其他节点上也应用补丁
    if [[ "$oracle_install_mode" = "rac" ]]; then
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        # 将 OJVM 补丁复制到远程主机的指定目录下
        scp -q "$ojvm_patch_name" "${rac_public_ips[i]}":"$software_dir"
        # 修改远程主机上的文件所有权以便 oracle 用户可以操作
        ssh -q "${rac_public_ips[i]}" "chown -R oracle:oinstall $software_dir"
        # 在远程主机上应用 OJVM 补丁
        run_as_oracle "ssh -q ${rac_public_ips[i]} unzip -oq $ojvm_patch_name -d $software_dir"
      done
    fi
  fi
}
#==============================================================#
#                    创建 Oracle 静默安装文件                     #
#==============================================================#
function conf_dbrsp() {
  log_print "Oracle 安装静默文件"
  # 将Oracle软件安装相关配置写入db.rsp文件
  declare -a db_rsp_arr=(
    "oracle.install.option=INSTALL_DB_SWONLY"
    "UNIX_GROUP_NAME=oinstall"
    "INVENTORY_LOCATION=$env_oracle_inven"
    "ORACLE_BASE=$env_oracle_base"
    "oracle.install.db.InstallEdition=EE"
    "oracle.install.db.DBA_GROUP=dba"
    "oracle.install.db.OPER_GROUP=oper"
  )
  if [[ "$oracle_install_mode" = "rac" ]]; then
    db_rsp_arr+=("oracle.install.db.CLUSTER_NODES=$rac_hostname")
  fi
  # 根据不同的版本向db.rsp文件追加配置
  case "$db_version" in
  "11")
    db_rsp_arr+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v11_2_0"
      "SELECTED_LANGUAGES=en,zh_CN"
      "ORACLE_HOME=$env_oracle_home"
      "DECLINE_SECURITY_UPDATES=true"
      "oracle.installer.autoupdates.option=SKIP_UPDATES"
    )
    ;;
  "12")
    db_rsp_arr+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v12.2.0"
      "SELECTED_LANGUAGES=en,zh_CN"
      "ORACLE_HOME=$env_oracle_home"
      "oracle.install.db.OSBACKUPDBA_GROUP=backupdba"
      "oracle.install.db.OSDGDBA_GROUP=dgdba"
      "oracle.install.db.OSKMDBA_GROUP=kmdba"
      "oracle.install.db.OSRACDBA_GROUP=racdba"
    )
    ;;
  "19" | "21" | "23")
    db_rsp_arr+=(
      "oracle.install.db.OSBACKUPDBA_GROUP=backupdba"
      "oracle.install.db.OSDGDBA_GROUP=dgdba"
      "oracle.install.db.OSKMDBA_GROUP=kmdba"
      "oracle.install.db.OSRACDBA_GROUP=racdba"
      "oracle.install.db.rootconfig.executeRootScript=false"
      "oracle.install.db.rootconfig.configMethod="
    )
    case "$db_version" in
    "19")
      db_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v19.0.0")
      ;;
    "21")
      db_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v21.0.0")
      ;;
    "23")
      db_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v23.0.0")
      ;;
    esac
    ;;
  esac
  # 将数组中的元素写入db.rsp文件
  if check_file "$software_dir"/db.rsp; then
    rm -rf "$software_dir"/db.rsp
  fi
  printf '%s\n' "${db_rsp_arr[@]}" >"$software_dir/db.rsp"
  # 记录 db.rsp 文件内容到日志中
  cat "$software_dir/db.rsp"
}
#==============================================================#
#                      获取安装 Oracle 命令                      #
#==============================================================#
function get_oracleinstall_cmd() {
  log_print "静默安装 Oracle 软件命令"
  # 判断补丁
  if [[ $oracle_patch ]]; then
    # 任何模式，如果指定了 -opa 参数，则优先使用 -opa 指定的补丁
    patch_number=$oracle_patch
  else
    # RAC 安装时，如果没有指定 -opa 参数，但是指定了 -gpa 参数，则默认使用 -gpa 指定的补丁
    if [[ $grid_patch ]]; then
      patch_number=$grid_patch
    fi
  fi
  case "$db_version" in
  "11" | "12")
    # 获取安装命令
    oracleinstall_cmd=$(echo -e "$software_dir/database/runInstaller \\
-silent \\
-responseFile $software_dir/db.rsp \\
-showProgress \\
-ignoreSysPrereqs \\
-ignorePrereq \\
-waitForCompletion")
    ;;
  "19" | "21" | "23")
    if [[ $patch_number ]]; then
      oracleinstall_cmd=$(echo -e "$env_oracle_home/runInstaller \\
-silent \\
-ignorePrereqFailure \\
-responseFile $software_dir/db.rsp \\
-waitForCompletion \\
-applyRU $software_dir/$patch_number")
    else
      # 无补丁
      oracleinstall_cmd=$(echo -e "$env_oracle_home/runInstaller \\
-silent \\
-ignorePrereqFailure \\
-responseFile $software_dir/db.rsp \\
-waitForCompletion")
    fi
    ;;
  esac
  color_printf blue "$oracleinstall_cmd"
}
#==============================================================#
#                       安装 Oracle 软件                         #
#==============================================================#
function install_dbsoft() {
  # 配置 Oracle 静默安装文件
  conf_dbrsp
  # 获取安装 Oracle 命令
  get_oracleinstall_cmd
  # 修改软件目录的所有者和所属组为Oracle
  chown -R oracle:oinstall "$software_dir"
  # 打印日志
  log_print "静默安装数据库软件"
  if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
    color_printf blue "检查 Oracle 软件 OPacth 版本："
    check_opatch_version "$env_oracle_home"
    echo
  fi
  color_printf blue "正在安装 Oracle 软件："
  # 安装数据库软件
  run_as_oracle "$oracleinstall_cmd"
  # 安装 Oracle 软件后操作
  after_oracle_install
  # 打印日志
  log_print "Oracle 软件版本"
  run_as_oracle "sqlplus -V"
  log_print "Oracle 补丁信息"
  run_as_oracle "opatch lspatches"
}
#==============================================================#
#                     安装 Oracle 软件后操作                     #
#==============================================================#
function after_oracle_install() {
  case "$db_version" in
  "11" | "12")
    if [[ "$db_version" = 11 && "$gi_version" -gt 11 ]]; then
      # 如果 GI 和 DB 版本不一致，[INS-35354] The system on which you are attempting to install Oracle RAC is not part of a valid cluster
      run_as_grid "$env_grid_home/oui/bin/runInstaller -updateNodeList ORACLE_HOME=$env_grid_home CRS=true" >/dev/null 2>&1
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        run_as_grid "ssh -q ${rac_public_ips[i]} $env_grid_home/oui/bin/runInstaller -updateNodeList ORACLE_HOME=$env_grid_home CRS=true" >/dev/null 2>&1
      done
    fi
    # 修改 Kylin 10 安装 11GR2 和 12CR2 报错 unzip 问题，Oralce 内置 unzip 版本太低
    if [[ "$os_type" = "kylin" ]]; then
      mv "$env_oracle_home"/bin/unzip "$env_oracle_home"/bin/unzipbak
      ln -s /usr/bin/unzip "$env_oracle_home"/bin/unzip
    fi
    # 执行 root 脚本
    exec_root "$env_oracle_home"
    # 安装数据库补丁
    # 如果 patch_number 有值，则打补丁
    if [[ $patch_number ]]; then
      log_print "Oracle 软件安装补丁"
      # 解压 opatch 工具
      run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      color_printf blue "检查 Oracle 软件 OPacth 版本："
      check_opatch_version "$env_oracle_home"
      echo
      color_printf blue "正在安装 Oracle 软件补丁："
      # RAC 和 单机ASM 安装 Oracle PSU/RU
      if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
        # RAC 安装数据库 PSU
        for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
          # 修改远程主机上的文件所有权以便 oracle 用户可以操作
          ssh -q "${rac_public_ips[i]}" "chown -R oracle:oinstall $software_dir"
          run_as_oracle "ssh -q ${rac_public_ips[i]} unzip -oq $db_opatch_name -d $env_oracle_home"
        done
        if [[ "$db_version" = "11" ]]; then
          # 单机 ASM 模式不显示节点提示
          if [[ "$oracle_install_mode" = "rac" ]]; then
            color_printf blue "节点 $local_ip ："
          fi
          if [[ $oracle_patch ]]; then
            # 11GR2 RAC For Linux8 安装补丁需要加 -no_relink
            if [[ "$os_version" = "8" ]]; then
              su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent -no_relink
EOF
            else
              su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
            fi
          else
            "$env_oracle_home"/OPatch/opatch auto "$software_dir"/"$patch_number" -oh "$env_oracle_home"
          fi
          for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
            echo
            color_printf blue "节点 ${rac_public_ips[i]} ："
            if [[ $oracle_patch ]]; then
              # 11GR2 RAC For Linux8 安装补丁需要加 -no_relink
              if [[ "$os_version" = "8" ]]; then
                ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent -no_relink
EOF"
              else
                ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
              fi
            else
              ssh -q "${rac_public_ips[i]}" "$env_oracle_home"/OPatch/opatch auto "$software_dir"/"$patch_number" -oh "$env_oracle_home"
            fi
          done
        elif [[ "$db_version" = "12" ]]; then
          if [[ "$oracle_install_mode" = "rac" ]]; then
            color_printf blue "节点 $local_ip ："
          fi
          if [[ $oracle_patch ]]; then
            su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
          else
            "$env_oracle_home"/OPatch/opatchauto apply "$software_dir"/"$patch_number" -oh "$env_oracle_home"
          fi
          for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
            echo
            color_printf blue "节点 ${rac_public_ips[i]} ："
            if [[ $oracle_patch ]]; then
              ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
            else
              ssh -q "${rac_public_ips[i]}" "cd $software_dir/$patch_number;$env_oracle_home/OPatch/opatchauto apply $software_dir/$patch_number -oh $env_oracle_home"
            fi
          done
        fi
      else
        # Linux8 安装 11GR2 时打补丁不需要执行 relink
        if [[ "$db_version" = "11" && "$os_version" = "8" ]]; then
          su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent -no_relink
EOF
        else
          su - oracle <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
        fi
      fi
    fi
    # 在 12c 上安装 Linux6 需要设置 irman、ioracle
    if [[ "$db_version" = "12" && "$os_version" = "6" ]]; then
      run_as_oracle "/usr/bin/make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk irman" >/dev/null 2>&1
      run_as_oracle "/usr/bin/make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk ioracle" >/dev/null 2>&1

      if [[ "$oracle_install_mode" = "rac" ]]; then
        for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
          run_as_oracle "ssh -q ${rac_public_ips[i]} /usr/bin/make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk irman" >/dev/null 2>&1
          run_as_oracle "ssh -q ${rac_public_ips[i]} /usr/bin/make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk ioracle" >/dev/null 2>&1
        done
      fi
    fi
    # 在 11g 上安装 Linux7 需要设置 -lnnz11
    if [[ "$db_version" = "11" && "$os_version" = "7" ]]; then
      sed -i "s/^\(\s*\$(MK_EMAGENT_NMECTL)\)\s*$/\1 -lnnz11/g" "$env_oracle_home"/sysman/lib/ins_emagent.mk
      if [[ "$oracle_install_mode" = "rac" ]]; then
        for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
          ssh -q "${rac_public_ips[i]}" "sed -i 's/^\(\s*\$(MK_EMAGENT_NMECTL)\)\s*$/\1 -lnnz11/g' $env_oracle_home/sysman/lib/ins_emagent.mk"
        done
      fi
    fi
    # 11GR2 安装补丁 33991024
    if [[ "$db_version" = "11" && "$os_version" = "8" ]]; then
      log_print "Oracle 软件安装补丁 33991024"
      if [[ "$oracle_install_mode" = "rac" ]]; then
        color_printf blue "节点 $local_ip ："
      fi
      su - oracle <<-EOF
cd "$software_dir/33991024"
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent -no_relink
EOF
      # 执行 relink 修复 Linux8 安装错误
      echo
      color_printf blue "Oracle 执行 relink："
      run_as_oracle "$env_oracle_home/bin/relink all"
      # for RAC
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        echo
        color_printf blue "节点 ${rac_public_ips[i]} ："
        ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
cd $software_dir/33991024
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent -no_relink
EOF"
        # 执行 relink 修复 Linux8 安装错误
        echo
        color_printf blue "Oracle 执行 relink："
        ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
$env_oracle_home/bin/relink all
EOF"
      done
    fi
    ;;
  # 在 19C、21C 上应用 RU
  "19" | "21" | "23")
    # 执行 root 脚本
    exec_root "$env_oracle_home"
    ;;
  esac

  if [[ $ojvm_patch ]]; then
    install_ojvm_patch
  fi
}
#==============================================================#
#                        安装 OJVM 补丁                         #
#==============================================================#
# 安装 ojvm 补丁
function install_ojvm_patch() {
  log_print "OJVM 补丁安装"
  color_printf blue "检查 OJVM 软件 OPacth 版本："
  check_opatch_version "$env_oracle_home"
  echo
  # 解压 db 成功后，db 版本为 11/12 的数据库需要使用 opatch 工具
  case "$db_version" in
  "11" | "12")
    run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      # 修改远程主机上的文件所有权以便 oracle 用户可以操作
      ssh -q "${rac_public_ips[i]}" "chown -R oracle:oinstall $software_dir"
      run_as_oracle "ssh -q ${rac_public_ips[i]} unzip -oq $db_opatch_name -d $env_oracle_home"
    done
    ;;
  esac
  # 所有 db 版本都安装 ojvm 补丁
  if [[ "$oracle_install_mode" = "rac" ]]; then
    color_printf blue "节点 $local_ip ："
  fi
  # 所有版本安装 OJVM 补丁
  su - oracle <<-EOF
cd $software_dir/$ojvm_patch
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
  if [[ "$oracle_install_mode" = "rac" ]]; then
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      echo
      color_printf blue "节点 ${rac_public_ips[i]} ："
      ssh -q "${rac_public_ips[i]}" "su - oracle <<-EOF
cd $software_dir/$ojvm_patch
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
    done
  fi
}
#==============================================================#
#                           配置监听                            #
#==============================================================#
# 配置NetCA监听器
function conf_netca() {
  # 检查Oracle安装模式是否为单实例，以及 listener.ora 文件是否存在
  if [[ "$oracle_install_mode" = "single" ]] && ! check_file "$env_oracle_home"/network/admin/listener.ora; then
    # 如果 netca.rsp 文件存在则执行 netca 配置命令
    if check_file "$env_oracle_home"/assistants/netca/netca.rsp; then
      log_print "静默安装 Oracle 软件命令"
      local netca_cmd
      netca_cmd=$(echo -e "$env_oracle_home/bin/netca -silent \\
-responsefile $env_oracle_home/assistants/netca/netca.rsp")
      color_printf blue "$netca_cmd"
      log_print "创建监听"
      color_printf blue "正在创建监听："
      run_as_oracle "$netca_cmd"
    fi
  fi
  # 输出检查监听状态的提示信息
  echo
  log_print "检查监听状态"
  # 使用oracle用户执行lsnrctl stat命令来检查监听状态
  run_as_oracle "lsnrctl stat"
}
#==============================================================#
#                          配置建库命令                          #
#==============================================================#
function get_dbca_cmd() {
  local dbname=$1
  local nums=$2
  # 数据库内存总和(MB) = 物理内存的 80%
  ((db_memory_total = os_memory_total * 4 / 5 / 1024 / nums))
  log_print "静默建库命令：$dbname"
  case "$db_version" in
  "11")
    # 数据库版本是11
    if [[ $enable_arch = "true" ]]; then
      # 同意使用归档日志模式
      sed -i 's/<archiveLogMode>false<\/archiveLogMode>/<archiveLogMode>true<\/archiveLogMode>/g' "$env_oracle_home/assistants/dbca/templates/General_Purpose.dbc"
    fi
    case "$oracle_install_mode" in
    "rac")
      # Oracle 安装模式是 RAC (Real Application Cluster)
      local adg_str="-diskGroupName $data_asm_group \\
-storageType ASM \\
-listeners LISTENER \\
-nodeinfo $rac_hostname"
      ;;
    "standalone")
      # Oracle 安装模式是 Standalone
      adg_str="-diskGroupName $data_asm_group \\
-storageType ASM"
      ;;
    *)
      # Oracle 安装模式是单实例
      adg_str="-datafileDestination $oradata_dir \\
-storageType FS"
      ;;
    esac
    dbca_cmd=$(echo -e "$env_oracle_home/bin/dbca -silent -createDatabase \\
-templateName General_Purpose.dbc \\
-responseFile NO_VALUE \\
-gdbname $dbname \\
-sid $dbname \\
-sysPassword $database_passwd \\
-systemPassword $database_passwd \\
-redoLogFileSize $redosize \\
$adg_str \\
-characterSet $db_characterset \\
-nationalCharacterSet $nation_characterset \\
-emConfiguration NONE \\
-automaticMemoryManagement false \\
-totalMemory $db_memory_total \\
-databaseType OLTP")
    ;;
  "12" | "19" | "21" | "23")
    # 数据库版本是12、19、21或23
    case "$oracle_install_mode" in
    "rac")
      # Oracle 安装模式是 RAC (Real Application Cluster)
      adg_str="-diskGroupName +$data_asm_group \\
-storageType ASM -enableArchive $enable_arch \\
-archiveLogDest +$data_asm_group \\
-databaseConfigType RAC \\
-nodeinfo $rac_hostname"
      ;;
    "standalone")
      # Oracle 安装模式是 Standalone
      adg_str="-diskGroupName +$data_asm_group \\
-storageType ASM \\
-enableArchive $enable_arch \\
-archiveLogDest +$data_asm_group \\
-databaseConfigType SINGLE"
      ## 12.2 Oracle Restart: LFI-00133 LFI-01517 occurred when using srvctl (Doc ID 2387137.1)
      if [[ "$db_version" = 12 ]]; then
        check_file "$env_oracle_home/log/$dbname" || mkdir -p "$env_oracle_home/log/$dbname"
        chown -R oracle:oinstall "$env_oracle_home/log/$dbname"
      fi
      ;;
    *)
      # 单实例
      adg_str="-datafileDestination $oradata_dir \\
-storageType FS \\
-enableArchive $enable_arch \\
-archiveLogDest $oradata_dir \\
-databaseConfigType SINGLE"
      ;;
    esac
    dbca_cmd=$(echo -e "$env_oracle_home/bin/dbca -silent -createDatabase \\
-ignorePrereqFailure \\
-templateName General_Purpose.dbc \\
-responseFile NO_VALUE \\
-gdbName $dbname \\
-sid $dbname \\
-sysPassword $database_passwd \\
-systemPassword $database_passwd \\
-redoLogFileSize $redosize \\
$adg_str \\
-characterset $db_characterset \\
-nationalCharacterSet $nation_characterset \\
-emConfiguration NONE \\
-automaticMemoryManagement false \\
-totalMemory $db_memory_total \\
-databaseType OLTP \\
-createAsContainerDatabase $iscdb")
    ;;
  esac
  color_printf blue "$dbca_cmd"
}
#==============================================================#
#                           创建数据库                           #
#==============================================================#
# 创建数据库
function create_db() {
  # 获取建库命令并打印
  for ((i = 0; i < ${#db_names[@]}; i++)); do
    local dbname=${db_names[i]}
    get_dbca_cmd "$dbname" ${#db_names[@]}
    # 打印日志到终端和文件
    log_print "创建数据库实例：$dbname"
    color_printf blue "正在创建数据库：$dbname"
    run_as_oracle "$dbca_cmd"
    # 配置 Oracle Managed Files（OMF）
    conf_omf "$dbname"
    # 创建 PDB
    if [[ $iscdb = "true" ]]; then
      create_pdb "$dbname"
    fi
  done
  # 配置 sqlnet.ora 文件
  conf_sqlnet
}
#==============================================================#
#                       创建 PDB数据库                           #
#==============================================================#
# 创建 PDB 数据库
function create_pdb() {
  local dbname=$1
  # 打印日志到终端和文件
  log_print "创建 PDB 数据库"
  # 如果启用了多租户架构，则创建可插入数据库 (PDB)
  for pdbs in ${pdbname//,/ }; do
    color_printf blue "正在创建 PDB：$pdbs"
    execute_sqlplus "$dbname" "" "create pluggable database $pdbs admin user admin identified by $database_passwd;
alter pluggable database all open;
alter pluggable database all save state;
alter session set container=$pdbs;
alter profile default limit password_life_time unlimited;"
  done
  # 查看 pdb
  execute_sqlplus "$dbname" "" "show pdbs"
}
#==============================================================#
#                         配置 SQLNET                              #
#==============================================================#
# 配置 SQLNET.ORA
function conf_sqlnet() {
  # 配置 sqlnet.ora 文件
  if check_file "$env_oracle_home/network/admin/sqlnet.ora"; then
    bak_file "$env_oracle_home/network/admin/sqlnet.ora"
  fi
  run_as_oracle "cat <<-EOF >>$env_oracle_home/network/admin/sqlnet.ora
SQLNET.ALLOWED_LOGON_VERSION_CLIENT=8
SQLNET.ALLOWED_LOGON_VERSION_SERVER=8
EOF"
  if [[ "$oracle_install_mode" = "rac" ]]; then
    # 将 sqlnet.ora 文件复制到其他节点
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      scp -q "$env_oracle_home/network/admin/sqlnet.ora" "${rac_public_ips[i]}:$env_oracle_home/network/admin/"
    done
  fi
}
#==============================================================#
#                         配置 OMF                              #
#==============================================================#
# 配置 OMF 以及优化 RMAN
function conf_omf() {
  log_print "配置 OMF && 优化 RMAN"
  # 定义 omf 变量，判断版本在11以后是否需要在路径前添加 + 符号
  local omf
  local dbname=$1
  # 如果安装模式为 rac，则获取数据组存储的路径；否则使用 oradata_dir 变量定义的路径。
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    omf=+$data_asm_group
    # 判断是否存在归档日志组磁盘路径，如果存在，则获取 arch_asm_group 存储路径；否则使用 omf 变量定义的路径。
    if [[ $arch_base_disk ]]; then
      local arch=+$arch_asm_group
    else
      arch=$omf
    fi
    # 使用 su 命令以 oracle 用户身份执行 rman 命令，配置控制文件备份地址\
    su - oracle <<-SO
source /home/oracle/.$dbname
rman target / <<-EOF
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '$omf/snapcf_fdcdb1.f';
SHOW SNAPSHOT CONTROLFILE NAME;
EOF
SO
  else
    # 获取 oradata 目录的存储路径
    omf=$oradata_dir
    # 获取归档日志组存储路径
    arch=$oradata_dir/archivelog
  fi
  # 使用 su 命令以 oracle 用户身份执行 sqlplus 命令，配置数据库链接、redo log 和归档日志的存储路径
  execute_sqlplus "$dbname" "" "alter system set db_create_file_dest='$omf';
alter system set log_archive_dest_1='location=$arch';
show parameter db_create_file_dest;"
}
#==============================================================#
#                          配置控制文件                          #
#==============================================================#
function conf_controlfile() {
  log_print "配置 Oracle 数据库控制文件复用"
  local dbname=$1
  # 获取控制文件数量
  local ctl_count
  ctl_count=$(execute_sqlplus "$dbname" "set pagesize 0" "select count(*) from v\$controlfile;" | tr -d '[:space:]')
  # 如果控制文件数量只有1个，则增加一个控制文件
  if ((ctl_count == 1)); then
    local ctl_name
    ctl_name=$(execute_sqlplus "$dbname" "set pagesize 0" "select name from v\$controlfile;" | tr -d '[:space:]')
    local ctl_name_new
    # 如果是 RAC，则将新增的控制寄文件存放在 OCR 磁盘组中
    if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
      ctl_name_new=$(execute_sqlplus "$dbname" "set pagesize 0" "select substr(replace(name,substr(name,1,instr(name,'/',1)-1),'+$data_asm_group'),1,instr(name,'/',-1)-1) || '/control02.ctl' from v\$controlfile where name = '$ctl_name';" | tr -d '[:space:]')
      # 重启数据库至 nomount 状态
      run_as_oracle "srvctl stop database -d $dbname"
      run_as_oracle "srvctl start database -d $dbname -o nomount"
    else
      # 单机模式则直接存放在 ORACLE_HOME/dbs 目录下
      ctl_name_new="$env_oracle_home/dbs/control02.ctl"
      # 重启数据库至 nomount 状态
      execute_sqlplus "$dbname" "" "shu immediate;
startup nomount;"
    fi
    # 从原来的控制文件恢复一个新的控制文件
    su - oracle <<-SO
source /home/oracle/.$dbname
rman target / <<-EOF
restore controlfile to '$ctl_name_new' from '$ctl_name';
EOF
SO
    # 修改数据库控制文件参数
    execute_sqlplus "$dbname" "" "alter system set control_files='$ctl_name','$ctl_name_new' scope=spfile;"
    # 重启数据库生效参数
    if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
      run_as_oracle "srvctl stop database -d $dbname"
      run_as_oracle "srvctl start database -d $dbname"
    else
      execute_sqlplus "$dbname" "" "shu immediate;
startup;"
    fi
  fi
  # 查询当前数据库控制文件
  echo
  color_printf blue "数据库控制文件："
  execute_sqlplus "$dbname" "col name for a100" "select name from v\$controlfile;"
}
#==============================================================#
#                    Configure redolog                         #
#==============================================================#
function conf_redolog() {
  log_print "配置在线重做日志"
  local dbname=$1
  # 函数中如果有循环变量 i，建议加上 local 定义，否则可能会影响外部调用该函数时的 i 变量值
  local i
  local thread
  if [[ "$oracle_install_mode" = "rac" ]]; then
    # 将 sqlnet.ora 文件复制到其他节点
    for ((i = 0; i < ${#rac_public_ips[@]}; i++)); do
      ((thread = i + 1))
      execute_sqlplus "$dbname" "" "alter database add logfile thread $thread
group ${thread}1 size ${redosize}M,
group ${thread}2 size ${redosize}M,
group ${thread}3 size ${redosize}M,
group ${thread}4 size ${redosize}M,
group ${thread}5 size ${redosize}M;"
    done
  else
    execute_sqlplus "$dbname" "" "alter database add logfile
group 11 size ${redosize}M,
group 12 size ${redosize}M,
group 13 size ${redosize}M,
group 14 size ${redosize}M,
group 15 size ${redosize}M;"
  fi
  # 查询当前数据库在线重做日志
  color_printf blue "数据库在线重做日志文件："
  execute_sqlplus "$dbname" "col member for a120" "select a.thread#,a.group#,b.member member,a.bytes/1024/1024 \"size(M)\" from v\$log a,v\$logfile b where a.group#=b.group# order by 1,2;"
}
#==============================================================#
#                       配置数据库开机自启                        #
#==============================================================#
function db_autostart() {
  log_print "配置 Oracle 数据库开机自启"
  local dbname=$1
  # 备份 oratab 文件
  bak_file /etc/oratab
  # 查询当前数据库在线重做日志
  # 修改 oratab 文件，将数据库自动启动状态改为 Y
  sed -i 's/db:N/db:Y/' /etc/oratab
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    if [[ "$gi_version" = "11" ]]; then
      # 修改资源配置，设置数据库自动启动
      "$env_grid_home"/bin/crsctl modify resource "ora.$dbname.db" -attr "AUTO_START=always"
    else
      # 该版本修改数据库自动启动方式不受支持，需要在命令中添加 -unsupported 参数
      "$env_grid_home"/bin/crsctl modify resource "ora.$dbname.db" -attr "AUTO_START=always" -unsupported
    fi
    color_printf blue "数据库开机自启配置："
    "$env_grid_home"/bin/crsctl stat res "ora.$dbname.db" -p | grep AUTO_START
  else
    color_printf blue "数据库开机自启配置："
    # 修改 dbstart 脚本，将变量 ORACLE_HOME_LISTNER 的值改为 $ORACLE_HOME
    sed -i "s/ORACLE_HOME_LISTNER=\$1/ORACLE_HOME_LISTNER=$ORACLE_HOME/" "$env_oracle_home/bin/dbstart"
    # sles 没有 rc.local 文件，需要使用 after.local
    if [[ "$os_type" = "sles" ]]; then
      # 备份 after.local 文件
      bak_file /etc/rc.d/after.local
      # 在 after.local 文件中添加启动监听器和数据库的命令，并配置权限为可执行
      write_file "N" "/etc/rc.d/after.local" "#!/bin/bash
# OracleBegin
su oracle -lc \"$env_oracle_home/bin/lsnrctl start\"
su oracle -lc \"$env_oracle_home/bin/dbstart\""
      chmod +x /etc/rc.d/after.local
      cat /etc/rc.d/after.local
    else
      # 备份 rc.local 文件
      bak_file /etc/rc.d/rc.local
      # 在 rc.local 文件中添加启动监听器和数据库的命令，并配置权限为可执行
      if ! grep '#!/bin/bash' /etc/rc.d/rc.local >/dev/null 2>&1; then
        write_file "N" "/etc/rc.d/rc.local" "#!/bin/bash"
      fi
      write_file "N" "/etc/rc.d/rc.local" "# OracleBegin
su oracle -lc \"$env_oracle_home/bin/lsnrctl start\"
su oracle -lc \"$env_oracle_home/bin/dbstart\""
      chmod +x /etc/rc.d/rc.local
      cat /etc/rc.d/rc.local
    fi
  fi
}
#==============================================================#
#                      配置 RMAN 备份脚本                        #
#==============================================================#
function db_backup() {
  log_print "配置 RMAN 备份任务"
  local dbname=$1
  local scripts_dir="/home/oracle/scripts"
  local rman_log_dir="/backup"
  # 共用的 RMAN 配置参数
  local rman_config
  rman_config=$(
    cat <<-RMAN
allocate channel c1 device type disk;
allocate channel c2 device type disk;
crosscheck backup;
crosscheck archivelog all;
sql"alter system archive log current";
delete noprompt expired backup;
delete noprompt obsolete device type disk;
backup not backed up 1 times as compressed backupset archivelog all format '/backup/arch_%d_%T_%t_%s_%p';
RMAN
  )
  # 删除过期归档日志脚本
  local del_arch_script="$scripts_dir/del_arch_$dbname.sh"
  cat >"$del_arch_script" <<DELARCH
#!/bin/bash
source ~/.$dbname
deltime=\$(date +"20%y%m%d%H%M%S")
rman target / nocatalog msglog $scripts_dir/del_arch_\$deltime.log <<-EOF
crosscheck archivelog all;
delete noprompt archivelog until time 'sysdate-7';
delete noprompt force archivelog until time 'SYSDATE-10';
EOF
DELARCH
  chmod +x "$del_arch_script"
  # Level 0 备份脚本
  local lv0_backup_script="$scripts_dir/dbbackup_lv0_$dbname.sh"
  cat >"$lv0_backup_script" <<LV0BACKUP
#!/bin/bash
source ~/.$dbname
backtime=\$(date +"20%y%m%d%H%M%S")
rman target / log=$rman_log_dir/level0_backup_\$backtime.log<<-EOF
run {
$rman_config
backup incremental level 0 database include current controlfile format '/backup/backlv0_%d_%T_%t_%s_%p';
}
EOF
LV0BACKUP
  chmod +x "$lv0_backup_script"
  # Level 1 备份脚本
  local lv1_backup_script="$scripts_dir/dbbackup_lv1_$dbname.sh"
  cat >"$lv1_backup_script" <<LV1BACKUP
#!/bin/bash
source ~/.$dbname
backtime=\$(date +"20%y%m%d%H%M%S")
rman target / log=$rman_log_dir/level1_backup_\$backtime.log<<-EOF
run {
$rman_config
backup incremental level 1 database include current controlfile format '/backup/backlv1_%d_%T_%t_%s_%p';
}
EOF
LV1BACKUP
  chmod +x "$lv1_backup_script"
  # 添加 crontab 计划任务
  local crontab_file="/var/spool/cron/oracle"
  if check_file "$crontab_file"; then
    bak_file "$crontab_file"
  else
    # 不存在文件时，生成一个原始空文件
    touch /var/spool/cron/oracle.original
  fi
  write_file "N" "$crontab_file" "## OracleBegin
00 02 * * * $del_arch_script
#00 00 * * 0 $lv0_backup_script
#00 00 * * 1,2,3,4,5,6 $lv1_backup_script"
  if check_file /etc/cron.allow; then
    write_file "N" "/etc/cron.allow" "oracle"
  fi
  chown -R oracle:oinstall "$scripts_dir" "$rman_log_dir"
  cat /var/spool/cron/oracle
}
#==============================================================#
#                        优化数据库参数                          #
#==============================================================#
function conf_para() {
  log_print "优化数据库参数"
  local dbname=$1
  local nums=$2
  local sga_target
  local pga_target
  # memory for db sga_size(MB) = os_memory_total * 0.8 * 0.8 / 1024
  ((sga_target = (os_memory_total * 8 * 8 / 100 / 1024 / nums)))
  sga_target="${sga_target}M"
  # memory for db pga_size(MB) = os_memory_total * 0.8 * 0.2 / 1024
  ((pga_target = (os_memory_total * 8 * 2 / 100 / 1024 / nums)))
  pga_target="${pga_target}M"
  # just rac
  if [[ "$oracle_install_mode" = "rac" ]]; then
    execute_sqlplus "$dbname" "" "alter system set parallel_force_local=true sid='*' scope=spfile;
alter system set \"_gc_policy_time\"=0 scope=spfile;
alter system set \"_gc_undo_affinity\"=false scope=spfile;
alter system set \"_clusterwide_global_transactions\"=FALSE scope=spfile;"
  fi
  # rac and single
  execute_sqlplus "$dbname" "" "exec dbms_scheduler.disable('ORACLE_OCM.MGMT_CONFIG_JOB');
exec dbms_scheduler.disable('ORACLE_OCM.MGMT_STATS_CONFIG_JOB');
BEGIN
DBMS_AUTO_TASK_ADMIN.DISABLE(
client_name => 'auto space advisor',
operation => NULL,
window_name => NULL);
END;
/
BEGIN
DBMS_AUTO_TASK_ADMIN.DISABLE(
client_name => 'sql tuning advisor',
operation => NULL,
window_name => NULL);
END;
/
alter profile default limit password_grace_time unlimited;
alter profile default limit password_life_time unlimited;
alter profile default limit password_lock_time unlimited;
alter profile default limit failed_login_attempts unlimited;
alter system set audit_trail=none sid='*' scope=spfile;
alter system set sga_max_size=$sga_target sid='*' scope=spfile;
alter system set sga_target=$sga_target sid='*' scope=spfile;
alter system set pga_aggregate_target=$pga_target sid='*' scope=spfile;
alter system set processes=2000 scope=spfile;
alter system set open_cursors=1000 scope=spfile;
alter system set session_cached_cursors=300 scope=spfile;
alter system set db_files=5000 scope=spfile;
alter system set \"_undo_autotune\"=false sid='*' scope=spfile;
alter system set undo_retention=10800 scope=spfile;
alter system set control_file_record_keep_time=31;
alter system set event='28401 trace name context forever,level 1','10949 trace name context forever,level 1' sid='*' scope=spfile;
alter system set \"_b_tree_bitmap_plans\"=false sid='*';
alter system set deferred_segment_creation=false sid='*';
alter system set \"_optimizer_adaptive_cursor_sharing\"=false sid='*' scope=spfile;
alter system set \"_optimizer_extended_cursor_sharing\"=none sid='*' scope=spfile;
alter system set \"_optimizer_extended_cursor_sharing_rel\"=none sid='*' scope=spfile;
alter system set \"_optimizer_use_feedback\"=false sid ='*' scope=spfile;
alter system set \"_cleanup_rollback_entries\"=2000 sid='*' scope=spfile;
alter system set \"_datafile_write_errors_crash_instance\"=false sid='*';
alter system set parallel_max_servers=64 sid='*';"
  # for 11g implied parameters
  if [[ "$db_version" = "11" ]]; then
    execute_sqlplus "$dbname" "" "alter system set resource_limit=true sid='*' scope=spfile;
alter system set resource_manager_plan='force:' sid='*' scope=spfile;
alter system set \"_optimizer_null_aware_antijoin\"=false sid ='*' scope=spfile;
alter system set \"_px_use_large_pool\"=true sid ='*' scope=spfile;
alter system set \"_partition_large_extents\"=false sid='*' scope=spfile;
alter system set \"_index_partition_large_extents\"=false sid='*' scope=spfile;
alter system set \"_use_adaptive_log_file_sync\"=false sid='*' scope=spfile;
alter system set \"_memory_imm_mode_without_autosga\"=false sid='*' scope=spfile;
alter system set enable_ddl_logging=true sid='*' scope=spfile;
alter system set sec_case_sensitive_logon=false sid='*' scope=spfile;"
  fi
  color_printf blue "数据库参数："
  # 查看数据库参数
  execute_sqlplus "$dbname" "col name for a50
col sid for a10
col spvalue for a80
col VALUE for a80" "SELECT DISTINCT s.name,
                s.sid,
                s.value spvalue,
                p.value VALUE
  FROM v\$spparameter s,
       gv\$parameter  p
 WHERE s.name = p.name
   AND (s.value IS NOT NULL OR (p.name IN ('statistics_level',
                                           'processes',
                                           'sessions',
                                           'db_files',
                                           'spfile',
                                           'optimizer_adaptive_features',
                                           'optimizer_adaptive_plans',
                                           'optimizer_adaptive_statistics',
                                           'max_string_size',
                                           'control_file_record_keep_time',
                                           '_use_adaptive_log_file_sync',
                                           'fast_start_parallel_rollback',
                                           '_datafile_write_errors_crash_instance',
                                           'max_dump_file_size',
                                           'parallel_max_servers',
                                           'deferred_segment_creation',
                                           '_optimizer_use_feedback',
                                           'open_cursors',
                                           'session_cached_cursors',
                                           'OPTIMIZER_INDEX_COST_ADJ',
                                           'optimizer_index_caching',
                                           'audit_trail',
                                           'SEC_CASE_SENSITIVE_LOGON',
                                           'parallel_force_local',
                                           'db_file_multiblock_read_count',
                                           'event',
                                           'dispatchers',
                                           'db_writer_processes',
                                           'optimizer_mode')))
   AND p.name NOT IN ('thread',
                      'instance_name',
                      'instance_number',
                      'undo_tablespace',
                      'local_listener',
                      'remote_listener',
                      'lisneter_network',
                      'control_files')
 ORDER BY s.name;"
}
#==============================================================#
#                         配置大页内存                           #
#==============================================================#
function conf_hugepage() {
  log_print "配置大页内存"
  # 获取当前系统的内核版本
  local KERN
  KERN=$(uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }')
  # 获取系统支持的 HugePage 大小
  local HPG_SZ
  HPG_SZ=$(grep Hugepagesize /proc/meminfo | awk '{print $2}')
  if [ -z "$HPG_SZ" ]; then
    color_printf yellow "在当前系统中不支持 HugePages!"
    echo
    return 1
  fi
  # 初始化计数器，累加所需的 HugePages 数量
  local NUM_PG=0
  local MIN_PG
  for SEG_BYTES in $(ipcs -m | cut -c44-300 | awk '{print $1}' | grep "[0-9][0-9]*"); do
    MIN_PG=$(echo "$SEG_BYTES/($HPG_SZ*1024)" | bc -q)
    if ((MIN_PG > 0)); then
      NUM_PG=$(echo "$NUM_PG+$MIN_PG+1" | bc -q)
    fi
  done
  # 计算所需的 HugePages 总大小（以字节为单位）
  local RES_BYTES
  RES_BYTES=$(echo "$NUM_PG * $HPG_SZ * 1024" | bc -q)
  # 如果需要使用 HugePages 的共享内存段总大小小于 100MB，则无法配置成功
  if ((RES_BYTES < 100000000)); then
    color_printf yellow "无法为 HugePages 配置分配足够的共享内存段。HugePages 只能用于大小与 Oracle 数据库 SGA 匹配的共享内存段。请确保：
* Oracle 数据库实例正在运行；
* Oracle 数据库 11g 自动内存管理（AMM）未配置!"
    echo
    return 1
  fi
  # 根据不同的内核版本，采用不同的 HugePages 配置方式
  case $KERN in
  "2.4")
    # 对于 2.4 版本的内核，使用 hugetlbfs 模式，并设置 vm.hugetlb_pool 参数
    local HUGETLB_POOL
    HUGETLB_POOL=$(echo "$NUM_PG*$HPG_SZ/1024" | bc -q)
    echo "建议的参数设置：vm.hugetlb_pool = $HUGETLB_POOL"
    sysctl -w vm.hugetlb_pool="$HUGETLB_POOL"
    write_file "N" "/etc/sysctl.conf" "vm.hugetlb_pool=$HUGETLB_POOL"
    if [[ "$oracle_install_mode" = "rac" ]]; then
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        ssh -q "${rac_public_ips[i]}" sysctl -w vm.hugetlb_pool="$HUGETLB_POOL"
        ssh -q "${rac_public_ips[i]}" "cat <<-EOF >>/etc/sysctl.conf
vm.hugetlb_pool=$HUGETLB_POOL
EOF"
      done
    fi
    ;;
  "2.6" | "3.8" | "3.10" | "4.1" | "4.14" | "4.18" | "5.4")
    # 对于其他版本的内核，直接设置 vm.nr_hugepages 参数即可
    echo "建议的参数设置：vm.nr_hugepages = $NUM_PG"
    sysctl -w vm.nr_hugepages="$NUM_PG"
    write_file "N" "/etc/sysctl.conf" "vm.nr_hugepages=$NUM_PG"
    if [[ "$oracle_install_mode" = "rac" ]]; then
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        ssh -q "${rac_public_ips[i]}" sysctl -w vm.nr_hugepages="$NUM_PG"
        ssh -q "${rac_public_ips[i]}" "cat <<-EOF >>/etc/sysctl.conf
vm.nr_hugepages=$NUM_PG
EOF"
      done
    fi
    ;;
  *)
    echo "当前内核版本 $KERN 不受此脚本支持。"
    ;;
  esac
  grep HugePages_Total /proc/meminfo
}
#==============================================================#
#                       配置 glogin.sql                         #
#==============================================================#
function conf_glogin() {
  log_print "配置 glogin.sql"
  bak_file "$env_oracle_home/sqlplus/admin/glogin.sql"
  write_file "Y" "$env_oracle_home/sqlplus/admin/glogin.sql" "define _editor=vi
set serveroutput on size 1000000
set pagesize 9999
set long 99999
set trimspool on
col name format a80
set termout off
define gname=idle
column global_name new_value gname
select lower(user) || '@' || substr( global_name, 1, decode( dot, 0, length(global_name), dot-1) ) global_name from (select global_name, instr(global_name,'.') dot from global_name );
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
set sqlprompt '&gname _DATE> '
set termout on"
  if [[ "$oracle_install_mode" = "rac" ]]; then
    bak_file "$env_grid_home"/sqlplus/admin/glogin.sql
    write_file "Y" "$env_grid_home/sqlplus/admin/glogin.sql" "define _editor=vi
set serveroutput on size 1000000
set pagesize 9999
set long 99999
set trimspool on
col name format a80
set termout off
define gname=idle
column global_name new_value gname
select lower(user) || '@' || substr( global_name, 1, decode( dot, 0, length(global_name), dot-1) ) global_name from (select global_name, instr(global_name,'.') dot from global_name );
ALTER SESSION SET nls_date_format = 'YYYY-MM-DD HH24:MI:SS';
set sqlprompt '&gname _DATE> '
set termout on"
    for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
      run_as_oracle "scp -q $env_oracle_home/sqlplus/admin/glogin.sql ${rac_public_ips[i]}:$env_oracle_home/sqlplus/admin/"
      run_as_grid "scp -q $env_grid_home/sqlplus/admin/glogin.sql ${rac_public_ips[i]}:$env_grid_home/sqlplus/admin/"
    done
  fi
  grep -v "^\s*\(#\|$\|--\)" "$env_oracle_home"/sqlplus/admin/glogin.sql
}
#==============================================================#
#                          优化数据库                            #
#==============================================================#
function db_optimize() {
  for ((i = 0; i < ${#db_names[@]}; i++)); do
    local dbname=${db_names[i]}
    conf_controlfile "$dbname"
    conf_redolog "$dbname"
    db_autostart "$dbname"
    db_backup "$dbname"
    conf_para "$dbname" ${#db_names[@]}
  done
  # 物理内存大于100G，配置大页内存
  if ((os_memory_total > 104857600)); then
    conf_hugepage
  fi
  conf_glogin
}
#==============================================================#
#                          主机是否重启                          #
#==============================================================#
function ask_for_reboot() {
  declare -u isreboot
  read -rep "$(echo -e "\033[1;34m$1 \E[0m")" isreboot
  echo
  if [[ $isreboot = "Y" ]]; then
    if [[ "$oracle_install_mode" = "rac" ]]; then
      for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
        color_printf blue "正在重启节点 ${rac_public_ips[i]} 主机......"
        ssh -q "${rac_public_ips[i]}" shutdown -r now
      done
    fi
    color_printf blue "正在重启当前节点主机......"
    shutdown -r now
  else
    exit 1
  fi
}
#==============================================================#
#                            主函数                             #
#==============================================================#
function main() {
  # 打印脚本 Logo
  logo_print
  echo
  color_printf yellow "注意：本脚本仅用于新服务器上实施部署数据库使用，严禁在已运行数据库的主机上执行，以免发生数据丢失或者损坏，造成不可挽回的损失！！！"
  # 检查脚本路径
  if [[ "$(dirname "$(readlink -f "$0")")" != "/soft" ]]; then
    color_printf yellow "注意：建议将 Oracle 软件安装包以及脚本放到 /soft 目录下并在 /soft 目录下执行脚本，否则可能会失败!"
  fi
  # 检查脚本名称是否为 OracleShellInstall
  if [[ "$(basename "$0")" != "OracleShellInstall" ]]; then
    color_printf red "本脚本不允许修改脚本名称，请修改回：OracleShellInstall，已退出!"
  fi
  # 判断当前执行脚本用户是否为 root 用户
  if [ "$(id -u)" != 0 ]; then
    color_printf red "本脚本需要使用 root 用户执行，已退出!"
  fi
  # 脚本传参赋值校验
  check_para "$@"
  # 改写支持同时创建多个数据库实例
  IFS=',' read -ra db_names <<<"$db_name"
  # 选择安装模式以及版本
  if [[ -z "$oracle_install_mode" ]]; then
    select_install_mode
  fi
  if [[ -z "$db_version" ]]; then
    select_db_version
  fi
  # 安装日志提示
  color_printf green "OracleShellInstall 开始安装，详细安装过程可查看日志： tail -2000f $oracleinstalllog"
  echo
  # 记录脚本安装开始执行时间
  local install_start_time
  install_start_time=$(date +%s)
  # 设置 Oracle 数据库和 Grid 基本目录
  # Oracle数据库基本目录，默认为 /u01/app/oracle
  env_oracle_base=$env_base_dir/app/oracle
  # Oracle oraInventory 基本目录，默认为 /u01/app/oraInventory
  env_oracle_inven=$env_base_dir/app/oraInventory
  if [[ "$gi_version" ]]; then
    # Oracle Grid 基本目录，默认为 /u01/app/grid
    env_grid_base=$env_base_dir/app/grid
    # 获取 Grid 版本以及安装包数组
    get_grid_soft
    # 获取SCAN名称，如果没有传参SCAN名称，则默认主机名前缀-scan为SCAN名称
    if [[ -z $scan_name ]]; then
      scan_name=$hostname-scan
    fi
  fi
  # 获取 Oracle 版本以及安装包数组
  get_db_soft
  # 获取操作系统信息
  get_os_info
  # 检查操作系统是否符合安装条件
  check_os_version
  # 去除密码复杂度
  execute_and_log "正在去除密码复杂度配置" remove_password_complexity
  # 适配麒麟 V10、openEuler 22.03 LTS SP3、SUSE 15 SP5、鸿蒙系统、Fedora 35 对应 8
  adapt_os_version
  # 检查是否需要挂载 ISO 镜像源
  if [[ $iso = "Y" && $os_type != "fedora" ]]; then
    check_iso
  fi
  # rac 需要安装 expect 和 openssh-clients
  if [[ "$oracle_install_mode" = "rac" ]]; then
    # 如果需要配置互信，则安装 expect 软件
    install_packages_if_not_present "expect" "openssh-clients"
  fi
  # 当前主节点检查配置
  if [[ $node_num = 1 ]]; then
    check_and_conf_local_node
  fi
  # 针对 RAC 所有节点配置
  if [[ "$oracle_install_mode" = "rac" ]]; then
    check_and_conf_all_node
  fi
  # 用于清理 oracle 安装旧环境
  if [[ $(find /etc -maxdepth 1 ! -name "oracle-release" -name "ora*") ]]; then
    execute_and_log "正在清理 Oracle 旧环境" clean_old_envir
  fi
  ## 打印系统信息
  execute_and_log "正在获取操作系统信息" print_sysinfo
  # 系统配置
  execute_and_log "正在配置 Swap" conf_swap
  execute_and_log "正在配置防火墙" conf_firewall
  if [[ "$os_type" != "sles" ]]; then
    execute_and_log "正在配置 selinux" conf_selinux
    execute_and_log "正在配置 nsyctl" conf_nsysctl
  fi
  execute_and_log "正在安装依赖包" rpm_install
  execute_and_log "正在配置主机名和 /etc/hosts" conf_hostname
  conf_hosts
  execute_and_log "正在创建用户和组" create_users_groups
  execute_and_log "正在创建安装目录" create_dir
  execute_and_log "正在配置 Avahi-daemon 服务" conf_avahi
  execute_and_log "正在配置透明大页 && NUMA && 磁盘 IO 调度器" conf_grub
  execute_and_log "正在配置操作系统参数 sysctl" conf_sysctl
  if [[ "$os_version" != "6" ]]; then
    execute_and_log "正在配置 RemoveIPC" conf_ipc
  fi
  execute_and_log "正在配置用户限制 limit" conf_limits
  execute_and_log "正在配置 shm 目录" conf_shm
  # 判断是否已安装 rlwrap
  if ! hash rlwrap 2>/dev/null; then
    execute_and_log "正在安装 rlwrap 插件" install_rlwrap
  fi
  execute_and_log "正在配置用户环境变量" conf_profile
  # 单机模式安装
  install_single_mode() {
    execute_and_log "正在解压 Oracle 安装包以及补丁" unzip_dbsoft
    if [[ $only_conf_os = "N" ]]; then
      execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
      execute_and_log "正在创建监听" conf_netca
      if [[ $install_until_db = "N" ]]; then
        execute_and_log "正在创建数据库" create_db
      fi
      if [[ $optimize_db = "Y" ]]; then
        execute_and_log "正在优化数据库" db_optimize
      fi
      # 记录和打印脚本命令执行完成的时间
      local install_end_time
      install_end_time=$(date +%s)
      local install_execution_time=$((install_end_time - install_start_time))
      echo
      ask_for_reboot "恭喜！Oracle 单机安装成功 (耗时: $install_execution_time 秒)，现在是否重启主机：[Y/N]"
    fi
  }
  # 单机 ASM 模式安装
  install_standalone_asm_mode() {
    if [[ $asm_disk_conf = "Y" ]]; then
      conf_asm
    fi
    execute_and_log "正在解压 Grid 安装包以及补丁" unzip_gridsoft
    execute_and_log "正在解压 Oracle 安装包以及补丁" unzip_dbsoft
    if [[ $only_conf_os = "N" ]]; then
      execute_and_log "正在安装 Grid 软件以及补丁" install_gridsoft
      execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
      if [[ $install_until_db = "N" ]]; then
        execute_and_log "正在创建数据库" create_db
      fi
      if [[ $optimize_db = "Y" ]]; then
        execute_and_log "正在优化数据库" db_optimize
      fi
      # 记录和打印脚本命令执行完成的时间
      local install_end_time
      install_end_time=$(date +%s)
      local install_execution_time=$((install_end_time - install_start_time))
      echo
      ask_for_reboot "恭喜！Oracle 单机 ASM 安装成功 (耗时: $install_execution_time 秒)，现在是否重启主机：[Y/N]"
    fi
  }
  # RAC 模式安装
  install_rac_mode() {
    if [[ $timeserver_ip ]]; then
      execute_and_log "正在配置时间同步" conf_timesync
    fi
    if [[ $dns = "Y" ]]; then
      execute_and_log "正在配置 DNS 解析" conf_dns
    fi
    if [[ $asm_disk_conf = "Y" ]]; then
      conf_asm
    fi
    if [[ $node_num = 1 ]]; then
      execute_and_log "正在配置 RAC 其他节点信息" other_node_shell
      execute_and_log "正在配置 RAC 所有节点互信" rac_ssh
      execute_and_log "正在解压 Grid 安装包以及补丁" unzip_gridsoft
      execute_and_log "正在解压 Oracle 软件以及补丁" unzip_dbsoft
      if [[ $only_conf_os = "N" ]]; then
        execute_and_log "正在安装 Grid 软件以及补丁" install_gridsoft
        execute_and_log "正在创建 ASM 磁盘组" create_asmgroup
        if [[ $install_until_grid = "N" ]]; then
          execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
          if [[ $install_until_db = "N" ]]; then
            execute_and_log "正在创建数据库" create_db
          fi
        fi
        if [[ $optimize_db = "Y" ]]; then
          execute_and_log "正在优化数据库" db_optimize
        fi
        # 记录和打印脚本命令执行完成的时间
        local install_end_time
        install_end_time=$(date +%s)
        local install_execution_time=$((install_end_time - install_start_time))
        echo
        ask_for_reboot "恭喜！Oracle RAC 安装成功 (耗时: $install_execution_time 秒)，现在是否重启主机：[Y/N]"
      fi
    fi
  }
  # 判断 Oracle 安装模式
  case "$oracle_install_mode" in
  "single")
    install_single_mode
    ;;
  "standalone")
    install_standalone_asm_mode
    ;;
  "rac")
    install_rac_mode
    ;;
  esac
}
# 执行主函数
main "$@" | tee -a "$oracleprintlog"
