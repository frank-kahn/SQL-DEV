#!/usr/bin/env bash
#===============================================================================
# 文件名: OracleShellInstall
# 创建时间: 2022-06-18 12:32:09
# 修改时间: 2024-08-22 13:08:28
# 描述: Oracle Database Install for single/standlone/rac
# 路径: /soft/OracleShellInstall
# 版本: 5.0.0
# 作者: Lucifer(pc1107750981@163.com),bak724(bak724@163.com)
# 版权所有 (C) 2022-2099 Pengcheng Liu
#===============================================================================
# 导出 PS4 变量，以便 set -x 调试时输出行号和函数参数
export PS4='+${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}: '
#==============================================================#
#                         全局变量定义                           #
#==============================================================#
# 增加 bash 版本限制
bash_version=$(echo "$BASH_VERSION" | cut -d '.' -f1)
if [[ $bash_version ]] && ((bash_version < 4)); then
  printf "\n\E[1;31m%-20s\n\E[0m\n" "本脚本不支持 Bash 版本低于 4 执行安装，当前 Bash 版本为：$bash_version，已退出！"
  exit 1
fi
# 定义 rhel 系操作系统列表
rhel_os_list=(Red CentOS rhel centos ol rocky anolis uos kylin neokylin openEuler almalinux opencloudos ningos asianux NFS fedora euleros hce tencentos kos ctyunos)
# 定义 deb 系操作系统列表
deb_os_list=(debian ubuntu Deepin)
# 配置网络镜像源列表
net_os_list=(fedora euleros debian ubuntu Deepin arch hce)
# 配置本地镜像源列表
local_os_list=(Red CentOS rhel centos ol rocky anolis uos UOS kylin neokylin sles opensuse-leap opensuse-tumbleweed openEuler almalinux opencloudos ningos asianux NFS tencentos kos ctyunos)
# 定义未认证的国产化操作系统列表
unscertified_os_list=(rocky anolis kylin openEuler uos UOS fedora almalinux euleros ubuntu debian arch Deepin opencloudos ningos asianux NFS opensuse-leap opensuse-tumbleweed hce tencentos kos ctyunos)
# 定义 Oracle 官方认证的操作系统列表
oracle_certified_os_list=(centos CentOS Red rhel ol sles)
# 获取安装软件以及脚本目录（当前目录）
software_dir=$(dirname "$(readlink -f "$0")")
# 当前执行脚本系统时间
current=$(date +%Y%m%d%H%M%S)
# 删除脚本生成的 log 日志文件
find "$software_dir" -name "print_shell_install_*.log" -exec /bin/rm -rf {} +
find "$software_dir" -name "shell_install_output_*.log" -exec /bin/rm -rf {} +
# 脚本安装日志文件
oracleinstalllog=$software_dir/print_shell_install_$current.log
# 脚本输出日志文件
oracleprintlog=$software_dir/shell_install_output_$current.log
# 定义 os 认证标识
oracle_os_flag=NONE
# 物理内存（KB）
os_memory_total=$(awk '/MemTotal/{print $2}' /proc/meminfo)
# Swap 大小（KB）
swap_total=$(awk '/^SwapTotal:/ { print $2; }' /proc/meminfo)
# 计算额外需要的交换空间大小
((swap_count = (os_memory_total > 16777216 ? 16777216 : os_memory_total > 2097152 ? os_memory_total : os_memory_total * 3 / 2) - swap_total))
# 主机名称，单机和单机 ASM 模式是当前主机名；RAC 模式是主机名前缀；默认值为 orcl
hostname=orcl
# 数据库名称，默认值为 orcl，支持多个实例，传参以逗号隔开：orcl,oradb
db_name=orcl
# 是否 CDB 架构
declare -l iscdb=false
# PDB 名称，如果 PDB 名称有值，则默认为 CDB 架构，默认值为 pdb01，如果传入多个 PDB 名称，则创建多个 PDB，传参以逗号隔开：pdb01,pdb02,pdb03
pdbname=pdb01
# 系统用户 oracle 名称，默认值为 oracle
oracle_user=oracle
# 系统用户 oracle 密码，默认值为 oracle
oracle_passwd=oracle
# 数据库用户 sys/system 密码, 默认值为 oracle
database_passwd=oracle
# 数据库软件安装根目录，默认值为 /u01
env_base_dir=/u01
# 单机数据库参数，数据文件目录，默认值为 /oradata
oradata_dir=/oradata
# 数据库备份目录，默认值为 /backup
backup_dir=/backup
# 数据库字符集，默认值为 AL32UTF8
declare -u db_characterset=AL32UTF8
# 数据库国家字符集，默认值为 AL16UTF16
declare -u nation_characterset=AL16UTF16
# 数据库块大小，默认值为 8192
db_block_size=8192
# 数据库在线重做日志大小，默认值为 1024，单位 MB
redosize=1024
# 数据库是否开启归档模式
declare -l enable_arch=true
# 仅配置操作系统，默认值为 N，包括配置操作系统以及解压软件安装包
declare -u only_conf_os=N
# 安装到 Grid 软件结束，默认值为 N
declare -u install_until_grid=N
# 安装到 Oracle 软件结束，默认值为 N
declare -u install_until_db=N
# 是否优化数据库参数，默认值为 N
declare -u optimize_db=N
# 数据库安装架构，分为单机和 RAC
declare -l oracle_install_mode
# 是否安装图形化界面，默认值为 N
declare -u isgui=N
# 默认配置本地源，默认值为 Y
declare -u local_repo=Y
# 默认不配置网络源，默认值为 N
declare -u net_repo=N
# 默认不配置大页内存，默认值为 N
declare -u huge_flag=N
#==============================================================#
#                      RAC 模式全局变量定义                       #
#==============================================================#
# RAC 节点号，默认为 1
node_num=1
# 定义一个存放所有 IP 的数组
declare -a allips
# 定义一个存放公网 IP 的数组
declare -a rac_public_ips
# 定义一个存放主机名的数组
declare -a rac_hostnames
# 定义一个存放 virtual ip 的数组
declare -a rac_virtual_ips
# 定义一个存放心跳网卡名称的数组
declare -a rac_priv_ifnames
# 定义一个存放 scan ip 的数组
declare -a rac_scan_ips
# 定义一个用于保存 root 用户需要设置 SSH 信任的 IP 地址
declare -a ssh_ips
# 定义用于保存心跳 IP 的关联数组
declare -A rac_priv_ips
# 定义数组 rac_priv_ifnames_sorted 用于存放排序后的 rac_priv_ifnames 数组
declare -a rac_priv_ifnames_sorted
# 用于存放 grid 静默文件 networkinterfacelist 数组
declare -a networkinterfacelist_array
# 存放 SSH 互信 IP 数组
declare -a hosts_array
# 系统用户 grid 名称，默认值为 grid
grid_user=grid
# 系统用户 grid 密码，默认值为 oracle
grid_passwd=oracle
# 是否配置 DNS 解析，默认值为 N
declare -u dns=N
# 是否配置 multipath 多路径，默认值为 Y
declare -u multipath=Y
# asm diskstring，默认值为 /dev/asm*
asmdisk_string="/dev/asm*"
# 是否配置 ASM 磁盘 UDEV 绑盘，默认值为 Y
declare -u asm_disk_conf=Y
# ASM 磁盘组名称，默认为 DATA,OCR,ARCH
declare -u ocr_asm_group=OCR
declare -u data_asm_group=DATA
declare -u arch_asm_group=ARCH
# ASM 磁盘组冗余度，默认值为 EXTERNAL，可选值为 [EXTERNAL|NORMAL|HIGH]
declare -u ocr_redun=EXTERNAL
declare -u data_redun=EXTERNAL
declare -u arch_redun=EXTERNAL
# 是否配置 AFD，默认值为 false
declare -l afd=false
# 是否配置 GIMR，默认值为 false
declare -l gimr=false
# 修复 VBOX BUG，如果使用 VBOX 划盘安装 RAC，则需要设置为 Y，默认值为 N
declare -u virtualbox=N
#==============================================================#
#                           颜色打印                            #
#==============================================================#
function color_printf() {
  declare -u con_flag
  declare -A color_map=(
    ["red"]='\E[1;31m'
    ["green"]='\E[1;32m'
    ["blue"]='\E[1;34m'
    ["yellow"]='\E[1;33m'
    ["light_blue"]='\E[1;94m'
    ["purple"]='\033[35m'
  )
  local res='\E[0m' default_color='\E[1;32m'
  local color=${color_map[$1]:-"$default_color"}
  case "$1" in
  "red")
    # 打印红色文本并退出
    printf "\n${color}%-20s %-30s %-50s\n${res}\n" "$2" "$3" "$4"
    exit 1
    ;;
  "green" | "light_blue")
    # 打印绿色或浅蓝色文本
    printf "${color}%-20s %-30s %-50s\n${res}" "$2" "$3" "$4"
    ;;
  "purple")
    # 打印紫色文本并等待用户输入
    printf "${color}%-s${res}" "$2" "$3"
    read -r con_flag
    # 如果用户未输入，默认为继续
    if [[ -z $con_flag ]]; then
      con_flag=Y
    fi
    if [[ $con_flag != "Y" ]]; then
      echo
      exit 1
    fi
    ;;
  *)
    # 打印其他颜色文本
    printf "${color}%-20s %-30s %-50s\n${res}\n" "$2" "$3" "$4"
    ;;
  esac
}
#==============================================================#
#                          日志打印                             #
#==============================================================#
function log_print() {
  echo
  color_printf green "#==============================================================#"
  color_printf green "$1"
  color_printf green "#==============================================================#"
  echo
}
#==============================================================#
#                      执行命令并输出日志文件                      #
#==============================================================#
function execute_and_log() {
  local prompt="$1" cmd="$2" log_file="$oracleinstalllog" pid start_time end_time execution_time status
  # 打印提示信息
  echo -e "\e[1;34m${prompt}\e[0m\c"
  printf "......"
  # 记录开始时间
  start_time=$(date +%s)
  # 执行命令并将输出重定向到日志文件
  if [[ $debug_flag == "Y" ]]; then
    set -x
  fi
  eval "$cmd" >>"$log_file" 2>&1 &
  if [[ $debug_flag == "Y" ]]; then
    set +x
  fi
  pid=$!
  # 显示进度条
  while ps -p $pid >/dev/null 2>&1; do
    printf "."
    sleep 0.5
    printf "\b"
    sleep 0.5
  done
  # 记录结束时间
  end_time=$(date +%s)
  execution_time=$((end_time - start_time))
  # 等待命令执行完成
  wait $pid
  status=$?
  # 根据命令执行状态打印结果
  if ((status == 0 || status == 3)); then
    printf "已完成 (耗时: %s 秒)\n" "$execution_time"
  elif [[ $status != 0 && $cmd == "pkg_install" ]]; then
    printf "已完成 (耗时: %s 秒)\n" "$execution_time"
  else
    printf "执行出错，请检查日志 %s\n" "$log_file"
    exit 1
  fi
}
#==============================================================#
#                         脚本通用函数                           #
#==============================================================#
function upper() {
  # 将字符串转换为大写
  echo "${1^^}"
}
function lower() {
  # 将字符串转换为小写
  echo "${1,,}"
}
function checkpara_NULL() {
  # 检查参数是否为空
  if [[ -z $2 || $2 == -* ]]; then
    color_printf red "参数 [ $1 ] 的值为空，请检查！"
  fi
}
function checkpara_YN() {
  # 检查参数是否为 Y 或者 N
  if ! [[ $2 =~ ^[YyNn]$ ]]; then
    color_printf red "参数 [ $1 ] 的值 $2 必须为 Y 或者 N，请检查！"
  fi
}
function checkpara_tf() {
  # 检查参数是否为 Y 或者 N
  if ! [[ $2 =~ ^(true|false)$ ]]; then
    color_printf red "参数 [ $1 ] 的值 $2 必须为 true 或者 false，请检查！"
  fi
}

function checkpara_REDUN() {
  # 检查 RAC 参数是否为 EXTERNAL，NORMAL 或者 HIGH
  local REDUN="EXTERNAL|NORMAL|HIGH"
  if ! [[ $2 =~ ^($REDUN)$ ]]; then
    color_printf red "RAC 参数 [ $1 ] 的值 $2 必须为 EXTERNAL，NORMAL 或者 HIGH，请检查！"
  fi
}
function check_disknum() {
  local disk_identifier=$1 redun=$2 normal=$3 high=$4 disk_count=$5
  if [[ $redun == "NORMAL" ]]; then
    if ((disk_count < normal)); then
      color_printf red "$disk_identifier 磁盘组冗余度为 $redun 时，至少需要 $normal 块磁盘，请检查磁盘数量！"
    fi
  elif [[ $redun == "HIGH" ]]; then
    if ((disk_count < high)); then
      color_printf red "$disk_identifier 磁盘组冗余度为 $redun 时，至少需要 $high 块磁盘，请检查磁盘数量！"
    fi
  fi
}
function check_password() {
  local password="$2"
  # 密码中不能有不可见的控制字符，例如回车换行制表符等
  if [[ $password =~ [[:cntrl:]] ]]; then
    color_printf red "参数 [ $1 ] 的密码 $2 不符合要求，包含不可见字符，请检查！"
  fi
  if [[ $1 == "-dp" ]]; then
    if ! [[ $password =~ ^[a-zA-Z][a-zA-Z0-9#$_]*$ ]]; then
      color_printf red "参数 [ $1 ] 的密码 $2 不符合要求，必须以字母开头，并且字符只能包含 (_)，(#)，($) ，请检查！"
    fi
  fi
}
function checkpara_NUMERIC() {
  # 检查参数是否为数字
  if ! [[ $2 =~ ^[0-9]+$ ]]; then
    color_printf red "参数 [ $1 ] 的值 $2 不是数字，请检查！"
  fi
}
function checkpara_DBS() {
  # 检查 db_block_size 参数值
  local DBS="2048|4096|8192|16384|32768"
  if ! [[ $2 =~ ^($DBS)$ ]]; then
    color_printf red "参数 [ $1 ] 的值 $2 必须为 2048，4096，8192，16384 或者 32768，请检查！"
  fi
}
function checkpara_DBCHARSET() {
  # 所有有效字符集的列表 247 个
  local CHARSETS="AL16UTF16|AL24UTFFSS|AL32UTF8|AR8ADOS710|AR8ADOS710T|AR8ADOS720|AR8ADOS720T|AR8APTEC715|AR8APTEC715T|AR8ARABICMAC|AR8ARABICMACS|AR8ARABICMACT|AR8ASMO708PLUS|AR8ASMO8X|AR8EBCDIC420S|AR8EBCDICX|AR8HPARABIC8T|AR8ISO8859P6|AR8MSWIN1256|AR8MUSSAD768|AR8MUSSAD768T|AR8NAFITHA711|AR8NAFITHA711T|AR8NAFITHA721|AR8NAFITHA721T|AR8SAKHR706|AR8SAKHR707|AR8SAKHR707T|AR8XBASIC|AZ8ISO8859P9E|BG8MSWIN|BG8PC437S|BLT8CP921|BLT8EBCDIC1112|BLT8EBCDIC1112S|BLT8ISO8859P13|BLT8MSWIN1257|BLT8PC775|BN8BSCII|CDN8PC863|CE8BS2000|CEL8ISO8859P14|CH7DEC|CL8BS2000|CL8EBCDIC1025|CL8EBCDIC1025C|CL8EBCDIC1025R|CL8EBCDIC1025S|CL8EBCDIC1025X|CL8EBCDIC1158|CL8EBCDIC1158R|CL8ISO8859P5|CL8ISOIR111|CL8KOI8R|CL8KOI8U|CL8MACCYRILLIC|CL8MACCYRILLICS|CL8MSWIN1251|D7DEC|D7SIEMENS9780X|D8BS2000|D8EBCDIC1141|D8EBCDIC273|DK7SIEMENS9780X|DK8BS2000|DK8EBCDIC1142|DK8EBCDIC277|E7DEC|E7SIEMENS9780X|E8BS2000|EE8BS2000|EE8EBCDIC870|EE8EBCDIC870C|EE8EBCDIC870S|EE8ISO8859P2|EE8MACCE|EE8MACCES|EE8MACCROATIAN|EE8MACCROATIANS|EE8MSWIN1250|EE8PC852|EEC8EUROASCI|EEC8EUROPA3|EL8DEC|EL8EBCDIC423R|EL8EBCDIC875|EL8EBCDIC875R|EL8EBCDIC875S|EL8GCOS7|EL8ISO8859P7|EL8MACGREEK|EL8MACGREEKS|EL8MSWIN1253|EL8PC437S|EL8PC737|EL8PC851|EL8PC869|ET8MSWIN923|F7DEC|F7SIEMENS9780X|F8BS2000|F8EBCDIC1147|F8EBCDIC297|HU8ABMOD|HU8CWI2|I7DEC|I7SIEMENS9780X|I8EBCDIC1144|I8EBCDIC280|IN8ISCII|IS8MACICELANDIC|IS8MACICELANDICS|IS8PC861|IW7IS960|IW8EBCDIC1086|IW8EBCDIC424|IW8EBCDIC424S|IW8ISO8859P8|IW8MACHEBREW|IW8MACHEBREWS|IW8MSWIN1255|IW8PC1507|JA16DBCS|JA16DBCSFIXED|JA16EBCDIC930|JA16EUC|JA16EUCFIXED|JA16EUCTILDE|JA16EUCYEN|JA16MACSJIS|JA16SJIS|JA16SJISFIXED|JA16SJISTILDE|JA16SJISYEN|JA16VMS|KO16DBCS|KO16DBCSFIXED|KO16KSC5601|KO16KSC5601FIXED|KO16KSCCS|KO16MSWIN949|LA8ISO6937|LA8PASSPORT|LT8MSWIN921|LT8PC772|LT8PC774|LV8PC1117|LV8PC8LR|LV8RST104090|N7SIEMENS9780X|N8PC865|NDK7DEC|NE8ISO8859P10|NEE8ISO8859P4|NL7DEC|RU8BESTA|RU8PC855|RU8PC866|S7DEC|S7SIEMENS9780X|S8BS2000|S8EBCDIC1143|S8EBCDIC278|SE8ISO8859P3|SF7ASCII|SF7DEC|TH8MACTHAI|TH8MACTHAIS|TH8TISASCII|TH8TISEBCDIC|TH8TISEBCDICS|TR7DEC|TR8DEC|TR8EBCDIC1026|TR8EBCDIC1026S|TR8MACTURKISH|TR8MACTURKISHS|TR8MSWIN1254|TR8PC857|US7ASCII|US8BS2000|US8ICL|US8PC437|UTF8|UTFE|VN8MSWIN1258|VN8VN3|WE8BS2000|WE8BS2000E|WE8BS2000L5|
WE8DEC|WE8DG|WE8EBCDIC1047|WE8EBCDIC1047E|WE8EBCDIC1140|WE8EBCDIC1140C|WE8EBCDIC1145|WE8EBCDIC1146|WE8EBCDIC1148|WE8EBCDIC1148C|WE8EBCDIC284|WE8EBCDIC285|WE8EBCDIC37|WE8EBCDIC37C|WE8EBCDIC500|WE8EBCDIC500C|WE8EBCDIC871|WE8EBCDIC924|WE8GCOS7|WE8HP|WE8ICL|WE8ISO8859P1|WE8ISO8859P15|WE8ISO8859P9|WE8ISOICLUK|WE8MACROMAN8|WE8MACROMAN8S|WE8MSWIN1252|WE8NCR4970|WE8NEXTSTEP|WE8PC850|WE8PC858|WE8PC860|WE8ROMAN8|YUG7ASCII|ZHS16CGB231280|ZHS16CGB231280FIXED|ZHS16DBCS|ZHS16DBCSFIXED|ZHS16GBK|ZHS16GBKFIXED|ZHS16MACCGB231280|ZHS32GB18030|ZHT16BIG5|ZHT16BIG5FIXED|ZHT16CCDC|ZHT16DBCS|ZHT16DBCSFIXED|ZHT16DBT|ZHT16HKSCS|ZHT16HKSCS31|ZHT16MSWIN950|ZHT32EUC|ZHT32EUCFIXED|ZHT32SOPS|ZHT32TRIS|ZHT32TRISFIXED"
  # 检查参数是否在有效字符集列表中
  if ! [[ $2 =~ ^($CHARSETS)$ ]]; then
    color_printf red "数据库字符集参数 [ $1 ] 的值 $2 无效，请检查！"
  fi
}
function checkpara_NCHARSET() {
  # 所有有效字符集的列表
  local NCHARSETS="UTF8|AL16UTF16"
  # 检查参数是否在有效字符集列表中
  if ! [[ $2 =~ ^($NCHARSETS)$ ]]; then
    color_printf red "国家字符集参数 [ $1 ] 的值 $2 无效，请检查！"
  fi
}
function check_DBNAME() {
  local dbname="$1"
  local regex="^[a-zA-Z0-9]+$"
  if ! [[ $dbname =~ $regex ]]; then
    color_printf red "参数 [ -o ] 的值 $dbname 不符合要求，请使用数字和字母，不要使用特殊字符，请检查！"
  fi
}
function check_RACNAME() {
  # 检查参数是否为数字
  if [[ $2 =~ ^[0-9] ]]; then
    color_printf red "参数 [ $1 ] 的值 $2 不能使用数字开头，请检查！"
  fi
}
function check_file() {
  # 检查文件是否存在
  if [[ -e "$1" ]]; then
    return 0
  else
    return 1
  fi
}
function mv_file() {
  local file_path=$1
  # 检查原始文件是否存在
  if ! check_file "$file_path".original; then
    # 检查文件是否存在
    if check_file "$file_path"; then
      # 不存在则备份为原始文件
      /bin/mv -f "$file_path"{,.original} >/dev/null 2>&1
    fi
  fi
}
function rm_file() {
  local file=$1
  # 检查文件是否存在
  if check_file "$file"; then
    # 不存在则备份为原始文件
    /bin/rm -rf "$file" >/dev/null 2>&1
  fi
}
function backup_restore_file() {
  local file_path=$1
  if check_file "$file_path"; then
    if (($(grep -E -c "# OracleBegin" "$file_path") == 0)); then
      /bin/cp -f "$file_path"{,.original}
    else
      /bin/cp -f "$file_path"{,."$current"}
      /bin/cp -f "$file_path"{.original,}
    fi
  else
    touch "$file_path".original
  fi
}
function write_file() {
  local flag=$1 file_name=$2 content=$3
  if [[ $flag == "Y" ]]; then
    cat <<-EOF >"$file_name"
$content
EOF
  elif [[ $flag == "N" ]]; then
    cat <<-EOF >>"$file_name"
$content
EOF
  fi
}
function run_as_oracle() {
  local command="$1"
  su - $oracle_user -c "bash -l -c \"$command\""
}
function run_as_grid() {
  local command="$1"
  su - $grid_user -c "bash -l -c \"$command\""
}
function execute_sqlplus() {
  local dbname="$1" format="$2" sql="$3"
  su - $oracle_user <<-SOF
source /home/$oracle_user/.$dbname
sqlplus -S / as sysdba<<-\EOF
set lin 2222 pages 1000 tab off feedback off
$format
$sql
exit;
EOF
SOF
}
function check_ip() {
  # 检查 IP 地址格式是否正确
  local ip=$1
  if echo "$ip" | grep -Eq "^([0-9]{1,3}\.){3}[0-9]{1,3}$"; then
    return 0
  else
    return 1
  fi
}
function check_ip_connectivity() {
  # 检查 IP 地址是否可以 ping 通
  local ip=$1
  if ! ping -c 1 "$ip" >/dev/null 2>&1; then
    color_printf red "IP地址 $ip 无法 ping 通，请检查！"
  fi
}
function check_ip_unreachability() {
  # 检查 IP 地址是否可以 ping 通
  local ip=$2
  if ping -c 1 "$ip" >/dev/null 2>&1; then
    color_printf red "RAC $1 的 $ip 可以被 ping 通，可能被占用，请检查！"
  fi
}
function isunique_ip() {
  # 检查 IP 地址是否唯一
  declare -A ip_count
  for ip in "${allips[@]}"; do
    ((ip_count[$ip]++))
  done
  for ip in "${!ip_count[@]}"; do
    if ((ip_count[$ip] > 1)); then
      color_printf red "IP地址 $ip 存在重复，请检查！"
    fi
  done
}
function check_internet_connectivity() {
  # 检查网络连接是否正常
  if ! ping -c 1 www.baidu.com >/dev/null 2>&1; then
    color_printf red "脚本参数 [ -nrp ] 值为 $net_repo，当前操作系统 [ $pretty_name ] 需要配置网络软件源，必须联网，否则安装失败！"
  fi
}
#==============================================================#
#                          GET WWID                            #
#==============================================================#
function get_wwid() {
  local wwid scsi_id
  # 根据操作系统版本设置 scsi_id 命令路径
  if ((os_version == 6)); then
    scsi_id="/sbin/scsi_id"
  else
    scsi_id="/usr/lib/udev/scsi_id"
  fi
  # 获取磁盘的 WWID
  wwid=$("$scsi_id" -g -u "$1")
  echo "$wwid"
}
#==============================================================#
#                       Clean Disk                             #
#==============================================================#
function clean_disk_and_get_wwid() {
  local wwid_list wwid wwid_string identifier=$2 disk_count
  # 使用传入的磁盘列表，以逗号分隔的字符串
  IFS=',' read -ra disks <<<"$1"
  disk_count=${#disks[@]}
  # 遍历处理每个磁盘
  for disk in "${disks[@]}"; do
    if [[ -n "$disk" ]]; then
      # 检查磁盘头部
      if hexdump -C -n 102400 "$disk" | grep -q "$identifier"; then
        color_printf purple "检查 ASM 磁盘 [ $disk ] 中已存在磁盘组名称 [ $identifier ] 信息，请确认是否格式化磁盘 (Y/N): [Y] "
        echo
        dd if=/dev/zero of="$disk" bs=4096 count=1 >/dev/null 2>&1
      fi
      # 获取磁盘 WWID
      wwid=$(get_wwid "$disk")
      if [[ -z "$wwid" ]]; then
        color_printf red "磁盘 $disk 的 WWID 未获取到，请检查磁盘！"
      fi
      wwid_list+=("$wwid")
    fi
  done
  # 将磁盘 WWID 列表转换为逗号分隔的字符串
  wwid_string=$(
    IFS=,
    echo "${wwid_list[*]}"
  )
  # 根据标识符设置全局变量的磁盘 WWID
  case "$identifier" in
  "OCR")
    ocr_disk_wwid="$wwid_string"
    check_disknum "$identifier" "$ocr_redun" 3 5 "$disk_count"
    ;;
  "DATA")
    data_disk_wwid="$wwid_string"
    check_disknum "$identifier" "$data_redun" 2 3 "$disk_count"
    ;;
  "ARCH")
    arch_disk_wwid="$wwid_string"
    check_disknum "$identifier" "$arch_redun" 2 3 "$disk_count"
    ;;
  esac
}
#==============================================================#
#                   Conf Disk && GET WWID                      #
#==============================================================#
function conf_disk_wwid() {
  if [[ $asm_disk_conf == "N" ]]; then
    datadisk=$data_base_disk
    ocrdisk=${ocr_base_disk:+"$ocr_base_disk"}
    archdisk=${arch_base_disk:+"$arch_base_disk"}
    # 构建 ASM 磁盘路径模式，格式为：磁盘目录/磁盘名前三个字符*
    asmdisk_string="$(dirname "${data_base_disk##*,}")/$(echo "${data_base_disk##*/}" | cut -c1-3)""*"
  else
    # 获取 ASM 磁盘 WWID 并格式化磁盘头
    local disk_types=("OCR" "DATA" "ARCH")
    # 循环遍历磁盘类型，处理每种磁盘
    for disk_type in "${disk_types[@]}"; do
      local base_disk="${disk_type,,}_base_disk"
      if [[ "${!base_disk}" ]]; then
        clean_disk_and_get_wwid "${!base_disk}" "$disk_type"
      fi
    done
  fi
}
#==============================================================#
#                       过滤唯一 wwid 磁盘                       #
#==============================================================#
function filter_disk() {
  local fil_disk=$1 all_disks disk disk_list=() wwid
  declare -A wwids sizes
  # 获取磁盘存储大小的函数，返回值以 GB 为单位
  disk_storage() {
    lsblk -b -o SIZE,TYPE "${1}" | awk '$2 == "disk" {print $1/1024/1024/1024 "G"}'
  }
  # 获取所有磁盘名，以 sd 或 vd 开头的磁盘
  all_disks=$(lsblk -n -o NAME | awk '/^sd|vd/ { print $1 }')
  # 解析传入的过滤磁盘列表
  IFS=',' read -ra fil_disk_arr <<<"$fil_disk"
  # 过滤磁盘列表，排除在过滤列表中的磁盘
  for disk in $all_disks; do
    if ! [[ "${fil_disk_arr[*]}" =~ $disk ]]; then
      disk_list+=("/dev/$disk")
    fi
  done
  # 获取每个磁盘的大小和 WWID
  for disk in "${disk_list[@]}"; do
    sizes[$disk]=$(disk_storage "$disk")
    wwid=$(get_wwid "$disk")
    if [[ -n $wwid && ! "${wwids[*]}" =~ $wwid ]]; then
      wwids[$disk]=$wwid
    fi
  done
  # 打印磁盘信息
  color_printf light_blue "Disk WWID" "Disk Name" "Size"
  for disk in "${!wwids[@]}"; do
    color_printf green "${wwids[$disk]}" "$disk" "${sizes[$disk]}"
  done | sort -k3,3n -k2,2
}
#==============================================================#
#                         SSH Check                            #
#==============================================================#
function ssh_check() {
  local user=$1 all_connections_ok="true"
  # 定义存放主机 IP 地址的数组
  declare -a ips=("${@:2}")
  # 循环遍历主机 IP 地址列表
  for ip in "${ips[@]}"; do
    # 使用 su 切换到指定用户，执行 ssh 命令检查连接
    if su -s /bin/bash -c "ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no $ip date" "$user" >/dev/null 2>&1; then
      all_connections_ok="true"
    else
      # 如果某个连接失败，则标识 all_connections_ok 置为 false，并跳出循环
      all_connections_ok="false"
      break
    fi
  done
  # 输出连接状态
  echo $all_connections_ok
}
#==============================================================#
#                         SSH Trust                            #
#==============================================================#
function ssh_trust() {
  # 获取目标用户名和密码
  local dest_user=$1 passwd ssh_dir
  passwd=$(printf "%q" "$2")
  # 定义存放主机 IP 地址的数组
  declare -a host_ips=("${@:3}")
  # 判断是否是 root 用户，设置 SSH 目录路径
  [[ $dest_user == "root" ]] && ssh_dir="/root/.ssh" || ssh_dir="/home/$dest_user/.ssh"
  # 如果目标路径存在，删除该路径
  if [[ -e "$ssh_dir" ]]; then
    /bin/rm -rf "$ssh_dir"
  fi
  # 创建 SSH 目录并设置目录权限
  /bin/mkdir -p "$ssh_dir" && chmod 755 "$ssh_dir"
  # 生成 SSH 密钥
  ssh-keygen -t rsa -P '' -f "$ssh_dir/id_rsa"
  # 将公钥添加到 authorized_keys 文件并设置文件权限
  cat "$ssh_dir/id_rsa.pub" >>"$ssh_dir/authorized_keys" && chmod 644 "$ssh_dir/authorized_keys"
  # 填充 expect 缓存
  for ip in "${host_ips[@]}"; do
    expect <<EOF >/dev/null 2>&1
set timeout 300
spawn ssh -q -o StrictHostKeyChecking=no $dest_user@$ip "echo 'Connected!'"
expect "password:" { send "$passwd\r"; exp_continue } eof { exit } timeout { puts "等待超时，检查 ssh 执行速度"; exit 1 }
EOF
  done
  # 循环遍历主机 IP 地址列表，将 ssh 目录复制到目标主机
  for ip in "${host_ips[@]}"; do
    expect <<EOF >/dev/null 2>&1
set timeout 300
spawn scp -q -o StrictHostKeyChecking=no -r $ssh_dir $dest_user@$ip:~
expect "password:" { send "$passwd\r"; exp_continue } eof { exit } timeout { puts "等待超时，检查 scp 执行速度"; exit 1 }
EOF
    # 如果 os 版本为 6，则执行 restorecon 命令恢复文件安全上下文
    if ((os_version == 6)); then
      expect <<EOF >/dev/null 2>&1
set timeout 300
spawn ssh -q -o StrictHostKeyChecking=no $dest_user@$ip restorecon -RF $ssh_dir
expect "password:" {  send "$passwd\r"; exp_continue } eof { exit } timeout { puts "等待超时，检查 ssh 执行速度"; exit 1 }
}
EOF
    fi
  done
  # 等待所有子进程完成
  wait
}
#==============================================================#
#                         适配国产系统                           #
#==============================================================#
function create_symlink() {
  local flag=$1 source_path=$2 destination_path=$3
  # 根据标志创建软链接
  if [[ $flag == "Y" ]]; then
    # 强制创建软链接
    ln -sf "$source_path" "$destination_path" >/dev/null 2>&1
  elif [[ $flag == "N" ]]; then
    # 创建软链接
    ln -s "$source_path" "$destination_path" >/dev/null 2>&1
  fi
}
# 定义函数 base64_to_binary
# 压缩命令 tar -cJf stat.tar.xz libaio.so.1 stat-stubs.o
# 生成字符串 base64 stat.tar.xz >stat.txt
# 解码并保存到 stat.tar.gz
# base64_to_binary "$base64_string" stat.tar.xz
# 解压 tar -xJf stat.tar.xz
function base64_to_binary() {
  local base64_string=$1 output_file="${2:-decoded.bin}"
  # 将 Base64 字符串解码并保存到指定的文件
  echo -n "$base64_string" | base64 --decode >"$output_file"
}
# 定义一个函数来检查操作系统是否在给定列表中
function is_in_list() {
  local item=$1
  shift
  local list=("$@")
  for element in "${list[@]}"; do
    if [[ "$item" == "$element" ]]; then
      return 0
    fi
  done
  return 1
}
function check_md5sum() {
  local file_name=$1
  local expected_md5=$2
  color_printf green "正在检测安装包 $file_name 的 MD5 值是否正确，请稍等......"
  if [[ $(md5sum "$file_name" | awk '{print $1}') != "$expected_md5" ]]; then
    color_printf red "请检查 $file_name 文件的完整性，确保 md5sum 值为 $expected_md5！"
  fi
}
# 检查 Oracle 兼容性
function check_oracle_compatibility() {
  check_version_compatibility() {
    local supported_versions="$1"
    # 检查操作系统版本是否兼容
    if [[ "$os_version" =~ ^($supported_versions)$ ]]; then
      oracle_os_flag=Y
    else
      oracle_os_flag=N
    fi
  }
  # 检查未认证的国产化操作系统
  check_unscertified_os() {
    if is_in_list "$os_type" "${unscertified_os_list[@]}"; then
      oracle_os_flag="N"
    fi
  }
  # 检查 Oracle 曾经认证过的国产数据库操作系统
  check_neokylin_os() {
    if [[ "$os_type" == "neokylin" ]]; then
      if ((db_version == 11 && os_version == 7)); then
        oracle_os_flag="Y"
      else
        oracle_os_flag="N"
      fi
    fi
  }
  # 检查 Oracle 官方认证的操作系统
  check_oracle_certified_os() {
    if is_in_list "$os_type" "${oracle_certified_os_list[@]}"; then
      if [[ $cpu_type == "aarch64" ]]; then
        if [[ "$os_type" == "ol" ]]; then
          check_version_compatibility "8"
        else
          oracle_os_flag="N"
        fi
      else
        if [[ "$os_type" == "sles" ]]; then
          case "$db_version" in
          11) check_version_compatibility "7" ;;
          12 | 19) check_version_compatibility "7|8" ;;
          21) check_version_compatibility "8" ;;
          23) oracle_os_flag="N" ;;
          esac
        else
          case "$db_version" in
          11 | 12) check_version_compatibility "6|7|8" ;;
          19) check_version_compatibility "7|8|9" ;;
          21) check_version_compatibility "7|8" ;;
          23) check_version_compatibility "8" ;;
          esac
        fi
      fi
    fi
  }
  check_unscertified_os
  check_neokylin_os
  check_oracle_certified_os
  if [[ "$oracle_os_flag" == "N" ]]; then
    color_printf purple "!!! 免责声明：当前操作系统版本是 [ $pretty_name ] 不在 Oracle 官方支持列表，本脚本只负责安装，请确认是否继续安装 (Y/N): [Y] "
    echo
  elif [[ "$oracle_os_flag" == "NONE" ]]; then
    color_printf red "当前操作系统版本是 [ $pretty_name ] 不在脚本支持列表中，如有需要请联系开发者适配！"
  fi
}
function ar_libc_nonshareda() {
  local base64_string
  if [[ $cpu_type == "aarch64" ]]; then
    base64_string='/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4Mf/CMZdADMcyt3f9REpe7Mql4Z72aQIt6Fkqj2Aq3SG
JjDLcH6dOLVuP818vA+C+aczpNGBpgE06wvrW45stoi4Z5iGhOHrm4sTBVpuZwov9TVD6PBSlvGb
pailsXIFMOU3h/eYiYEc7h9NkzplDHOsQFxwmD/RmfdSG/WTUmguftOCt85HXW+5KNxKeBK54I1F
rFiH7Z6eoAivlTM0VchNtfKT8CknW3GbG6YS1RqpywczbnggQW4W8tQGruI/PcnZfttd1e/+MzVM
89w8BeEAHCTdBJ2syEJ55kafLFnN681ogUuDA5AE6F+cz88lHSz9J0STAAcZQNH1MMYKtv1kNZ9Z
rkj7aFr6lcrgpRJvk0ResulNroK46JM52sI1zg3ii/lxS/vjYz8W5G12FvNPmotZj9atz5be8TK4
EGF3VDDi2TYfzqV4zue/2Q4NXAcRtDV4BNkKnJG9muXHhKiVASJiohYCv9CJCIv2j0wtBqXgMJng
heKO3ptYP7gv5E76wg9iTkLgQvwanULVmn18KVqc422MM6VTzl3eUc0YjPV64lEsL3+mpNCa+vUl
8Dz0B90eOZztQmk58xZqSmAc8cKgCBFM3oWJYbVPud+bHltzYxEWUI+7TtV5+wFrcQh2xrb21JZw
VV21g1qtcmnE+3qY9RNXgfbqFdynABQ4vuIie4q/XQKOerD5CspVF0AhztL9vlWgg+fMO/I56yCX
8k1z/3MXNkpOUYATuU99U6ASXcTmHEZ9WblcIJx3YgnoqSXphiwpJDbiZ/dBF0K3n+wXJrCayXWb
z/Wj7BsXYTfGga1vYGyECRTj/jiJ0/tlN9J7MR0m3aS5IJ8duuuMjByWa4qDLtE+UQCpbolnoy4U
l1JchXAoxZGGOks1nJfF//uuhlkhgvwP/hFknPqt7jZAAWQphjDcVneTwLFPZC4k4OxdK1yVNPud
Chcz27uay+NOQ+GKF5hVTL6DLvIt/YSOiYhhL3u4srXTZETgIZOVaxXUbLwd9KDPM1jv2wpgkmXt
S5wkLVQXSiQ4y7qAdEltD0+g59WQZKLcfoWu9kfx16JfCZiyFMbJvSM/U1szMHYCMBt/ZHbiCabN
XkPmNsuSaDpUYeuNKurVm+0f8gMyY6Q9mCEXz1jA0nbBzAXVo04Iih3p80B1rvOhUnnT8Ml3zZYz
gI0rllX2xhigD+bIzJhpeiM0DzKC/sQiJ0nM8crgB1NR46ItjXBz0Ade1PChMM7rFLah/vC16o7t
O6iFJg5sWSpGFRi+KdrZat2klTNqsDjrfz1AXqFKfnGRelma5cfSO99cLDauiL1cYqHJfVBvEeUL
uwAJJlFXrWSyAxK3UPmWyPIK+wsCNqKcmqnh3woz/gTs/sVURc36PXRytXqW+wQqIKCQJu3T+Ixw
Fhti9SuGiEmeVmjQPwVOVpBW16ozX099mXw89f2WBups3MfTk1YJZtgdnCVeolZi8L2nzvDaeABZ
A1VjFgNCRni0IMOd3JD3p3YIevm6L//VqyOHf+P8J5wFNPR7AbtTq4o8dLxAz0YXqhjPETFStpMN
HetI/BhFzxSZuLcHzKCq5jvpX1TfL8mDavDuVjliEL27uCTSmDZGlihAS8GSL7zhycyJ8db5Up8d
Thf1ca4M7OxHKJ3/D7j0kg2AaayHDuflUiJJGRmh+XnuePGJmK809EmI0jsmDZ8UdjMRlflP1MMv
TztwRB7JjicM9iyKGlATtx7e7iOSqrdolBZt1juRLOXsDrdaXVoav5KMqU8At4fSHs91AQgiSDo0
85IVUngLVb26VIsWA+QWItAu17s2k9R7608Nh0fDnCrPQX1nuM9FGJFFOYMWHc2t4vasoBQcSK/j
oZarmJxMy7o2+nS6STqU6WieTfhGSnFxwqKZLRUEfc1t+uUyelp+BRmoB6LP67vS1rIlIGRRZSMK
x3opa+G1U0tiSeTBt4Wk/vA6d4Gq6MszDGj8vt5rdJcaK3FdgwF/sa7Mhsr3nJ5XKrRvJQ04tdpu
DrhaJpn1mDLcWv4lUSxWG4VfBIfJnlupGPRrNZVjmyxZtvuhpPIWkwb0opBLAgnp1ueLmmBC9CpL
JaNc852qF7VBKI6UNKdMVovqyBO/DLMfGMEj6xouEOIWqXF/frO2ytdJfW0BEwUjvluK2xbBCBww
o/5WJIVn0zRw0wVnktxSRspbdYL4WDDlnqse0ibwo7lLnJiC0CaluYvouTvxfuSNwS6EjJpjJjin
u58cY0L2Z04fGHeCVKfkufSXjzby5KRIR/ZO5NCX5wo39SJsamrgA5QzAnEAIM5lJKcq0RkR5wTm
6K/qeNcJpz0qKe5sHxuF+hO59ayMlllUUCOry1fT/Lhz8nceAJauIrIVDaFZfwPRHcpH+ehSkJCG
sS3waiwn/4k90HJXynLxOgkPjbtiXatU/tyrwX/BXceRJIUIQgnv+XcLL0S3sHqrY35UWeo3PENQ
JoxC8Jq0jrYhdDE8MXgUrJpbEXtagTL7IBQ5xvl7CacwJ8/UclUXLU5/Bvzs9wsHVe36oJI0oZxP
Mg1azJly9rSykO70Ga5OC2JLLE9cW+gInssifTIcmHGoiqOtmzqMX7udo1TpwV9GUc3eUAr9D5Ck
4bYJncIJB1HisH6Gyh+An6jFDh8utoH+6z392WP3C1LZ0k8rx6i0jgDKjMNhZh2P2XWY+amZmp7n
CXxpNaUO6JspQKUkhTjWrlLIaofzWQaTB8sKzMIYsCx+2ymBcL2OsCQvaRcqiXRIScl6g96objAA
15JIjMNoyzMbdFd/+hy2bxyPRV7uwkr6QOdYHYCYTC0LndLoaylRxcKjBNbi88mf2cdqnDPusRLv
BIB3/2IioRma9rMOc+O1z4HzuEJWRPwCO9L91s8JHSDW4tBM8mBgqHwhM4McVo8h7sPt8/wTlZav
aVI8cABjfq+slqqd96hKhue2QGqhne+UWsbRvGEexKWRrTifeCqN6okMpp8a4kUtLkjEte8PAAAA
7CA44DTdJK8AAeIRgJADAG6NPv6xxGf7AgAAAAAEWVo='
    # 解码并保存到 stat.tar.xz
    stat_array=(
      "$software_dir/fstat64.oS"
      "$software_dir/lstat64.oS"
      "$software_dir/lstat.oS"
      "$software_dir/stat64.oS"
      "$software_dir/fstatat64.oS"
      "$software_dir/mknod.oS"
    )
  else
    base64_string='/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4Cf/Af1dADmdCEcK2iXKM9hlSqnJgOklzkj59aGHLFqo
DWNfS87u1zfN2ZEKKUt1dO9GLhDuvHtQQqc4ljXoBmNoK5BLs+vNuOEwa3Hm/IJ9OFH2vxiu+g/a
e98u5sOg1WX22b+A/pm+zW843A9s8M6wHYfjKqp13DxrDtyB/H0Mju2tV8oZ+8mOM4xSPfnM7keT
O69cMufEh5jKsCOL8n2mwAadM/X7/susSp+ThkmiKFzvwpL6pSBIZAZ9NnhyGt+Mb+3z/oh0v/QE
Q9/Sebsd+kdAIYxrlnyR6QwA46RXUx9CUv1WlN9G/mHcK86Jp9y5OTT8/ObWzDLX9OE1y/NzHsYO
riL7LxJAoJbv5iNuakmBHTHLVcNiqcS4A+y3cJpiw+yfqr+/NjpmB/pw9UPhpmMCDX2dS35TPbTl
5mww27aAvuE7WVT25Q6gOZ7VVh7gw2pnoXlvaBH480FmOhMB+5U9mtcbMAoKyYaDhvtjKpfx8l3I
Lq6xlN76sfL3EencD4k8zC+42nLb/sjofaJADN1suSMWUPAFZWrxKaInDdfWCOy764JKBAtMPcia
2l0ltIc7jJ2RzZob591N5iwY2xjcVvQQNv2VJHM6wM3Mw8s6RIjZlP9WeXzFNhWHTl9UZ25RMKe8
DS7PiRyfdum+4wnQckYYvXeWpHSOVp9zq8ngAAAAAHfXVLs/p0kvAAGZBIBQAAAdrVmNscRn+wIA
AAAABFla'
    # 解码并保存到 stat.tar.xz
    stat_array=(
      "$software_dir/stat-stubs.o"
    )
  fi
  # 解码并保存到 stat.tar.xz
  for stat in "${stat_array[@]}"; do
    if ! check_file "$stat"; then
      base64_to_binary "$base64_string" "$software_dir/stat.tar.xz"
      tar -xJf "$software_dir"/stat.tar.xz -C "$software_dir" >/dev/null 2>&1
    fi
    ## 适配 libc_nonshared
    ar r "$a_path"/libc_nonshared.a "$stat" >/dev/null 2>&1
  done
}
function create_libpthreada() {
  # 适配 debs，事先建立 /usr/lib64
  /bin/mkdir -p /usr/lib64
  # 检查并创建 libpthread_nonshared.a
  # 因 libpthread_nonshared.a libc_nonshared.a 路径是 Oracle 硬编码，无需 so_path
  if ! check_file /usr/lib64/libpthread_nonshared.a; then
    ar cr /usr/lib64/libpthread_nonshared.a >/dev/null 2>&1
    chmod a+rx /usr/lib64/libpthread_nonshared.a
  fi
}
function do_fix_libaio() {
  local base64_string
  base64_string='/Td6WFoAAATm1rRGAgAhARYAAAB0L+Wj4Cf/CNpdADYaSGngEds6yU77L3p7YQRoEDDGtDAHn4d3
qObYtZOk4HqKbJhaozkuYDvWT0Z/gEn2IqRSNXlyvazH5kLpLQ0mNGzkje9YiNvoF3TBW6SGpEuu
3WNkO5gEiKKP2DvYF+D0P/UXK3/gPrIhdR9BopCC48v+QHnFcKw4IhEalu6M7lyZBHfJH9zAK7Qk
b9D0lXfFbEREbp2gJ6jyVxePboIs4bCYaZXoztouDfgGHfv9z0re712ZT7vPVq6byP4XsMhDtQv9
86sEL+DPPsh/QsBphSBzM2GontB8ZYel9zs7N5qDALQ5l/THYFK7iH3Cus3q2KeWsISRTPgJqd06
eFppowVrLXT6OlyQ6pyHXCZKEHox7eJFQM/DIG5xKsv2RZPT5dRkV5DIlnDA14NfduDBLboLnGDs
wVixPz5qDoWL9sZ5XC79GO3Z3n3UTty+oO4QGjMtx1h2D2fHFC9pmnZVYkVAENaCQdEZv+GZWimk
HbH9C+tXBzwNY0iteDH0QhhJtleRaWx3SPdjBN1rVzQ1j/3yrbDf4auvwk6jgON1FijpkgQNoXsk
LsxMa0HT7ftF9WpG5Cj3Uhkh8WHzVo9WMAHxtYm0lDk8cqP/YOJ5Ts+YQxw3mZc7K82Pt8sErVrc
AyRaFdwBtRgSSDm/QU+jT4/khQCaxUw+zJt4SJpoEgSrEOv5oC++DCG//AMYmT1OVg3TemAjJQHc
sl9uzLk+oajVrfuo/1F5W52pyH8Gw/AiPtQAyxlUlrvftoBdx7jt/8d74+qV9XSr+3AJxSx2E7mL
rBN9B0Lx/niQIrWWRj3Yf+uUH7hz2x9TA/VTJlchpKXQfiGxbQubdNSvCDQdW8O115E11jFr6+XY
Q3+jr8aaq5pBvMibKGImfsMG3YHMluuWBiJ3QrBLBFNROwr1h/OOI3xheLA9C1LeMFYucDV7BtyK
NRFqCuYF5zAVl3Nd9JFcXzb3CGQWgL6zdH9+Z2I3aqMifqX8XrM7AROSWhaD/3uRc6p3N42a5Uxd
iDNWuHxGzZPM0xj/yjwCS4gCsxxfY8zM1VEDI782OcGlIscG+7/U72btqOY/JXSIIh1oLuzzJLRJ
gzJjmtNTWrqlcS676IBrgB92WC5prAggguiQxuMrSgZ+Z/4YiUO/BhEKxO68j/QOS58NAyYqjmQr
SavRUI2yztqbb4uK30kvqG+odiIEDZSz3ZbWaDb3HsmjJf7A8SA92qWvVKu7rlGBPO5jvYvWwy4s
BjJWrJbosXFn1UGC94YC+Fz2KfzdYaH+48VJaFJtAWqw/5VttN5l+zSRqizxn3aJHOs2fnSjeFhi
twpzopZ0+4bzmzXkH2XalZmC8vEWDBP3ZE0FqV790OmmQSkzPH1KaWyux7HRasoWRqmqKMT7aHm/
cQ4QaoLwz3M1EdZIJSmJI67QwMhGPsbsislKZjQJndOuF82bi2V2QKJYlG2kKyWytf3J+vBDv7Gt
12WRCej9ZiWCEV/RzoLEqwTj2nbFbjLO0XvvChYpvZKUuJHvGjIHsgYOEKw0IyVv71VvVPfM8Eq4
n0eFCahoULNtEo/+e/0WNYRXFlNjD/S14PMeJiOorjeAK5LNh1XZw/z+/J21M05LLCEI7otOTs3t
LA18egsT4uYPpINc2ZhAQNPVHk4AUzu2cTfAa+r9oYEPCKWBvU0mddpgY32CI7IatqAc/FzZ1abn
RKvaP10FPeKy41m6TMy5eenXwhAG6QT6D/f3R5JoWOtT0fkXiUhST/tp+KF0Ap1XKu6wz83Hmn8a
HMDLPYcIfj9pISSgIGyrNtELZp38gK0aRzDuQvgvP5+LC1CMDwObPB7t0w+njAuTByNTKhRDVtIe
iL8Xa8lCnVURdbzlLC0S3xjaCZyYdkNKWaF2jIrk95K7ZSuHj3+nHbYBxii/epcGGdpOvqKR3b3Z
uZvmCN1mMTFcHQCPvjWuEmJcCiIN6z9M4opNvAc6XqxDlkovkljNNoWQMf/2NBhuEknS3sG5ARUy
kYWUSMULeh19Vgc2lKRz0bKljBZJn2vRBcQDcVkNsFKw6v3h5ywi4iiAw67wF8QCCZI4XtDdAkR7
nsic5aL/sVUBvJdyJfuXTFQRD9C4ts+rszpy7+oWZtgvJBHhkODgEgQnA/SROMKKiAoYjsio0wZV
bya0xdR1nSI/JMugER5oATcZNB06t455jPWYMt2mxrJjE3N6WsKGrNhEGGR8fJuv+M7CQ+WLUjPP
x3P7vELSmv5NeP7kyLYZeRLmlRLp44iE2+rZhKBx8xPCihxezUYlE3BP7xPc8BVGZhh2oj8Bf6Jd
hCDYrZh9MdhZAXxGuB9ygGrLhmRs8Y1UTf4LEwwC6R8J7eAeyQpS00bN6SaiM99RRK0lEKjLJoUR
sc9rmO/Km2Pq3q1ivURuWc81NH7BD9Ja+aUeI77yH98xzF1JM1t7NhvMTXnrstJ5ipOJNeC7MgMf
pcfcBxEQoiEawXMQ6dMwQ2KK7ckuplGxOmHiEz7V8Q9hE7IawUgH3VLvNnvtCPDTotHXBPmqBUgH
nrwXVaZLuWHOojYl5qTqp9X9m7vBaBJkk3frQc1hYOYcDh3zEkFGZkpybTul0t4v48w1e9an0O+1
4QpDDmVVLIPnlp1NYwUVsOtLLgP6QsGTqSaP+QzEKnWbKaf+p909XJDR+gGoONxLdLdGj1L2in+8
vkODzmXj3zMs+opX5saN41XRTMPTpZqhLJe8w5+LkMAdTwSS/yYQ0PnvGYmlh82ZjJv9dffNuF23
EokBfNXFajJnLqvOnfiwAV5jjJc/O//jjZXSPI61Fw11X6JKeFETACe9LoketEbf2EU3zzfYE+UL
OXeoAy+ChySjp9mAWO0ZNkxdKNneIopQSgyWa4/EBUbSehgBTKcZGHH8ZILx6Orxxm3jT1KFnv+0
TCIW2v0gV1oN6fJQgtB2BCP1LfqWn7GVN/yM7a9Y7rjDt29uVKB2LfN+iobHrwijMwwx+FOvog6M
UrG/U7ad8Yq3/bzF3Kj0HQAAAAChFxN8nnba7AAB9hGAUAAAYAj73LHEZ/sCAAAAAARZWg=='
  # 解码并保存到 libaio.tar.xz
  if ! check_file "$software_dir"/libaio.so.1; then
    base64_to_binary "$base64_string" "$software_dir/libaio.tar.xz"
    tar -xJf "$software_dir"/libaio.tar.xz -C "$software_dir" >/dev/null 2>&1
  fi
  # 链接 libaio
  if ! check_file "$so_path"/libaio.so.1.original; then
    if check_file "$so_path"/libaio.so.1; then
      /bin/mv -f "$so_path"/libaio.so.1 "$so_path"/libaio.so.1.original >/dev/null 2>&1
    fi
    if check_file "$software_dir"/libaio.so.1; then
      /bin/cp -f "$software_dir"/libaio.so.1 "$so_path"/libaio.so.1 >/dev/null 2>&1
      chmod a+rx "$so_path"/libaio.so.1
    fi
  fi
}
function do_fix_libnsl() {
  # 修复 libnsl，主要针对单机模式，RAC 必须要安装 libnsl* 包
  if ! check_file "$a_path"/libnsl.so; then
    if check_file "$so_path"/libnsl.so.2; then
      create_symlink "N" "$so_path"/libnsl.so.2 "$a_path"/libnsl.so
    elif check_file "$so_path"/libnsl.so.3; then
      create_symlink "N" "$so_path"/libnsl.so.3 "$a_path"/libnsl.so
    fi
  fi
  if ! check_file "$so_path"/libnsl.so.1; then
    if check_file "$so_path"/libnsl.so.2; then
      create_symlink "N" "$so_path"/libnsl.so.2 "$so_path"/libnsl.so.1
    elif check_file "$so_path"/libnsl.so.3; then
      create_symlink "N" "$so_path"/libnsl.so.3 "$so_path"/libnsl.so.1
    fi
  fi
  if [[ $cpu_type == "aarch64" ]]; then
    if ! check_file "$so_path"/libnsl.so.2; then
      if check_file "$a_path"/libnsl.so; then
        create_symlink "N" "$so_path"/libnsl.so "$a_path"/libnsl.so.2
      fi
    fi
  fi
}
function do_fix_libcap() {
  # 修复 libcap.so,libcap.so.1
  if ! check_file "$so_path"/libcap.so; then
    create_symlink "N" "$so_path"/libcap.so.2 "$a_path"/libcap.so
  fi
  if check_file "$so_path"/libcap.so.2; then
    if ! check_file "$so_path"/libcap.so.1; then
      create_symlink "N" "$so_path"/libcap.so.2 "$so_path"/libcap.so.1
    fi
  fi
}
function do_fix_so() {
  do_fix_libnsl
  do_fix_libcap
  # 适配 11GR2 安装
  if ((db_version == 11)); then
    if [[ "$os_type" =~ ^(ubuntu|debian|Deepin)$ ]]; then
      adapt_gcc
    fi
    do_fix_libaio
  fi
  if [[ $cpu_type == "aarch64" ]]; then
    if [[ "$os_type" =~ ^(ubuntu|debian|Deepin)$ ]]; then
      adapt_gcc
    fi
  fi
}
# 在 OpenSSH 升级到 8.x 后 GI 安装失败 INS-06006 (Doc ID 2639907.1)
# GI runInstaller Fails with INS-6006 despite fixing Bug 30159782 (Doc ID 2921432.1)
function adapt_scp() {
  local scp_ver
  scp_ver=$(ssh -V 2>&1 | grep -oP 'OpenSSH_\K[0-9]+\.[0-9]+')
  handle_scp() {
    local scp_verion=$1 original_scp="/usr/bin/scp" new_content="/usr/bin/scp.original -T"
    if (($(echo "$scp_verion >= 8.7" | bc -l))); then
      new_content+=" -O"
    fi
    mv_file "$original_scp"
    write_file "Y" "$original_scp" "$new_content \$*"
    chmod 555 "$original_scp"
  }
  if (($(echo "$scp_ver >= 8.0" | bc -l))); then
    handle_scp "$scp_ver"
  fi
}
function adapt_gcc() {
  local gccbin gccver
  gccbin=$(basename "$(readlink -f /usr/bin/gcc)" | sed 's/.*-\(gcc-[0-9]*\)/\1/')
  gccver=$(basename "$(readlink -f /usr/bin/gcc)" | awk -F '-' '{print $NF}')
  if [[ "$os_type" == "arch" ]]; then
    gccbin="x86_64-pc-linux-gnu-gcc"
    gccver=100
  fi
  mv_file /usr/bin/gcc
  if (($(echo "$gccver >= 4.6  &&  $gccver < 7.0" | bc -l))); then
    write_file "Y" "/usr/bin/gcc" "#!/bin/bash
/usr/bin/$gccbin -Wl,--no-as-needed \$*"
  elif (($(echo "$gccver >= 7.0" | bc -l))); then
    write_file "Y" "/usr/bin/gcc" "#!/bin/bash
/usr/bin/$gccbin -Wl,--no-as-needed -no-pie \$*"
  fi
  chmod 755 /usr/bin/gcc
}
function add_debs_link() {
  /bin/mkdir -p /usr/lib64
  # ubuntu 默认是 bash
  create_symlink "Y" /bin/bash /bin/sh
  # 从某个版本开始用 mawk
  if check_file /usr/bin/gawk; then
    create_symlink "N" /usr/bin/gawk /bin/awk
  else
    create_symlink "N" /usr/bin/mawk /bin/awk
  fi
  find "$a_path" -name "*.o" -exec ln -s {} /usr/lib64/ \;
  create_symlink "N" "$so_path"/libgcc_s.so.1 /usr/lib64
  create_symlink "N" "$so_path"/libstdc++.so.6 /usr/lib64/
  # debs 版本为 7，使用原版
  if ((os_version == 7)); then
    create_symlink "Y" "$a_path"/libc_nonshared.a /usr/lib64/
    create_symlink "Y" "$a_path"/libpthread_nonshared.a /usr/lib64/
  else
    create_symlink "Y" "$a_path"/libc_nonshared.a /usr/lib64/
  fi
  # 针对 Ubuntu 24、Debian 13 版本缺少 libaio.so.1 问题，进行修复
  if ((os_version > 9)); then
    if ! check_file "$so_path"/libaio.so.1; then
      if check_file "$so_path"/libaio.so.1t64; then
        create_symlink "Y" "$so_path"/libaio.so.1t64 "$so_path"/libaio.so.1
      fi
    fi
  fi
}
#==============================================================#
#                             Usage                            #
#==============================================================#
function help() {
  # 打印参数
  print_options() {
    local options=("$@")
    # 调用 color_printf 函数，输出绿色字体
    # ${option%% *} 表示从 option 变量中删除最后一个空格及其后面的字符，保留前面的部分
    # ${option#* } 表示从 option 变量中删除第一个空格及其前面的字符，保留后面的部分
    for option in "${options[@]}"; do
      color_printf green "${option%% *}" "${option#* }"
    done
  }
  # 单机模式
  color_printf blue "用法: OracleShellInstall [选项] 对象 { 命令 | help }"
  color_printf blue "单机模式："
  options=(
    "-lrp 配置本地软件源，需要挂载本地 ISO 镜像源，默认值：[Y]"
    "-nrp 配置网络软件源，默认值：[N]"
    "-lf [必填] 公网 IP 的网卡名称"
    "-n 主机名，默认值：[orcl]"
    "-ou 系统 oracle 用户名称，默认值：[oracle]"
    "-op 系统 oracle 用户密码，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-d Oracle 软件安装根目录，默认值：[/u01]"
    "-ord Oracle 数据文件目录，默认值：[/oradata]"
    "-ard Oracle 归档文件目录，默认值：[/oradata/archivelog]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-dp Oracle 数据库 sys/system 密码，若包含特殊字符(_,#,$)必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-dbs 数据库块大小，默认值：[8192]，可选：[2048|4096|8192|16384|32768]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
    "-hf 安装完成是否配置内存大页，默认值：[N]"
  )
  print_options "${options[@]}"
  # 单机 ASM 模式
  echo
  color_printf blue "单机 ASM 模式："
  options=(
    "-lrp 配置本地软件源，需要挂载本地 ISO 镜像源，默认值：[Y]"
    "-nrp 配置网络软件源，默认值：[N]"
    "-lf [必填] 公网 IP 的网卡名称"
    "-n 主机名，默认值：[orcl]"
    "-ou 系统 oracle 用户名称，默认值：[oracle]"
    "-op 系统 oracle 用户密码，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-d Oracle 软件安装根目录，默认值：[/u01]"
    "-ord Oracle 数据文件目录，默认值：[/oradata]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-gu 系统 grid 用户名称，默认值：[grid]"
    "-gp 系统 grid 用户密码，，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-dp Oracle 数据库 sys/system 密码，若包含特殊字符(_,#,$)必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-adc 是否需要脚本配置 ASM 磁盘，如果不需要配置，则需要自行提前配置好，默认值：[Y]"
    "-mp 是否需要脚本配置 multipath 多路径，如果不需要配置多路径，则使用UDEV直接绑盘，默认值：[Y]"
    "-dd [必填] ASM DATA 磁盘组的磁盘列表，默认传参为(sd名称)：-dd /dev/sdb：若设置参数 -adc N，则传入已配置好的磁盘列表：-dd /dev/asm_data1"
    "-dn ASM DATA 磁盘组名称，默认值：[DATA]"
    "-dr ASM DATA 磁盘组冗余度，默认值：[EXTERNAL]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-dbs 数据库块大小，默认值：[8192]，可选：[2048|4096|8192|16384|32768]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-gpa Grid PSU/RU 补丁编号"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
    "-vbox 在虚拟机 virtualbox 上安装 RAC 时需要设置 -vbox Y，用于修复 BUG，默认值：[N]"
    "-fd 过滤多路径磁盘，去除重复路径，获取唯一盘符：参数值为非ASM盘符（系统盘等），例如：-fd /dev/sda，多个盘符用逗号拼接：-fd /dev/sda,/dev/sdb"
    "-hf 安装完成是否配置内存大页，默认值：[N]"
  )
  print_options "${options[@]}"
  # RAC 集群模式
  echo
  color_printf blue "RAC 模式："
  options=(
    "-lrp 配置本地软件源，需要挂载本地 ISO 镜像源，默认值：[Y]"
    "-nrp 配置网络软件源，默认值：[N]"
    "-lf [必填] RAC 所有节点公网 IP 的网卡名称，所有节点需要保持一致，例如：-lf team0"
    "-pf [必填] RAC 所有节点心跳 IP 的网卡名称，最多支持2组心跳，所有节点需要保持一致，例如：-pf eth3,eth4"
    "-n [必填] RAC 所有节点主机名前缀，参数值必须按照节点顺序排序，例如主机名为 orcl01,orcl02，则参数传值：-n orcl，默认值：[orcl]"
    "-hn [必填] RAC 所有节点主机名，参数值必须按照节点顺序排序，例如：-hn orcl01,orcl02"
    "-ri [必填] RAC 所有节点公网 IP 地址，参数值必须按照节点顺序排序，例如：-ri 10.211.55.100,10.211.55.101"
    "-vi [必填] RAC 所有节点虚拟 IP 地址，参数值必须按照节点顺序排序，例如：-vi 10.211.55.102,10.211.55.103"
    "-si [必填] RAC scan IP 地址，单个scan ip无需配置 DNS，3个scan ip则必须配置 DNS，例如：-si 10.211.55.105,10.211.55.106,10.211.55.107"
    "-d Oracle 数据库软件安装根目录 [/u01]"
    "-rp [必填] 系统 root 用户密码，所有节点必须保持一致，用于建立互信，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'"
    "-gu 系统 grid 用户名称，默认值：[grid]"
    "-gp 系统 grid 用户密码，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-ou 系统 oracle 用户名称，默认值：[oracle]"
    "-op 系统 oracle 用户密码，若包含特殊字符必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-cn RAC 集群名称，长度不能超过15位，可自定义，默认值：主机名前缀(-n参数)-cluser [orcl-cluster]"
    "-sn RAC scan名称，可自定义，默认值：主机名前缀(-n参数)-scan [orcl-scan]"
    "-adc 是否需要脚本配置 ASM 磁盘，如果不需要配置，则需要自行提前配置好，默认值：[Y]"
    "-mp 是否需要脚本配置 multipath 多路径，如果不需要配置多路径，则使用UDEV直接绑盘，默认值：[Y]"
    "-od [必填] ASM OCR 磁盘组的磁盘列表，默认传参为(sd名称)：-od /dev/sdb：若设置参数 -adc N，则传入已配置好的磁盘列表：-od /dev/asm_ocr1"
    "-dd [必填] ASM DATA 磁盘组的磁盘列表，传参方式同 -od"
    "-ad ASM 归档日志磁盘组的磁盘列表，传参方式同 -od"
    "-on ASM OCR 磁盘组名称，默认值：[OCR]"
    "-dn ASM DATA 磁盘组名称，默认值：[DATA]"
    "-an ASM ARCH 磁盘组名称，默认值：[ARCH]"
    "-or ASM OCR 磁盘组冗余度，默认值：[EXTERNAL]"
    "-dr ASM DATA 磁盘组冗余度，默认值：[EXTERNAL]"
    "-ar ASM ARCH 磁盘组冗余度，默认值：[EXTERNAL]"
    "-o Oracle 数据库名称，默认值：[orcl]"
    "-dp Oracle 数据库 sys/system 密码，若包含特殊字符(_,#,$)必须以单引号包裹，例如：'Passw0rd#'，默认值：[oracle]"
    "-ds 数据库字符集，默认值：[AL32UTF8]"
    "-ns 数据库国家字符集，默认值：[AL16UTF16]"
    "-dbs 数据库块大小，默认值：[8192]，可选：[2048|4096|8192|16384|32768]"
    "-er 是否启用归档日志，默认值：[true]"
    "-pdb 用于 CDB 架构，PDB 名称，支持传入多个PDB：-pdb pdb01,pdb02，默认值：[pdb01]"
    "-redo 数据库 redo 日志文件大小，单位为 MB，默认值[1024]"
    "-tsi RAC CTSS 的时间服务器 IP 地址，用于配置所有节点间的时间同步"
    "-dns 是否配置 DNS，如果配置多个scan ip，则需要配置 -dns Y，默认值：[N]"
    "-dnsn DNS 服务器名称"
    "-dnsi DNS 服务器 IP 地址"
    "-gpa Grid PSU/RU 补丁编号"
    "-opa Oracle PSU/RU 补丁编号"
    "-jpa Oracle OJVM PSU/RU 补丁编号"
    "-m 仅配置操作系统，默认值：[N]"
    "-ug 安装到 Grid 软件结束，默认值：[N]"
    "-ud 安装到 Oracle 软件结束，默认值：[N]"
    "-gui 是否安装系统图形界面，默认值：[N]"
    "-opd 安装完成是否优化 Oracle 数据库，默认值：[N]"
    "-vbox 在虚拟机 virtualbox 上安装 RAC 时需要设置 -vbox Y，用于修复 BUG，默认值：[N]"
    "-fd 过滤多路径磁盘，去除重复路径，获取唯一盘符：参数值为非ASM盘符（系统盘等），例如：-fd /dev/sda，多个盘符用逗号拼接：-fd /dev/sda,/dev/sdb"
    "-hf 安装完成是否配置内存大页，默认值：[N]"
  )
  print_options "${options[@]}"
}
#==============================================================#
#                       获取 Grid 安装包信息                     #
#==============================================================#
function get_grid_soft() {
  case "$gi_version" in
  "11")
    cvu_name="cvuqdisk-1.0.9-1.rpm"
    ;;
  *)
    cvu_name="cvuqdisk-1.0.10-1.rpm"
    ;;
  esac
  declare -A gi_version_dirs=(
    ["11"]="$software_dir/p6880880_112000_Linux-x86-64.zip;$env_base_dir/app/11.2.0/grid;$software_dir/p13390677_112040_Linux-x86-64_3of7.zip;$software_dir/grid/rpm/$cvu_name;11.2.0.4.0"
    ["12"]="$software_dir/p6880880_122010_Linux-x86-64.zip;$env_base_dir/app/12.2.0/grid;$software_dir/LINUX.X64_122010_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;12.2.0.1.0"
    ["19"]="$software_dir/p6880880_190000_Linux-x86-64.zip;$env_base_dir/app/19.3.0/grid;$software_dir/LINUX.X64_193000_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;19.0.0.0.0"
    ["21"]="$software_dir/p6880880_210000_Linux-x86-64.zip;$env_base_dir/app/21.3.0/grid;$software_dir/LINUX.X64_213000_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;21.0.0.0.0"
    ["23"]="$software_dir/p6880880_230000_Linux-x86-64.zip;$env_base_dir/app/23.5.0/grid;$software_dir/LINUX.X64_235000_forEngineeredSystems_grid_home.zip;$env_grid_home/cv/rpm/$cvu_name;23.0.0.0.0"
  )
  # 根据选择的 Grid 数据库版本
  IFS=";" read -r grid_opatch_name env_grid_home grid_soft_name cvuqdisk gi_compatible <<<"${gi_version_dirs[$gi_version]}"
  if [[ $cpu_type == "aarch64" ]]; then
    grid_soft_name=$software_dir/LINUX.ARM64_1919000_grid_home.zip
    grid_opatch_name=$software_dir/p6880880_190000_Linux-ARM-64.zip
  fi
  if ((node_num == 1)); then
    if check_file "$grid_soft_name"; then
      case "${gi_version}" in
      "11")
        check_md5sum "$grid_soft_name" "04cef37991db18f8190f7d4a19b26912"
        ;;
      "12")
        check_md5sum "$grid_soft_name" "ac1b156334cc5e8f8e5bd7fcdbebff82"
        ;;
      "19")
        if [[ $cpu_type == "aarch64" ]]; then
          check_md5sum "$grid_soft_name" "e8666c88c56d77c4bdf0188673b3fe37"
        else
          check_md5sum "$grid_soft_name" "b7c4c66f801f92d14faa0d791ccda721"
        fi
        ;;
      "21")
        check_md5sum "$grid_soft_name" "b3fbdb7621ad82cbd4f40943effdd1be"
        ;;
      "23")
        check_md5sum "$grid_soft_name" "bc13cfe0beecd5fd1a75132a7f46bb09"
        ;;
      esac
    else
      color_printf red "请检查 Grid 软件安装包 $grid_soft_name 是否已上传至 $software_dir 目录下！"
    fi
    # 检查 GI OPatch 补丁包是否已上传至指定目录
    if [[ $grid_patch ]]; then
      if ! check_file "$grid_opatch_name"; then
        color_printf red "OPatch 补丁包：$grid_opatch_name 不存在，请检查并上传！"
      fi
    fi
  fi
}
#==============================================================#
#                      获取 Oracle 安装包信息                    #
#==============================================================#
function get_db_soft() {
  # 定义 oracle 相关信息
  declare -A db_version_dirs=(
    ["11"]="$software_dir/p6880880_112000_Linux-x86-64.zip;$env_oracle_base/product/11.2.0/db;$software_dir/p13390677_112040_Linux-x86-64_1of7.zip;$software_dir/p13390677_112040_Linux-x86-64_2of7.zip;;11.2.0.4.0"
    ["12"]="$software_dir/p6880880_122010_Linux-x86-64.zip;$env_oracle_base/product/12.2.0/db;$software_dir/LINUX.X64_122010_db_home.zip;;$iscdb;12.2.0.1.0"
    ["19"]="$software_dir/p6880880_190000_Linux-x86-64.zip;$env_oracle_base/product/19.3.0/db;$software_dir/LINUX.X64_193000_db_home.zip;;$iscdb;19.0.0.0.0"
    ["21"]="$software_dir/p6880880_210000_Linux-x86-64.zip;$env_oracle_base/product/21.3.0/db;$software_dir/LINUX.X64_213000_db_home.zip;;true;21.0.0.0.0"
    ["23"]="$software_dir/p6880880_230000_Linux-x86-64.zip;$env_oracle_base/product/23.5.0/db;$software_dir/LINUX.X64_235000_forEngineeredSystems_db_home.zip;;true;23.0.0.0.0"
  )
  # 根据选择的 Oracle 数据库版本
  IFS=";" read -r db_opatch_name env_oracle_home db_soft_name db_soft_name1 iscdb db_compatible <<<"${db_version_dirs[$db_version]}"
  if [[ $cpu_type == "aarch64" ]]; then
    db_soft_name=$software_dir/LINUX.ARM64_1919000_db_home.zip
    db_opatch_name=$software_dir/p6880880_190000_Linux-ARM-64.zip
  fi
  if ((node_num == 1)); then
    if ((db_version == 11)); then
      if check_file "$db_soft_name" && check_file "$db_soft_name1"; then
        check_md5sum "$db_soft_name" "1616f61789891a56eafd40de79f58f28"
        check_md5sum "$db_soft_name1" "67ba1e68a4f581b305885114768443d3"
      else
        color_printf red "请检查 Oracle 软件安装包 $db_soft_name,$db_soft_name1 是否已上传至 $software_dir 目录下。"
      fi
    else
      if check_file "$db_soft_name"; then
        case "${db_version}" in
        "12")
          check_md5sum "$db_soft_name" "1841f2ce7709cf909db4c064d80aae79"
          ;;
        "19")
          if [[ $cpu_type == "aarch64" ]]; then
            check_md5sum "$db_soft_name" "6c39043ad12e11bcdc505184631e11a2"
          else
            check_md5sum "$db_soft_name" "1858bd0d281c60f4ddabd87b1c214a4f"
          fi
          ;;
        "21")
          check_md5sum "$db_soft_name" "8ac915a800800ddf16a382506d3953db"
          ;;
        "23")
          check_md5sum "$db_soft_name" "2260486cc0383504b35593c40a256a18"
          ;;
        esac
      else
        color_printf red "请检查 Oracle 软件安装包 $db_soft_name 是否已上传至 $software_dir 目录下。"
      fi
    fi
    # 检查 DB/OJVM OPatch 补丁包是否已上传至指定目录
    if [[ $oracle_patch || $ojvm_patch ]]; then
      if ! check_file "$db_opatch_name"; then
        color_printf red "OPatch 补丁包：$db_opatch_name 不存在，请检查并上传！"
      fi
    fi
  fi
}
#==============================================================#
#                     检查操作系统版本是否符合要求                  #
#==============================================================#
function check_os_version() {
  case "$os_type" in
  "anolis")
    if ((os_version == 7)); then
      if ((db_version != 11)); then
        # 检查 12C/19C 版本是否符合条件，否则给出提示并退出
        if [[ $(md5sum /usr/lib64/libc-2.17.so | awk '{print $1}') != "391da37c6f4a98f1103ea72a42490fbb" ]]; then
          if ! check_file "$software_dir"/libc-2.17.so; then
            color_printf red "本脚本在 anolis 7.9 安装 Oracle 12C/19C/21/23 需要上传 libc-2.17.so 到 $software_dir 目录下！
              下载地址：https://www.modb.pro/doc/129426"
          fi
        fi
      fi
    fi
    ;;
  "kylin")
    if ((gi_version == 11)); then
      if ! ls "$software_dir"/libnsl-*.rpm >/dev/null 2>&1; then
        color_printf red "本脚本安装 Oracle 11GR2 Grid 必须上传 libnsl 软件包到 $software_dir 目录下！
            银河麒麟 V10 libnsl 包下载地址：https://update.cs2c.com.cn/NS/V10/"
      fi
    fi
    ;;
  esac
  # 6 版本的操作系统官方不支持 19C 以后的版本
  if ((os_version == 6)); then
    if [[ "$gi_version" =~ ^(19|21|23)$ || "$db_version" =~ ^(19|21|23)$ ]]; then
      color_printf red "Oracle 19C/21C/23ai 官方不支持 Linux 6 版本！"
    fi
  fi
  # 7 版本的操作系统官方不支持 23ai 以后的版本
  if ((os_version == 7)); then
    if ((gi_version == 23 || db_version == 23)); then
      color_printf red "Oracle 23ai 官方不支持 Linux 7 版本！"
    fi
  fi
  # 8 版本以下的操作系统目前不支持 19C ARM 数据库安装
  if [[ "$cpu_type" == "aarch64" ]]; then
    if ((os_version < 8)); then
      color_printf red "本脚本暂不支持 [ $pretty_name ] 安装 Oracle 19C ARM 数据库！"
    fi
    if ((db_version != 19)); then
      color_printf red "官方目前只支持在 Linux ARM 上安装 Orale 19C 版本！"
    fi
  fi
}
#==============================================================#
#                      适配 8 以上操作系统版本类型                 #
#==============================================================#
function adapt_os_version() {
  if ((os_version >= 8)); then
    # 匹配 os_version 8 9 10
    create_libpthreada
    # 匹配 os_version 9 10
    if ((os_version >= 9)); then
      if check_file "$a_path"/libc_nonshared.a; then
        /bin/cp -f "$a_path"/libc_nonshared.a "$a_path"/libc_nonshared.a.original
        ar_libc_nonshareda
      else
        color_printf red "必需文件 $a_path/libc_nonshared.a 文件未找到，请检查原因！"
      fi
    fi
  fi
  # 修复 so 版本
  do_fix_so
  case $os_type in
  "anolis")
    if ((os_version == 7)); then
      if ((db_version != 11)); then
        if check_file "$software_dir"/libc-2.17.so; then
          /bin/mv -f "$software_dir"/libc-2.17.so /usr/lib64/libc-2.17.so
          chmod 755 /usr/lib64/libc-2.17.so
        fi
      fi
    fi
    ;;
  "ubuntu" | "debian" | "Deepin")
    # 添加 deb 系目录链接
    add_debs_link
    ;;
  esac
  # ARM 适配
  if [[ "$cpu_type" == "aarch64" ]]; then
    # 修复 arm 版本 ar,as,nm 找不到问题
    write_file "Y" /etc/oracle-release "Oracle Linux Server release 8"
  fi
  # 适配 scp 版本
  if [[ $oracle_install_mode == "rac" ]]; then
    adapt_scp
  fi
}
function undo_adapt() {
  case $os_type in
  "ubuntu" | "debian" | "Deepin" | "arch")
    # 恢复 gcc链接
    if check_file /usr/bin/gcc.original; then
      /bin/mv -f /usr/bin/gcc.original /usr/bin/gcc
    fi
    ;;
  esac
  # 恢复 libaio 链接
  if check_file "$so_path"/libaio.so.1.original; then
    /bin/mv -f "$so_path"/libaio.so.1.original "$so_path"/libaio.so.1
  fi
}
#==============================================================#
#                        检查 ISO 镜像源挂载                     #
#==============================================================#
function check_iso() {
  # 获取ISO镜像挂载路径，排除光盘挂载的路径 iso9660 以及被删除挂载 ISO 的路径
  mountPath=$(mount | awk '/iso9660/ && !/(deleted)/ && !/run\/media/ && !/\/media/ {print $3}')
  # 检查是否存在多个挂载路径，存在则报错退出
  if [[ $(echo "$mountPath" | wc -l) -gt 1 ]]; then
    echo "$mountPath"
    color_printf red "当前主机存在多个 ISO 镜像源，脚本无法判断，请务必只保留一个！"
  fi
  # 检查是否需要挂载 ISO 镜像源
  if [[ -z $mountPath ]]; then
    # 脚本尝试挂载 ISO 镜像
    if mount /dev/sr0 /mnt >/dev/null 2>&1; then
      mountPath=/mnt
    else
      color_printf red "本地软件源配置需要挂载 ISO 镜像源，建议挂载 Everything ISO 源！"
    fi
  fi
}
#==============================================================#
#                         备份官方软件源                         #
#==============================================================#
# 创建备份目录并移动文件
function backup_repos() {
  local bak_type="$1" source_repo="$2" backup_repo="$3"
  /bin/mkdir -p "$backup_repo" >/dev/null 2>&1
  if [[ "$bak_type" == "d" ]]; then
    find "$source_repo" -mindepth 1 -maxdepth 1 -type f -exec /bin/mv -f {} "$backup_repo" \; >/dev/null 2>&1
  elif [[ "$bak_type" == "f" ]]; then
    /bin/mv -f "$source_repo" "$backup_repo" >/dev/null 2>&1
  fi
}
#==============================================================#
#                        配置本地软件源                          #
#==============================================================#
function conf_local_repository() {
  log_print "配置本地软件源"
  # 配置本地软件源（单一目录）
  conf_rhel7_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/local.repo" "[server]
name=server
baseurl=file://$mountPath
enabled=1
gpgcheck=0"
    cat /etc/yum.repos.d/local.repo
  }
  conf_rhel8_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/local.repo" "[BaseOS]
name=BaseOS
baseurl=file://$mountPath/BaseOS
enabled=1
gpgcheck=0
[AppStream]
name=AppStream
baseurl=file://$mountPath/AppStream
enabled=1
gpgcheck=0"
    cat /etc/yum.repos.d/local.repo
  }
  ## 龙蜥 23 版本
  conf_anolis23_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/local.repo" "[server]
name=os
baseurl=file://$mountPath/os
enabled=1
gpgcheck=0"
    cat /etc/yum.repos.d/local.repo
  }
  # 配置 uos 软件源
  conf_uos_e_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/local.repo" "[BaseOS]
name=BaseOS
baseurl=file://$mountPath
enabled=1
gpgcheck=0
[AppStream]
name=AppStream
baseurl=file://$mountPath/AppStream
enabled=1
gpgcheck=0"
    cat /etc/yum.repos.d/local.repo
  }
  conf_uos_d_repository() {
    local uos_codename
    uos_codename=$(grep -oP '^VERSION_CODENAME="?(\K[^"]+|[^"]+$)' /etc/os-release)
    backup_repos "f" /etc/apt/sources.list /etc/apt/bak
    write_file "Y" "/etc/apt/sources.list" "deb [trusted=yes] file://$mountPath $uos_codename main"
    apt-get update >/dev/null 2>&1
    cat /etc/apt/sources.list
  }
  # 配置本地软件源（分离 BaseOS 和 AppStream）
  conf_rhel_repository() {
    if ((os_version >= 8)); then
      conf_rhel8_repository
    else
      conf_rhel7_repository
    fi
  }
  # 配置 openEuler 软件源
  conf_openeuler_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/local.repo" "[openEuler]
name=openeuler
baseurl=file://$mountPath
enabled=1
gpgcheck=1
gpgkey=file://$mountPath/RPM-GPG-KEY-openEuler"
    cat /etc/yum.repos.d/local.repo
  }
  # 配置 SLES 软件源
  conf_sles_repository() {
    backup_repos "d" "/etc/zypp/repos.d/" "/etc/zypp/repos.d/bak"
    # 适配 openSUSE
    if [[ "$os_type" =~ ^(opensuse-leap|opensuse-tumbleweed)$ ]]; then
      zypper ar -f "$mountPath" opensuse
    else
      case "$os_version" in
      "7") zypper ar -f "$mountPath"/suse sles ;;
      "8" | "9")
        zypper ar -f "$mountPath"/Module-Basesystem sles
        zypper ar -f "$mountPath"/Module-Legacy sles-Legacy
        zypper ar -f "$mountPath"/Module-Development-Tools sles-Tools
        ;;
      esac
    fi
  }
  # 根据不同操作系统类型调用相应的配置函数
  if is_in_list "$os_type" "${local_os_list[@]}"; then
    case $os_type in
    "kylin" | "ningos" | "asianux" | "NFS")
      conf_rhel7_repository
      ;;
    "sles" | "opensuse-leap" | "opensuse-tumbleweed")
      conf_sles_repository
      ;;
    "openEuler" | "ctyunos")
      if [[ "$uos_edition" == "e" ]]; then
        conf_uos_e_repository
      else
        conf_openeuler_repository
      fi
      ;;
    *)
      if [[ $os_type == "anolis" ]] && ((os_version >= 9)); then
        conf_anolis23_repository
      else
        conf_rhel_repository
      fi
      ;;
    esac
  else
    if [[ $os_type == "debian" ]]; then
      # 实际是 uos(d)
      conf_uos_d_repository
    fi
  fi
}
#==============================================================#
#                         配置网络软件源                         #
#==============================================================#
function conf_network_repository() {
  log_print "配置网络软件源"
  # 配置 Fedora 软件源
  conf_fedora_repository() {
    local releasever
    releasever=$(grep -oP '^VERSION_ID="?(\K[^"]+|[^"]+$)' /etc/os-release)
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/fedora.repo" "[fedora]
name=Fedora
failovermethod=priority
baseurl=http://mirrors.tuna.tsinghua.edu.cn/fedora/releases/$releasever/Everything/$cpu_type/os/
metadata_expire=28d
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$cpu_type
skip_if_unavailable=False"
    cat /etc/yum.repos.d/fedora.repo
  }
  # 配置 Euleros 软件源
  conf_euleros_repository() {
    local euler_codename
    euler_codename=$(grep -oP '(?<=release )\d+\.' /etc/euleros-release)$(grep -oP '(?<=SP)\d+' /etc/euleros-release)
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/EulerOS-base.repo" "[base]
name=EulerOS
baseurl=http://mirrors.huaweicloud.com/euler/$euler_codename/os/x86_64/
enabled=1
gpgcheck=1
gpgkey=http://mirrors.huaweicloud.com/euler/$euler_codename/os/RPM-GPG-KEY-EulerOS"
    cat /etc/yum.repos.d/EulerOS-base.repo
  }
  # 配置 Huawei Cloud EulerOS 软件源
  conf_hce_repository() {
    backup_repos "d" "/etc/yum.repos.d/" "/etc/yum.repos.d/bak"
    write_file "Y" "/etc/yum.repos.d/HCE2-base.repo" "[base]
name=HCE-2.0 base
#ARM-Repo
baseurl=https://repo.huaweicloud.com/hce/2.0/os/aarch64/
enabled=1
gpgcheck=1
gpgkey=https://repo.huaweicloud.com/hce/2.0//os/RPM-GPG-KEY-HCE-2"
    cat /etc/yum.repos.d/HCE2-base.repo
  }
  # 配置 arch 软件源
  conf_arch_repository() {
    backup_repos "f" /etc/pacman.d/mirrorlist /etc/pacman.d/bak
    write_file "Y" "/etc/pacman.d/mirrorlist" "Server = http://mirrors.tuna.tsinghua.edu.cn/archlinux/\$repo/os/\$arch"
    cat /etc/pacman.d/mirrorlist
  }
  # 配置 Debian/Ubuntu 软件源
  set_sources() {
    local codename=$1 extra=$2
    new_sources="deb http://mirrors.tuna.tsinghua.edu.cn/debian/ $codename main contrib non-free $extra
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ ${codename}-updates main contrib non-free $extra
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ ${codename}-backports main contrib non-free $extra
deb http://mirrors.tuna.tsinghua.edu.cn/debian-security/ ${codename}-security main contrib non-free $extra"
  }
  conf_deb_repository() {
    local debs_codename
    if check_file "/etc/lsb-release"; then
      debs_codename=$(grep DISTRIB_CODENAME /etc/lsb-release | cut -d '=' -f2)
    elif check_file "/etc/os-release"; then
      debs_codename=$(grep VERSION_CODENAME /etc/os-release | cut -d '=' -f2)
    fi
    backup_repos "f" /etc/apt/sources.list /etc/apt/bak
    if [[ "$os_type" == "debian" ]]; then
      if ((os_version == 7)); then
        wget http://deb.freexian.com/extended-lts/archive-key.gpg -O /tmp/elts-archive-key.gpg >/dev/null 2>&1
        /bin/mv -f /tmp/elts-archive-key.gpg /etc/apt/trusted.gpg.d/freexian-archive-extended-lts.gpg
        new_sources="deb http://mirrors4.tuna.tsinghua.edu.cn/debian-elts $debs_codename main contrib non-free"
      elif ((os_version == 8)); then
        if [[ $debs_codename == "buster" ]]; then
          new_sources="deb http://mirrors4.tuna.tsinghua.edu.cn/debian-elts $debs_codename main contrib non-free"
        else
          set_sources "$debs_codename"
        fi
      elif ((os_version == 9)); then
        set_sources "$debs_codename" "non-free-firmware"
      fi
    elif [[ "$os_type" == "ubuntu" ]]; then
      if [[ "$cpu_type" == "aarch64" ]]; then
        new_sources="deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ $debs_codename main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ ${debs_codename}-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ ${debs_codename}-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ ${debs_codename}-security main restricted universe multiverse"
      else
        new_sources="deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $debs_codename main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ ${debs_codename}-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ ${debs_codename}-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ ${debs_codename}-security main restricted universe multiverse"
      fi
    elif [[ "$os_type" == "Deepin" ]]; then
      new_sources="deb https://community-packages.deepin.com/deepin/ $debs_codename main contrib non-free"
    fi
    write_file "Y" "/etc/apt/sources.list" "$new_sources"
    apt-get update >/dev/null 2>&1
    cat /etc/apt/sources.list
  }
  # 根据不同操作系统类型调用相应的配置函数
  if is_in_list "$os_type" "${net_os_list[@]}"; then
    case $os_type in
    "fedora")
      conf_fedora_repository
      ;;
    "euleros")
      conf_euleros_repository
      ;;
    "arch")
      conf_arch_repository
      ;;
    "hce")
      conf_hce_repository
      ;;
    *)
      conf_deb_repository
      ;;
    esac
  fi
}
#==============================================================#
#                            杀进程                             #
#==============================================================#
function kill_process() {
  local process_name=$1
  pgrep -f "$process_name" | awk '{system("pkill -9 -f "$1)}' >/dev/null 2>&1
}
#==============================================================#
#                        级联删除文件夹内容                       #
#==============================================================#
function cascade_del_file() {
  local file_path=$1
  if [[ -d "$file_path" ]]; then
    find "$file_path" -mindepth 1 -delete >/dev/null 2>&1
  elif [[ -f "$file_path" ]]; then
    /bin/rm -f "$file_path" >/dev/null 2>&1
  fi
}
function send_to_other_nodes() {
  # 创建其他节点的脚本执行命令，将内容保存在变量中
  local node_cmd="./OracleShellInstall -lf $local_ifname -pf $rac_priv_ifname -ri $rac_public_ip \
              -vi $rac_virtual_ip -n $hostname -hn $rac_hostname -o $db_name -d $env_base_dir -rp $root_passwd \
              -gu $grid_user -gp $grid_passwd -ou $oracle_user -op $oracle_passwd -mp $multipath -dns $dns -si $rac_scan_ip \
              -adc $asm_disk_conf -or $ocr_redun -dr $data_redun -install_mode $oracle_install_mode \
              -dbv $db_version -giv $gi_version -gui $isgui -lrp $local_repo -nrp $net_repo -hf $huge_flag -vbox $virtualbox -sn $scan_name"
  # 判断是否存在 ASM 磁盘配置
  if [[ $asm_disk_conf == "N" ]]; then
    node_cmd+=" -od $ocr_base_disk -dd $data_base_disk"
  else
    # 将主节点的 WWID 传递给其他节点，防止共享盘盘符不一致的问题
    node_cmd+=" -od $ocr_disk_wwid -dd $data_disk_wwid"
  fi
  # 判断是否存在 ARCH ASM 磁盘组
  if [[ $arch_base_disk ]]; then
    if [[ $asm_disk_conf == "N" ]]; then
      node_cmd+=" -an $arch_asm_group -ad $arch_base_disk -ar $arch_redun"
    else
      node_cmd+=" -an $arch_asm_group -ad $arch_disk_wwid -ar $arch_redun"
    fi
  fi
  # 判断是否需要时间服务器
  if [[ $timeserver_ip ]]; then
    node_cmd+=" -tsi $timeserver_ip"
  fi
  # 判断是否需要配置DNS
  if [[ $dns_ip && $dns_name ]]; then
    node_cmd+=" -dnsn $dns_name -dnsi $dns_ip"
  fi
  # 将命令以重定向的方式保存到文件中
  echo -n "$node_cmd" >"$software_dir"/racnode.sh
  # 发送脚本和安装程序到其他节点
  for ((i = 1; i < ${#rac_public_ips[@]}; i++)); do
    # ssh 连接到其他节点并创建目录
    ssh -q "${rac_public_ips[i]}" "[[ -f $software_dir || -d $software_dir ]] && /bin/rm -rf $software_dir ; /bin/mkdir -p $software_dir"
    # 将脚本发送到其他节点
    scp -q "$software_dir"/racnode.sh "${rac_public_ips[i]}":"$software_dir"
    # 将节点编号写入脚本中
    ssh -q "${rac_public_ips[i]}" "echo -n ' -node $((i + 1))' >> $software_dir/racnode.sh"
    # 将安装程序发送到其他节点
    scp -q "$software_dir"/OracleShellInstall "${rac_public_ips[i]}":"$software_dir"
    # 拷贝 Grid OPatch 到其他节点
    if check_file "$grid_opatch_name"; then
      scp -q "$grid_opatch_name" "${rac_public_ips[i]}":"$software_dir"
    fi
    # 如果 GI 和 DB 版本不一致，则需要分别拷贝 OPatch 补丁包
    if [[ "$gi_version" != "$db_version" ]]; then
      # 拷贝 DB OPatch 到其他节点
      if check_file "$db_opatch_name"; then
        scp -q "$db_opatch_name" "${rac_public_ips[i]}":"$software_dir"
      fi
    fi
    case "$os_type-$os_version" in
    "anolis-7")
      if check_file "$software_dir"/libc-2.17.so; then
        scp -q "$software_dir"/libc-2.17.so "${rac_public_ips[i]}":"$software_dir"
      fi
      ;;
    esac
    if ls "$software_dir"/libnsl-*.rpm >/dev/null 2>&1; then
      find "$software_dir" -name "libnsl-*.rpm" -exec scp -q {} "${rac_public_ips[i]}":"$software_dir" \;
    fi
    # 如果是 RAC 安装并且存在多个节点，则将 rlwrap 复制到其他节点上
    if ls "$software_dir"/rlwrap-*.gz >/dev/null 2>&1; then
      find "$software_dir" -name "rlwrap-*.gz" -exec scp -q {} "${rac_public_ips[i]}":"$software_dir" \;
    fi
  done
  # 删除本地脚本
  rm_file "$software_dir/racnode.sh"
}
#==============================================================#
#                    检查并更新 RAC 主机时间                      #
#==============================================================#
function check_and_update_date() {
  log_print "检查并更新 RAC 主机时间"
  color_printf green "当前主机时间: $(date)"
  echo
  # 远程主机的IP地址或主机名
  for ip in "${rac_public_ips[@]:1}"; do
    local time_diff_threshold=10 local_time remote_time
    hwclock --systohc >/dev/null 2>&1
    local_time=$(date +%s)
    remote_time=$(ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no "${ip}" "date +%s")
    # 计算时间差
    local time_diff=$((remote_time - local_time))
    # 将时间差转换为绝对值
    time_diff=${time_diff#-}
    # 检查时间是否在阈值内
    if ((time_diff > time_diff_threshold)); then
      color_printf blue "目标主机 (${ip}) 时间误差: ${time_diff} 秒超过 10 秒，正在自动调整目标主机时间："
      # 通过 SSH 将远程主机时间调整为当前主机时间并写入硬件时间，防止重启失效
      ssh -q -o ConnectTimeout=1 -o ConnectionAttempts=1 -o PreferredAuthentications=publickey -o StrictHostKeyChecking=no "${ip}" "date -s '@${local_time}' && hwclock --systohc" >/dev/null 2>&1
      echo
      color_printf blue "主机 (${ip}) 时间已经更新。"
    else
      color_printf blue "目标主机 (${ip}) 时间误差: ${time_diff} 秒小于 10 秒，无需调整！"
    fi
  done
}
#==============================================================#
#                      ROOT SSH Trust                          #
#==============================================================#
function root_ssh_trust() {
  #  对所有未互信的IP进行互信配置
  if [[ $(ssh_check root "${ssh_ips[@]}") == "false" ]]; then
    log_print "配置 root 用户互信"
    install_package "expect"
    # 检查是否有 expect 命令
    if ! type expect >/dev/null 2>&1; then
      color_printf red "本脚本安装 RAC 需要使用 expect 命令互信，当前 expect 未安装成功，请检查 YUM 源配置是否正确！"
    fi
    # 主节点 root ssh 互信，只需要公网 IP
    ssh_trust root "$root_passwd" "${ssh_ips[@]}"
    # 互信完成后检查互信是否成功
    if [[ $(ssh_check root "${ssh_ips[@]}") == "false" ]]; then
      color_printf red "root 用户互信失败，请检查参数 [ -rp ] 传入的 root 密码： $root_passwd 是否正确！"
    fi
  fi
}
#==============================================================#
#                         打印环境信息                           #
#==============================================================#
function print_sysinfo() {
  log_print "打印系统信息"
  print_cpu_info() {
    # 定义关联数组的键的顺序
    local keys=("A" "B" "C" "D" "E")
    # 保存要提取的信息的关键词
    declare -A keywords=(
      ["A"]="$(grep </proc/cpuinfo "model name" | head -n 1 | awk -F ': ' '{print $2}')"
      ["A_DESC"]="型号名称                "
      ["B"]="$(grep </proc/cpuinfo "physical id" | sort | uniq | wc -l)"
      ["B_DESC"]="物理 CPU 个数           "
      ["C"]="$(grep </proc/cpuinfo "core id" | sort -u | wc -l)"
      ["C_DESC"]="每个物理 CPU 的逻辑核数 "
      ["D"]="$(grep -c "processor" /proc/cpuinfo)"
      ["D_DESC"]="系统的 CPU 线程数       "
      ["E"]="$cpu_type"
      ["E_DESC"]="系统的 CPU 类型         "
    )
    # 循环提取信息并按顺序打印
    for key in "${keys[@]}"; do
      local desc="${keywords[${key}_DESC]}"
      local value="${keywords[$key]}"
      color_printf green "$desc ：$value"
    done
  }
  ## 服务器时间
  color_printf blue "服务器时间: "
  date
  ## 操作系统版本
  echo
  color_printf blue "操作系统版本: "
  if check_file /etc/os-release; then
    cat /etc/os-release
  elif check_file /etc/system-release; then
    cat /etc/system-release
  elif check_file /etc/redhat-release; then
    cat /etc/redhat-release
  fi
  ## 内核信息
  echo
  color_printf blue "内核信息: "
  cat /proc/version
  ## glibc 版本信息
  echo
  color_printf blue "Glibc 版本: "
  ldd --version | head -n 1 | awk '{print $NF}'
  ## cpu信息
  echo
  color_printf blue "CPU 信息: "
  print_cpu_info
  ## 内存信息
  echo
  color_printf blue "内存信息: "
  free -m
  ## 挂载信息
  echo
  color_printf blue "挂载信息: "
  grep </etc/fstab -E -v '^#|^$'
  ## 目录信息
  echo
  color_printf blue "目录信息: "
  df -h
}
#==============================================================#
#                         configure swap                       #
#==============================================================#
# 定义名为 conf_swap 的函数，用于配置交换空间
function conf_swap() {
  # 判断 /etc/fstab 文件中是否存在 /swapfile 文件这行，如果没有则添加
  if ! grep -q '/swapfile swap swap defaults 0 0' /etc/fstab; then
    log_print "配置 SWAP 交换空间"
    rm_file /swapfile
    # 创建指定大小的空文件 /swapfile，并将其格式化为交换分区
    dd if=/dev/zero of=/swapfile bs=1K count=$swap_count >/dev/null 2>&1
    # 设置文件权限为 0600
    chmod 600 /swapfile
    # 格式化文件为 Swap 分区
    mkswap /swapfile >/dev/null 2>&1
    # 启用 Swap 分区
    swapon /swapfile >/dev/null 2>&1
    # 将 Swap 分区信息添加到 /etc/fstab 文件中，以便系统重启后自动加载
    write_file "N" "/etc/fstab" "/swapfile swap swap defaults 0 0"
    free -m
  fi
}
#==============================================================#
#                           禁用防火墙                           #
#==============================================================#
function disable_firewall() {
  log_print "禁用防火墙"
  case "$os_type" in
  "ubuntu" | "debian" | "Deepin")
    if type ufw >/dev/null 2>&1; then
      ufw stop && ufw disable >/dev/null 2>&1
      ufw status
    else
      color_printf blue "当前主机未安装防火墙，无需配置！"
    fi
    ;;
  "sles")
    if ((os_version == 7)); then
      service SuSEfirewall2 stop && SuSEfirewall2 off >/dev/null 2>&1
      service SuSEfirewall2 status
    else
      systemctl stop firewalld.service && systemctl disable firewalld.service >/dev/null 2>&1
      systemctl status firewalld
    fi
    ;;
  *)
    if ((os_version == 6)); then
      chkconfig iptables off && service iptables stop >/dev/null 2>&1
      service iptables status
    else
      systemctl stop firewalld.service && systemctl disable firewalld.service >/dev/null 2>&1
      systemctl status firewalld
    fi
    ;;
  esac
}
#==============================================================#
#                         禁用 Selinux                          #
#==============================================================#
function disable_selinux() {
  log_print "禁用 SELinux"
  # 检查 SELinux 是否已经被禁用
  if [[ $(getenforce) != "Disabled" ]]; then
    # 临时关闭 SELinux
    setenforce 0
  fi
  # 更新配置文件中的 SELINUX 配置
  sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
  # 记录更新后的 SELINUX 配置
  sestatus
}
#==============================================================#
#                       配置 nsysctl.conf                       #
#==============================================================#
function conf_nsysctl() {
  # 检查是否已经存在 NOZEROCONF=yes 的配置选项，如果不存在则添加之
  if ! grep -q "^NOZEROCONF=yes$" /etc/sysconfig/network; then
    log_print "配置 nsysctl.conf"
    # 备份原始配置文件
    backup_restore_file /etc/sysconfig/network
    # 追加 NOZEROCONF=yes 配置选项
    write_file "N" "/etc/sysconfig/network" "# OracleBegin
NOZEROCONF=yes"
    # 记录更改前后的差异到日志中
    grep -v "^\s*\(#\|$\)" /etc/sysconfig/network
  fi
}
#==============================================================#
#                         GUI Install                          #
#==============================================================#
function install_gui() {
  color_printf green "正在安装图形化界面："
  # 如果需要图形界面，则安装 GUI 软件包
  if [[ "$os_type" == "rhel" ]]; then
    case "$os_version" in
    "6")
      install_package "nautilus-open-terminal" "tigervnc-server"
      yum groupinstall -y -q "X Window System" "Desktop" >/dev/null 2>&1
      ;;
    "7" | "8" | "9")
      install_package "tigervnc-server"
      yum groupinstall -y -q "Server with GUI" >/dev/null 2>&1
      ;;
    esac
  fi
}
#==============================================================#
#                         RPM Install                          #
#==============================================================#
# 安装软件包（如果未安装）
function install_package() {
  local yum_cmd
  case "$os_type" in
  "sles")
    yum_cmd=zypper
    ;;
  "arch")
    yum_cmd=pacman
    ;;
  "ubuntu" | "debian" | "Deepin")
    yum_cmd=apt-get
    ;;
  *)
    if ((os_version <= 7)); then
      yum_cmd=yum
    else
      yum_cmd=dnf
    fi
    ;;
  esac
  # 安装软件包
  for package in "$@"; do
    if [[ "$os_type" == "arch" ]]; then
      # 更新包索引并尝试安装软件包
      install_cmd="$yum_cmd -S --noconfirm \"$package\""
    else
      # 直接尝试安装软件包
      install_cmd="$yum_cmd install -y \"$package\""
    fi
    # 执行安装命令并检查是否成功
    if ! eval "$install_cmd" >/dev/null 2>&1; then
      if is_in_list "$package" "${must_packages[@]}"; then
        if [[ "$package" =~ ^libnsl[0-9]*$ ]]; then
          if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
            color_printf red "Oracle Gird 安装需要依赖包 $package ，当前未成功安装，请检查。"
          fi
        fi
      fi
    fi
  done
}
#==============================================================#
#                          安装软件包                            #
#==============================================================#
function pkg_install() {
  log_print "安装依赖软件包"
  local option_packages must_packages
  if [[ $isgui == "Y" ]]; then
    install_gui
  fi
  if is_in_list "$os_type" "${rhel_os_list[@]}"; then
    # 定义可选软件包列表
    option_packages=(
      libaio-devel                 # 异步 I/O 库开发包
      e2fsprogs                    # EXT2/3/4 文件系统工具
      e2fsprogs-libs               # EXT2/3/4 文件系统库
      smartmontools                # 硬盘监控工具
      net-tools                    # 网络工具（如 ifconfig）
      nfs-utils                    # NFS 客户端和服务器工具
      elfutils-libelf              # 处理 ELF 文件的库
      elfutils-libelf-devel        # ELF 文件库的开发包
      libibverbs                   # RDMA (Remote Direct Memory Access) 库
      librdmacm                    # RDMA 通信管理库
      fontconfig                   # 字体配置工具
      fontconfig-devel             # 字体配置开发工具
      libXrender                   # X Rendering Extension 库
      libXrender-devel             # X Rendering Extension 开发包
      libX11                       # X11 库
      libXau                       # X11 认证库
      libXi                        # X Input Extension 库
      libXtst                      # X Testing 库
      libxcb                       # X11 协议 C 语言绑定库
      unixODBC                     # ODBC 数据库访问库
      sysstat                      # 性能监控工具
      readline                     # 提供行编辑功能的库
      readline-devel               # readline 库的开发包
      policycoreutils              # SELinux 工具
      libvirt-libs                 # 虚拟化库
      policycoreutils-python-utils # SELinux Python 工具
      libnsl2                      # 网络服务库 v2
      libasan                      # AddressSanitizer 库
      liblsan                      # LeakSanitizer 库
      compat-openssl10             # 兼容的 OpenSSL 1.0 库
      libxcrypt-compat             # 兼容的加密库
      compat-openssl11             # 兼容的 OpenSSL 1.1 库
      libgfortran                  # Fortran编译器的运行时库
      rlwrap                       # 提供 GNU readline 功能的包装器，增加行编辑和历史记录支持
    )
    # 定义必需软件包列表
    must_packages=(
      psmisc
      tar             # 解压工具
      glibc           # GNU C 库
      libaio          # 异步 I/O 库
      libgcc          # GCC 运行时库
      libstdc++       # C++ 标准库
      bc              # 任意精度计算器语言
      make            # 编译工具
      binutils        # 二进制工具
      glibc-devel     # GNU C 库开发包
      ksh             # KornShell (KSH) 解释器
      libstdc++-devel # C++ 标准库开发包
      unzip           # 解压工具
      gcc             # GNU 编译器集合
      gcc-c++         # GNU C++ 编译器
    )
    # 根据操作系统版本追加必需软件包
    case "${os_version}" in
    "6")
      must_packages+=(
        compat-libstdc++-33 # 兼容的 C++ 标准库
        compat-libcap1      # 兼容的 libcap1 库
      )
      ;;
    "7")
      must_packages+=(
        compat-libcap1 # 兼容的 libcap1 库
      )
      ;;
    "8" | "9" | "10")
      must_packages+=(
        libnsl # 网络服务库
        initscripts
      )
      ;;
    esac
  elif is_in_list "$os_type" "${deb_os_list[@]}"; then
    option_packages=(
      bc              # 数学运算工具
      libnsl2         # 网络服务库版本 2
      sysstat         # 系统统计信息收集工具
      net-tools       # 网络工具（已废弃，推荐使用 iproute2）
      libelf-dev      # ELF 库的开发文件
      xauth           # X 认证工具
      libxi6          # X11 输入扩展库
      libxtst6        # X11 测试扩展库
      x11-utils       # X11 实用工具
      libxrender-dev  # X 渲染扩展的开发文件
      libreadline8    # GNU readline 库版本 8
      libreadline-dev # GNU readline 库的开发文件
      rlwrap          # Readline 包装器 - 为程序增加 readline 支持
      lsb-release     # Linux 标准基础版本信息
      ksh             # KornShell 解释器
      libaio-dev      # 异步 I/O 库的开发文件
      libnsl-dev      # 网络服务库的开发文件
      libgcc-s1       # GNU C 库的共享库
      build-essential
      smartmontools # 硬盘监控工具
    )
    must_packages=(
      psmisc
      tar        # 解压工具
      unzip      # 解压缩工具
      gcc        # GNU 编译器集合
      make       # 构建工具
      libstdc++6 # GNU 标准 C++ 库
      rpm2cpio
      cpio
    )
    if ((libc_version >= 39)); then
      must_packages+=(
        libaio1t64    # 异步 I/O 库（64 位）
        libpcap0.8t64 # 网络数据包捕获库（64 位）
      )
    else
      must_packages+=(
        libaio1    # 异步 I/O 库
        libpcap0.8 # 网络数据包捕获库
      )
    fi
  elif [[ "$os_type" == "sles" ]]; then
    option_packages=(
      xz                    # XZ压缩工具
      libcap-ng-utils       # libcap-ng工具集
      libcap-ng0            # libcap-ng库
      libcap-progs          # POSIX访问控制列表工具
      libpcre1              # Perl兼容正则表达式库
      libpng16-16           # PNG图片格式库
      libstdc++6            # GNU标准C++库
      libtiff5              # TIFF图片格式库
      mksh                  # MirBSD Korn Shell
      nfs-kernel-server     # NFS服务器
      pixz                  # 多线程XZ压缩工具
      rdma-core             # RDMA核心库
      libX11-6              # X11库
      libXau6               # X11认证库
      libXrender1           # X11渲染库
      libXtst6              # X11测试库
      xorg-x11              # X.Org X11元包
      xorg-x11-Xvnc         # X.Org X11虚拟网络计算机
      xorg-x11-driver-video # X.Org X11视频驱动程序
      xorg-x11-essentials   # X.Org X11基本组件
      xorg-x11-fonts        # X.Org X11字体
      xorg-x11-fonts-core   # X.Org X11字体核心
      xorg-x11-libs         # X.Org X11库
      xorg-x11-server       # X.Org X11服务器
      xorg-x11-server-extra # X.Org X11服务器额外组件
    )
    must_packages=(
      psmisc
      make
      tar          # 解压工具
      unzip        # 解压缩工具
      bc           # 数学运算工具
      binutils     # GNU二进制工具集
      gcc          # GNU编译器集合
      glibc        # GNU C库
      libaio-devel # 异步I/O库的开发文件
      libaio1      # 异步I/O库
      libcap1      # POSIX访问控制列表库（旧版本）
      libcap2      # POSIX访问控制列表库（新版本）
      libgcc_s1    # GNU C库的共享库
      libpcap1     # 网络数据包捕获库
      iputils      # 网络实用工具包
      libnsl1
    )
    case "$os_version" in
    "7")
      must_packages+=(
        gcc-c++           # GNU C++编译器
        gcc-info          # GCC信息文档
        gcc-locale        # GCC本地化文件
        gcc48             # GCC 4.8编译器
        gcc48-c++         # GCC 4.8 C++编译器
        gcc48-info        # GCC 4.8信息文档
        gcc48-locale      # GCC 4.8本地化文件
        libelf-devel      # ELF库的开发文件
        libgfortran3      # GNU Fortran运行时库
        libjpeg-turbo     # JPEG图像压缩库，Turbo版本
        libjpeg62         # JPEG图像压缩库，版本62
        libjpeg62-turbo   # JPEG图像压缩库，Turbo版本，版本62
        libpcre16-0       # PCRE 16位正则表达式库
        libstdc++-devel   # GNU标准C++库的开发文件
        libstdc++48-devel # GCC 4.8的GNU标准C++库开发文件
      )
      ;;
    "8")
      must_packages+=(
        insserv-compat   # 用于系统初始化脚本的兼容性支持
        libXext-devel    # X11扩展库的开发文件
        libXext6         # X11扩展库
        libXi-devel      # X11输入扩展库的开发文件
        libXi6           # X11输入扩展库
        libXrender-devel # X11渲染扩展库的开发文件
        libelf1          # ELF库
        libgfortran4     # GNU Fortran运行时库
        libjpeg8         # JPEG图像压缩库，版本8
        rdma-core-devel  # RDMA核心库的开发文件
        libreadline7     # GNU readline库，版本7
        readline-devel   # GNU readline库的开发文件
      )
      ;;
    "9")
      must_packages+=(
        insserv-compat # 用于系统初始化脚本的兼容性支持
        systemd-sysvcompat
      )
      ;;
    esac
  elif [[ "$os_type" == "arch" ]]; then
    option_packages=(
      xorg-xdpyinfo    # X.Org显示信息工具
      xorg-xauth       # X.Org身份验证工具
      net-tools        # 网络工具（已废弃，推荐使用 iproute2）
      inetutils        # Internet工具集
      libxcrypt-compat # 兼容性支持库，用于密码哈希和加密
    )
    must_packages=(
      psmisc
      tar    # 解压工具
      gcc    # GNU编译器集合
      make   # 构建工具
      bc     # 数学运算工具
      unzip  # 解压缩工具
      libnsl # 网络服务库
      libaio # 异步I/O库
    )
  fi
  if [[ "$cpu_type" == "aarch64" ]]; then
    must_packages+=(
      psmisc
      gcc # GNU 编译器集合
      g++ # GNU C++ 编译器
    )
  fi
  packages=("${must_packages[@]}" "${option_packages[@]}")
  local packages_display
  packages_display=$(printf '%s \\\n' "${packages[@]}" | sed '$s/\\$//')
  color_printf blue "$packages_display"
  log_print "静默安装软件包"
  install_package "${packages[@]}"
  color_printf blue "检查必需软件包安装情况："
  if [[ "$os_type" =~ ^(ubuntu|debian|Deepin)$ ]]; then
    for package in "${must_packages[@]}"; do
      dpkg-query -f '${binary:Package}\n' -W | grep "$package"
    done
  elif [[ "$os_type" == "arch" ]]; then
    for package in "${must_packages[@]}"; do
      pacman -Qs "$package"
    done
  else
    rpm -q "${must_packages[@]}"
  fi
}
#==============================================================#
#                           配置主机名                           #
#==============================================================#
function conf_hostname() {
  log_print "配置主机名"
  if [[ "$os_type" == "sles" ]]; then
    local hostname_file="/etc/hostname"
  else
    case "$os_version" in
    "6")
      local hostname_file="/etc/sysconfig/network"
      ;;
    *)
      local hostname_file="/etc/hostname"
      ;;
    esac
  fi
  # 检查新主机名是否已设置，并且不存在于相应的主机名文件中
  if ! grep -Fxq "$HOSTNAME" "$hostname_file"; then
    # 设置新主机名
    case "$os_version" in
    "6")
      hostname "$HOSTNAME"
      sysctl kernel.hostname="$HOSTNAME"
      write_file "Y" "/proc/sys/kernel/hostname" "$HOSTNAME"
      sed -i "s/^HOSTNAME=.*/HOSTNAME=$HOSTNAME/" "$hostname_file"
      # 记录日志
      hostname
      ;;
    *)
      # 包含了 sles 版本
      hostnamectl set-hostname "$HOSTNAME"
      write_file "Y" "$hostname_file" "$HOSTNAME"
      # 记录日志
      hostnamectl
      ;;
    esac
  else
    cat "$hostname_file"
  fi
}
#==============================================================#
#                      配置 /etc/hosts 文件                     #
#==============================================================#
function conf_hosts() {
  log_print "配置 /etc/hosts 文件" >>"$oracleinstalllog"
  # 备份 /etc/hosts 文件
  backup_restore_file /etc/hosts
  # 配置 RAC hosts 文件
  if [[ "$oracle_install_mode" == "rac" ]]; then
    # 检查 /etc/hosts 文件权限是否为 644，否则修改
    [[ $(stat -c "%a" /etc/hosts) != 644 ]] && chmod 644 /etc/hosts
    # 将集群节点信息写入 hosts 文件中
    write_file "N" "/etc/hosts" "
# OracleBegin"
    local node
    for i in "${!rac_hostnames[@]}"; do
      ((node = i + 1))
      local priv_count=0
      # 将PublicIP和主机名写入互信数组
      hosts_array+=("${rac_public_ips[i]}" "${rac_hostnames[i]}")
      write_file "N" "/etc/hosts" "
# RAC$node IP's: ${rac_hostnames[i]}

# RAC$node Public IP
${rac_public_ips[i]} ${rac_hostnames[i]}
# RAC$node Virtual IP
${rac_virtual_ips[i]} ${rac_hostnames[i]}-vip
# RAC$node Private IP"
      # 遍历心跳IP排序数组，按顺序输出心跳地址
      for node_name in "${rac_priv_ifnames_sorted[@]}"; do
        # 遍历心跳关联数组列表，找到属于当前节点的私有 IP，并将其写入 hosts 文件中
        for ifname in "${!rac_priv_ips[@]}"; do
          # 心跳IP按顺序输出
          if [[ $ifname == *"$node_name"* ]]; then
            # 用公网IP地址来匹配心跳
            if [[ $ifname == *"${rac_public_ips[i]}"* ]]; then
              ((priv_count++))
              # 根据私有 IP 数量添加相应的后缀，用于区分不同的私有 IP
              if ((priv_count > 1)); then
                # 将心跳IP和心跳主机名写入互信数组
                hosts_array+=("${rac_priv_ips[$ifname]}" "${rac_hostnames[i]}-priv1")
                write_file "N" "/etc/hosts" "${rac_priv_ips[$ifname]} ${rac_hostnames[i]}-priv1"
              else
                # 将心跳IP和心跳主机名写入互信数组
                hosts_array+=("${rac_priv_ips[$ifname]}" "${rac_hostnames[i]}-priv")
                write_file "N" "/etc/hosts" "${rac_priv_ips[$ifname]} ${rac_hostnames[i]}-priv"
              fi
            fi
          fi
        done
      done
    done
    # 如果有 SCAN IP，则将其写入到 hosts 文件中
    if ((scan_count == 1)); then
      write_file "N" "/etc/hosts" "
# SCAN IP
${rac_scan_ips[0]} $scan_name"
    fi
  else
    # 配置单实例 hosts 文件
    write_file "N" "/etc/hosts" "
# OracleBegin
# Public IP
$local_ip	$hostname"
  fi
  grep -v "^\s*\(#\|$\)" /etc/hosts >>"$oracleinstalllog" 2>&1 &
}
#==============================================================#
#                        创建用户和组                            #
#==============================================================#
function create_users_groups() {
  log_print "创建用户和组"
  # 定义标记空值标记
  local flag
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    flag="true"
  fi
  # 定义os用户组
  local group_groups=("oinstall:54321" "dba:54322" "oper:54323" "backupdba:54324" "dgdba:54325" "kmdba:54326" "racdba:54330" ${flag:+"asmdba:54327"} ${flag:+"asmoper:54328"} ${flag:+"asmadmin:54329"})
  local user_groups=("$oracle_user" ${flag:+$grid_user})
  # 定义os用户密码数组
  declare -A passwd_groups=(
    [$oracle_user]=$oracle_passwd
    [$grid_user]=$grid_passwd
  )
  # 循环创建组
  for group in "${group_groups[@]}"; do
    local groupname=${group%%:*}
    local gid=${group##*:}
    # 如果不存在，则创建新组
    if ! grep -E -q "^$groupname:" /etc/group; then
      groupadd -g "$gid" "$groupname" >/dev/null 2>&1
    fi
  done
  for user in "${user_groups[@]}"; do
    local uid
    uid=$([[ $user == "$oracle_user" ]] && echo "54321" || echo "11012")
    local primary_group=oinstall
    local other_groups=dba,oper,backupdba,dgdba,kmdba,racdba${flag:+",asmdba"}${flag:+",asmoper"}${flag:+",asmadmin"}
    if ! id -u "$user" >/dev/null 2>&1; then
      useradd -u "$uid" -g $primary_group -G "$other_groups" -m "$user" >/dev/null 2>&1
    else
      usermod -g $primary_group -G "$other_groups" "$user" >/dev/null 2>&1
    fi
    # 为用户设置密码
    echo "$user:${passwd_groups[$user]}" | chpasswd >/dev/null 2>&1
    # 记录日志，输出创建的 grid 和 oracle 用户信息
    color_printf blue "$user 用户："
    id "$user"
    echo
  done
}
#==============================================================#
#                         创建安装目录                           #
#==============================================================#
function create_dir() {
  # 创建 Oracle 环境所需目录
  /bin/mkdir -p "$env_oracle_home" "$env_oracle_inven" "$backup_dir" "$oradata_dir"
  # 如果安装模式是 "RAC" (Real Application Clusters)
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    cascade_del_file "$env_grid_home"
    # 创建额外的目录，并设置属性
    /bin/mkdir -p "$env_grid_base" "$env_grid_home"
    chown -R $grid_user:oinstall {$env_base_dir,"$env_grid_home","$env_oracle_inven"}
    chown -R $oracle_user:oinstall {"$backup_dir","$env_oracle_base"}
  else
    /bin/mkdir -p "$archive_dir"
    chown -R $oracle_user:oinstall {"$oradata_dir","$backup_dir","$env_base_dir","$archive_dir"}
  fi
  chmod -R 775 "$env_base_dir"
}
#==============================================================#
#                        配置 avahi deamon                      #
#==============================================================#
# 安装并配置 Avahi 服务
function conf_avahi() {
  log_print "配置 Avahi-daemon 服务"
  case "$os_version" in
  "6")
    # 如果 avahi-daemon 已经启用，则停止并禁用它
    if (($(chkconfig --list | grep avahi-daemon | grep -c '3:on') > 0)); then
      service avahi-daemon stop
      chkconfig avahi-daemon off
    fi
    # 记录 avahi-daemon 状态
    service avahi-daemon status
    ;;
  *)
    # 停止 avahi-daemon 服务，并使用 "pgrep" 命令杀死任何残留进程
    if (($(systemctl status avahi-daemon | grep -c running) > 0)); then
      systemctl stop avahi-daemon.socket >/dev/null 2>&1
      systemctl stop avahi-daemon.service >/dev/null 2>&1
      kill_process "avahi-daemon"
      # 禁用 avahi-daemon 服务
      systemctl disable avahi-daemon.service >/dev/null 2>&1
      systemctl disable avahi-daemon.socket >/dev/null 2>&1
    fi
    # 记录 avahi-daemon 状态
    systemctl status avahi-daemon
    ;;
  esac
}
#==============================================================#
#               配置 THP && numa && ASM I/O scheduler           #
#==============================================================#
function conf_grub() {
  log_print "配置透明大页 && NUMA && 磁盘 IO 调度器"
  set_kernel_option() {
    local option="$1"
    if grubby --info=ALL | grep -q "$option"; then
      return 0
    fi
    grubby --update-kernel=ALL --args="$option"
  }
  case "$os_type" in
  "ubuntu" | "debian" | "sles" | "arch" | "Deepin")
    sed -i 's/quiet/quiet transparent_hugepage=never numa=off tsx=off elevator=deadline/' /etc/default/grub
    sed -i 's|GRUB_DISABLE_OS_PROBER="true"|GRUB_DISABLE_OS_PROBER="false"|' /etc/default/grub
    if [[ "$os_type" =~ ^(ubuntu|debian|arch|Deepin)$ ]]; then
      grub-mkconfig -o /boot/grub/grub.cfg
    elif [[ "$os_type" == "sles" ]]; then
      grub2-mkconfig -o /boot/grub2/grub.cfg
    fi
    ;;
  *)
    local options=("numa=off" "transparent_hugepage=never" "elevator=deadline")
    for option in "${options[@]}"; do
      set_kernel_option "$option"
    done
    grubby --info=ALL | awk '/numa/{print $0 "\n-" $(NR-1) "\n-" $(NR-2)}'
    ;;
  esac
}
#==============================================================#
#                        配置 sysctl.conf                       #
#==============================================================#
function conf_sysctl() {
  log_print "配置 sysctl.conf"
  # 获取系统页面大小，用于计算内存总量
  local pagesize min_free_kbytes shmall shmmax
  pagesize=$(getconf PAGE_SIZE)
  # min_free_kbytes = os_memory_total * 0.004
  ((min_free_kbytes = os_memory_total / 250))
  ((shmall = (os_memory_total - 1) * 1024 / pagesize))
  ((shmmax = os_memory_total * 1024 - 10))
  # 如果 shmall 小于 2097152，则将其设为 2097152
  ((shmall < 2097152)) && shmall=2097152
  # 如果 shmmax 小于 4294967295，则将其设为 4294967295
  ((shmmax < 4294967295)) && shmmax=4294967295
  # 备份 sysctl 配置文件
  backup_restore_file /etc/sysctl.conf
  # 使用 Here Document 来追加配置参数到 sysctl.conf 文件中
  write_file "Y" "/etc/sysctl.conf" "# OracleBegin
fs.aio-max-nr = 1048576
fs.file-max = 6815744
kernel.shmall = $shmall
kernel.shmmax = $shmmax
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048576
vm.min_free_kbytes=$min_free_kbytes
net.ipv4.conf.$local_ifname.rp_filter = 1
vm.swappiness = 10
kernel.panic_on_oops = 1
kernel.randomize_va_space = 2
vm.hugetlb_shm_group=54321"
  # 修复 centos6 部分版本没有这个参数
  if [[ $os_version != "6" ]]; then
    write_file "N" "/etc/sysctl.conf" "kernel.numa_balancing = 0"
  fi
  # 如果在 RAC 模式下安装，追加 RAC 参数
  for priv_ifname in "${rac_priv_ifnames[@]}"; do
    if [[ $priv_ifname ]]; then # 检查非空
      write_file "N" "/etc/sysctl.conf" "net.ipv4.conf.$priv_ifname.rp_filter = 2"
    fi
  done
  # 重新加载 sysctl 配置，并将结果输出到日志中
  color_printf blue "查看 sysctl.conf 配置情况 ：sysctl -p"
  sysctl -p
}
#==============================================================#
#                         配置 RemoveIPC                        #
#==============================================================#
function conf_ipc() {
  log_print "配置 RemoveIPC"
  # redhat6 版本无需配置
  # 检查是否需要设置 RemoveIPC=no。如果不需要设置则直接返回。
  # Failed Install of RAC with ASM: ORA-27300 ORA-27302 ORA-27300 ORA-27301 ORA-27302 (文档 ID 2099563.1)
  # ORA-27300 ORA-27301 ORA-27302 ORA-27157 Database Crash (文档 ID 438205.1)
  if grep -Fq "#RemoveIPC=yes" "$logind_file"; then
    sed -i 's/#RemoveIPC=yes/RemoveIPC=no/' "$logind_file"
  fi
  if grep -Fq "#RemoveIPC=no" "$logind_file"; then
    # 将 "#RemoveIPC=no" 行替换为 "RemoveIPC=no"
    sed -i 's/#RemoveIPC=no/RemoveIPC=no/' "$logind_file"
  fi
  # 重新加载 systemd 守护进程并重启 systemd-logind 服务
  systemctl daemon-reload >/dev/null 2>&1
  systemctl restart systemd-logind >/dev/null 2>&1
  # 检查是否已修改成功
  color_printf blue "查看 RemoveIPC ：$logind_file"
  grep "RemoveIPC" "$logind_file"
}
#==============================================================#
#                         配置 limits.conf                     #
#==============================================================#
function conf_limits() {
  log_print "配置 /etc/security/limits.conf 和 /etc/pam.d/login"
  # 备份 /etc/security/limits.conf 文件
  backup_restore_file /etc/security/limits.conf
  # 在 /etc/security/limits.conf 文件末尾添加 Oracle 的配置
  write_file "N" "/etc/security/limits.conf" "# OracleBegin
$oracle_user soft nofile 1024
$oracle_user hard nofile 65536
$oracle_user soft stack 10240
$oracle_user hard stack 32768
$oracle_user soft nproc 16384
$oracle_user hard nproc 16384
$oracle_user hard memlock unlimited
$oracle_user soft memlock unlimited"
  # 如果 Oracle 安装模式为 RAC，则添加额外的配置
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    write_file "N" "/etc/security/limits.conf" "grid soft nofile 1024
$grid_user hard nofile 65536
$grid_user soft stack 10240
$grid_user hard stack 32768
$grid_user soft nproc 16384
$grid_user hard nproc 16384"
  fi
  # 记录 /etc/security/limits.conf 文件的输出到日志中
  color_printf blue "查看 /etc/security/limits.conf："
  grep -v "^\s*\(#\|$\)" /etc/security/limits.conf
  # 备份 /etc/pam.d/login 文件
  backup_restore_file /etc/pam.d/login
  # 在 /etc/pam.d/login 文件末尾添加 Oracle 的配置
  write_file "N" "/etc/pam.d/login" "# OracleBegin
session required pam_limits.so
# OracleEnd"
  # 记录 /etc/pam.d/login 文件的输出到日志中
  echo
  color_printf blue "查看 /etc/pam.d/login 文件："
  grep -v "^\s*\(#\|$\)" /etc/pam.d/login
}
#==============================================================#
#                         配置 /dev/shm                        #
#==============================================================#
function conf_shm() {
  log_print "配置 /dev/shm"
  local shm_total
  shm_total=$(df -k /dev/shm | awk 'NR==2 {print $2}')
  # 检查是否将 /dev/shm 添加到了 /etc/fstab 文件中
  if ! grep -qE "/dev/shm" /etc/fstab; then
    # 如果没有添加，则将其添加进去
    backup_restore_file /etc/fstab
    write_file "N" "/etc/fstab" "# OracleBegin
tmpfs /dev/shm tmpfs size=${os_memory_total}k 0 0"
  elif ((shm_total < os_memory_total)); then
    # 如果已经添加了 /dev/shm，检查共享内存总大小是否小于操作系统内存总量
    # 如果共享内存总大小小于操作系统内存总量，则将其设置为相同的值
    backup_restore_file /etc/fstab
    sed -i "/\/dev\/shm/d" /etc/fstab
    write_file "N" "/etc/fstab" "# OracleBegin
tmpfs /dev/shm tmpfs size=${os_memory_total}k 0 0"
  fi
  # 重新挂载 /dev/shm
  mount -o remount /dev/shm
  color_printf blue "查看 Linux 挂载情况：/etc/fstab"
  grep -v "^\s*\(#\|$\)" /etc/fstab
}
#==============================================================#
#                       安装 rlwrap 插件                        #
#==============================================================#
function install_rlwrap() {
  # 如果压缩包存在则开始安装 rlwrap
  log_print "安装 rlwrap 插件"
  # 创建并进入目录
  /bin/mkdir -p "$software_dir"/rlwrap && cd "$software_dir"/rlwrap || return 1
  # 解压缩文件
  tar -xf "$software_dir"/rlwrap-*.gz --strip-components 1 -C "$software_dir"/rlwrap
  # 配置、编译和安装软件，并将日志重定向到/dev/null以避免输出干扰
  (./configure -q && make -s && make install -s prefix=/usr/local libdir=/usr/local/libexec) >/dev/null 2>&1
  # 返回 /soft 目录
  cd ..
  # 删除不必要的文件夹和文件
  rm_file "$software_dir/rlwrap"
  # 检查 rlwrap 是否已成功安装
  if type rlwrap >/dev/null 2>&1; then
    # 如果已成功安装，则输出信息
    color_printf green "成功安装 rlwrap：" "$(rlwrap -v)"
  else
    # 如果未成功安装，则输出错误信息
    color_printf yellow "未能成功安装 rlwrap，请检查安装日志。"
  fi
}
#==============================================================#
#                         配置 profile                          #
#==============================================================#
function conf_profile() {
  local oracle_sids grid_sid
  log_print "Root 用户环境变量"
  # 配置 root 用户环境变量
  backup_restore_file /root/"$profile_name"
  write_file "N" "/root/$profile_name" "# OracleBegin
alias so='su - $oracle_user'
export PS1="[\`whoami\`@\`hostname\`:"'\$PWD]# '
alias bdf='df -Th'
alias syslog='vi /var/log/messages'"
  # RAC 模式增加集群相关
  if [[ $oracle_install_mode =~ ^(rac|standalone)$ ]]; then
    write_file "N" "/root/$profile_name" "alias sg='su - $grid_user'
alias crsctl='$env_grid_home/bin/crsctl'
alias srvctl='$env_grid_home/bin/srvctl'"
  fi
  color_printf blue "查看 root 用户环境变量：/root/$profile_name"
  grep -v "^\s*\(#\|$\)" /root/"$profile_name"
  # 获取 ASM 实例名称
  if [[ $oracle_install_mode == "rac" ]]; then
    grid_sid=+ASM$node_num
  elif [[ $oracle_install_mode == "standalone" ]]; then
    grid_sid=+ASM
  fi
  # 获取 DB 实例名
  for name in "${db_names[@]}"; do
    if [[ "$oracle_install_mode" =~ ^(single|standalone)$ ]]; then
      oracle_sids+=("$name" "$name")
    else
      # 将数组元素与对应索引的 oracle_sids 元素连接，并保存到新数组中
      oracle_sids+=("$name" "${name}$node_num")
    fi
  done
  adapt_oracle_support() {
    local profile_user=$1
    if [[ "$cpu_type" == "aarch64" ]]; then
      write_file "N" "/home/$profile_user/$profile_name" "export CV_ASSUME_DISTID=OL8"
    else
      case "$os_version" in
      7)
        if [[ "$oracle_os_flag" == "N" ]]; then
          write_file "N" "/home/$profile_user/$profile_name" "export CV_ASSUME_DISTID=OL7"
        fi
        ;;
      8 | 9 | 10)
        if ((db_version >= 23)); then
          write_file "N" "/home/$profile_user/$profile_name" "export CV_ASSUME_DISTID=OL8"
        else
          write_file "N" "/home/$profile_user/$profile_name" "export CV_ASSUME_DISTID=OL7"
        fi
        ;;
      esac
    fi
  }
  for ((i = 0; i < ${#oracle_sids[@]}; i += 2)); do
    # 配置 oracle 用户环境变量
    log_print "$oracle_user 用户环境变量，实例名：${oracle_sids[i + 1]}"
    backup_restore_file /home/$oracle_user/"$profile_name"
    write_file "N" "/home/$oracle_user/$profile_name" "# OracleBegin
umask 022
export TMP=/tmp
export TMPDIR=\$TMP
export NLS_LANG=AMERICAN_AMERICA.$db_characterset
export ORACLE_BASE=$env_oracle_base
export ORACLE_HOME=$env_oracle_home
export ORACLE_TERM=xterm
export TNS_ADMIN=\$ORACLE_HOME/network/admin
export ORACLE_SID=${oracle_sids[i + 1]}
export PATH=/usr/sbin:\$PATH
export PATH=\$ORACLE_HOME/bin:\$ORACLE_HOME/OPatch:\$ORACLE_HOME/perl/bin:\$PATH
export PERL5LIB=\$ORACLE_HOME/perl/lib
alias sas='sqlplus / as sysdba'
alias awr='sqlplus / as sysdba @?/rdbms/admin/awrrpt'
alias ash='sqlplus / as sysdba @?/rdbms/admin/ashrpt'
alias alert='vi \$ORACLE_BASE/diag/rdbms/*/\$ORACLE_SID/trace/alert_\$ORACLE_SID.log'
export PS1=\"[\`whoami\`@\`hostname\`:\"'\$PWD]\$ '
alias bdf='df -Th'
alias acd='cd \$ORACLE_BASE/diag/rdbms/*/\$ORACLE_SID/trace'
alias dblog='tail -200f \$ORACLE_BASE/diag/rdbms/*/\$ORACLE_SID/trace/alert_\$ORACLE_SID.log'"
    adapt_oracle_support "$oracle_user"
    if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
      export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib:$HOME/lib:/lib/x86_64-linux-gnu
    else
      export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib
    fi
    # 检查 rlwrap 是否已经安装，并显示无误信息
    if type rlwrap >/dev/null 2>&1; then
      write_file "N" "/home/$oracle_user/$profile_name" "alias sqlplus='rlwrap sqlplus'
alias rman='rlwrap rman'
alias adrci='rlwrap adrci'"
    fi
    # sles 授予目录权限
    if [[ "$os_type" == "sles" ]]; then
      chown -R $oracle_user:oinstall /home/$oracle_user/
    fi
    color_printf blue "查看 $oracle_user 用户环境变量：/home/$oracle_user/$profile_name"
    grep -v "^\s*\(#\|$\)" /home/$oracle_user/"$profile_name"
    # 创建一个与实例名同名的环境变量
    /bin/cp -f /home/$oracle_user/"$profile_name" /home/$oracle_user/."${oracle_sids[i]}"
    chown -R $oracle_user:oinstall "/home/$oracle_user/"
  done
  # grid
  if [[ $oracle_install_mode =~ ^(rac|standalone)$ ]]; then
    log_print "$grid_user 用户环境变量"
    backup_restore_file /home/$grid_user/"$profile_name"
    write_file "N" "/home/$grid_user/$profile_name" "# OracleBegin
umask 022
export TMP=/tmp
export TMPDIR=\$TMP
export NLS_LANG=AMERICAN_AMERICA.$db_characterset
export ORACLE_BASE=$env_grid_base
export ORACLE_HOME=$env_grid_home
export ORACLE_TERM=xterm
export TNS_ADMIN=\$ORACLE_HOME/network/admin
export ORACLE_SID=$grid_sid
export PATH=/usr/sbin:\$PATH
export PATH=\$ORACLE_HOME/bin:\$ORACLE_HOME/OPatch:\$PATH
alias sas='sqlplus / as sysasm'
alias bdf='df -Th'
export PS1=\"[\`whoami\`@\`hostname\`:\"'\$PWD]\$ '"
    adapt_oracle_support "$grid_user"
    if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
      export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib:$HOME/lib:/lib/x86_64-linux-gnu
    else
      export LD_LIBRARY_PATH=\$ORACLE_HOME/lib:/lib:/usr/lib
    fi
    # 检查 rlwrap 是否已经安装，并显示无误信息
    if type rlwrap >/dev/null 2>&1; then
      write_file "N" "/home/$grid_user/$profile_name" "alias sqlplus='rlwrap sqlplus'
alias adrci='rlwrap adrci'"
    fi
    # 19c rac 大于 2 节点修复 BUG
    local node_count=${#rac_public_ips[@]}
    if ((db_version = 19 && node_count > 2)); then
      write_file "N" "/home/$grid_user/$profile_name" "export SRVM_DISABLE_MTTRANS=true"
    fi
    # sles 授予目录权限
    if [[ "$os_type" == "sles" ]]; then
      chown -R $grid_user:oinstall /home/$grid_user/
    fi
    # rh9 系安装 RAC 创建监听失败
    if ((os_version >= 8 && gi_version == 11)); then
      if check_file /etc/profile.d/which2.sh; then
        write_file "N" "/home/$grid_user/$profile_name" "unset -f \$(env | grep BASH_FUNC | sed 's/BASH_FUNC_\([^%]*\).*/\1/')"
      fi
    fi
    color_printf blue "查看 $grid_user 用户环境变量：/home/$grid_user/$profile_name"
    grep -v "^\s*\(#\|$\)" /home/$grid_user/"$profile_name"
    chown -R $grid_user:oinstall "/home/$grid_user/"
  fi
}
#==============================================================#
#                       配置 ntp timeserver                     #
#==============================================================#
# 定义函数：配置 ntp 服务
function conf_ntp() {
  case "$os_version" in
  6 | 7)
    # 备份 ntp 配置文件和 sysconfig 配置文件
    backup_restore_file /etc/ntp.conf
    backup_restore_file /etc/sysconfig/ntpd
    write_file "N" "/etc/ntp.conf" "# OracleBegin
tos maxdist 30
tinker panic 0"
    # 删除 ntp 配置文件中已有的时间服务器信息，并添加新的时间服务器信息
    sed -i '/^server/d' /etc/ntp.conf
    write_file "N" "/etc/ntp.conf" "server $timeserver_ip iburst"
    # 创建 ntpd 进程ID文件
    touch /var/run/ntpd.pid
    # 编辑 sysconfig 文件来配置 ntpd 服务
    write_file "Y" "/etc/sysconfig/ntpd" "# OracleBegin
OPTIONS=\"-g -x -p /var/run/ntpd.pid\"
SYNC_HWCLOCK=yes"
    ;;
  *)
    # 备份 chrony 配置文件
    backup_restore_file /etc/chrony.conf
    # 删除 ntp 配置文件中已有的时间服务器信息，并添加新的时间服务器信息
    sed -i '/^server/d' /etc/chrony.conf
    write_file "N" "/etc/chrony.conf" "# OracleBegin
server $timeserver_ip iburst"
    ;;
  esac
}
#==============================================================#
#                         配置时间同步                           #
#==============================================================#
function conf_timesync() {
  log_print "配置时间同步"
  # 如果存在时间服务器 IP，则配置 NTP/chrony 服务
  if [[ $timeserver_ip ]]; then
    case "$os_version" in
    6)
      install_package "ntp"
      # 启动和开机启动 ntpd 服务
      service ntpd start
      chkconfig ntpd on
      # 配置 ntp
      conf_ntp
      # 重启 ntpd 服务，并检查其状态及时间同步情况
      service ntpd restart
      # 记录时间同步后的日期和时间
      ntpstat
      echo
      ntpq -p -n
      ;;
    7)
      # 关闭并禁用 chrony 服务，备份 chrony 配置文件
      install_package "ntp" "chrony"
      systemctl disable chronyd.service
      if systemctl is-active --quiet chronyd.service; then
        systemctl stop chronyd.service
        mv_file /etc/chrony.conf
      fi
      # 启动和开机启动 ntpd 服务
      systemctl start ntpd.service
      systemctl enable ntpd.service
      # 配置 ntp
      conf_ntp
      # 重启 ntpd 服务，并检查其状态及时间同步情况
      systemctl restart ntpd.service
      # 记录时间同步后的日期和时间
      ntpstat
      echo
      ntpq -p -n
      ;;
    *)
      # 关闭并禁用 ntpd 服务，备份 ntpd 配置文件
      systemctl disable ntpd.service
      install_package "ntp" "chrony"
      if systemctl is-active --quiet ntpd.service; then
        systemctl stop ntpd.service
        mv_file /etc/ntpd.conf
      fi
      # 启动和开机启动 chronyd 服务
      systemctl start chronyd.service
      systemctl enable chronyd.service
      # 配置 ntp
      conf_ntp
      # 重启 chrony 服务，并检查其状态及时间同步情况
      systemctl restart chronyd.service
      chronyc tracking
      echo
      chronyc sources -v
      ;;
    esac
  fi
}
#==============================================================#
#                        配置 DNS 解析                          #
#==============================================================#
function conf_dns() {
  # 记录日志
  log_print "配置 DNS 解析"
  # 检查是否已安装 bind，如果未安装则安装相关软件包
  if ! rpm -q bind >/dev/null; then
    install_package "bind-libs" "bind" "bind-utils"
  fi
  # 配置 DNS 文件
  write_file "Y" "/etc/resolv.conf" "search $dns_name  
nameserver $dns_ip
options rotate
options timeout:2
options attempts:5"
  # 检查 DNS 解析是否可用
  if nslookup "$scan_name"."$dns_name"; then
    # 如果解析成功，则输出提示信息
    color_printf green "DNS 配置成功！域名解析正常！"
  else
    # 如果解析失败，则输出错误信息
    color_printf yellow "DNS 配置成功！但域名无法正常解析，请检查网络连接或者 DNS 设置！"
  fi
}
#==============================================================#
#                    Configure Oracle ASM                      #
#==============================================================#
# 配置asm磁盘
function conf_asmdisk() {
  local uuid=$1 symlink=$2 udev_rule
  if [[ $multipath == "Y" ]]; then
    # 多路径udev绑盘
    udev_rule="KERNEL==\"dm-*\",ENV{DM_UUID}==\"$uuid\",SYMLINK+=\"$symlink\",OWNER=\"grid\",GROUP=\"asmadmin\",MODE=\"0660\""
  else
    # 没有多路径udev绑盘,版本不同，scsi_id 路径不同
    if ((os_version == 6)); then
      udev_rule="SUBSYSTEM==\"block\", PROGRAM==\"/sbin/scsi_id -g -u -d /dev/\$name\", RESULT==\"$uuid\", SYMLINK+=\"$symlink\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""
    else
      udev_rule="SUBSYSTEM==\"block\", PROGRAM==\"/usr/lib/udev/scsi_id -g -u -d /dev/\$name\", RESULT==\"$uuid\", SYMLINK+=\"$symlink\", OWNER=\"grid\", GROUP=\"asmadmin\", MODE=\"0660\""
    fi
  fi
  # 写入udev规则文件
  write_file "N" "/etc/udev/rules.d/99-oracle-asmdevices.rules" "$udev_rule"
}
#==============================================================#
#                         配置 asm disk                         #
#==============================================================#
function conf_asm() {
  # 如果 udev 规则文件存在则删除
  rm_file /etc/udev/rules.d/99-oracle-asmdevices.rules
  # 配置多路径
  if [[ $multipath == "Y" ]]; then
    if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
      install_package "multipath-tools" "multipath-tools-boot"
    elif [[ "$os_type" == "openEuler" ]]; then
      install_package "multipath-tools"
    else
      install_package "device-mapper-multipath"
    fi
    log_print "配置 multipath 多路径和 UDEV 绑盘" >>"$oracleinstalllog"
    # 启用多路径
    mpathconf --enable --with_multipathd y >/dev/null 2>&1
    # 配置多路径开机自启和获取根目录磁盘
    case "$os_version" in
    "6")
      chkconfig multipathd.service on >/dev/null 2>&1
      ;;
    *)
      systemctl enable multipathd.service >/dev/null 2>&1
      ;;
    esac
    backup_restore_file /etc/multipath.conf
    # 配置 multipath.conf
    write_file "Y" "/etc/multipath.conf" "# OracleBegin
defaults {
  user_friendly_names yes
}

blacklist {
  devnode \"^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*\"
  devnode \"^asm/*\"
  devnode \"ofsctl\"
}

multipaths {"
  fi
  # 将磁盘 WWID 和磁盘组名称存放在关联数组变量中
  declare -A DISK_INFOS=(
    ["ocr"]="$ocr_disk_wwid"
    ["data"]="$data_disk_wwid"
    ["arch"]="$arch_disk_wwid"
  )
  # 循环ASM磁盘信息数组
  for NAME in "${!DISK_INFOS[@]}"; do
    # 获取当前磁盘组中的磁盘 WWID 列表
    local WWID_LIST=${DISK_INFOS[$NAME]}
    # 定义一个间接变量用于存放asm磁盘路径，用逗号拼接
    local asm_disks="${NAME}disk"
    # 当前磁盘组存在 WWID 时解析
    if [[ -n $WWID_LIST ]]; then
      # 将逗号分隔的 WWID 转换成 WWID 数组
      IFS=',' read -ra WWIDS <<<"$WWID_LIST"
      # 遍历 WWID 数组，为每个 WWID 添加别名
      for ((i = 0; i < ${#WWIDS[@]}; i++)); do
        # 获取当前循环的 WWID 值
        local WID="${WWIDS[i]}"
        # 根据当前索引计算出别名编号
        local NUM
        ((NUM = i + 1))
        local ALIAS=asm_${NAME}_$NUM
        local WWID=$WID
        # 需要配置多路径时，写入多路径配置文件
        if [[ $multipath == "Y" ]]; then
          # 构造磁盘管理器使用的 WWID 和别名
          WWID=mpath-$WID
          # 将当前磁盘的 WWID 和别名写入 multipath.conf
          write_file "N" "/etc/multipath.conf" "multipath {
wwid $WID
alias $ALIAS
}"
        fi
        local ALIAS_STR=/dev/$ALIAS
        # 针对 udev 的规则配置 ASM 磁盘
        conf_asmdisk "$WWID" "$ALIAS"
        # 拼接 asm 磁盘组磁盘路径
        eval "${asm_disks}=\"\${${asm_disks}}${ALIAS_STR},\""
      done
    fi
    # 去掉最后一个逗号
    eval "${asm_disks}=\${${asm_disks}%?}"
  done
  if [[ $multipath == "Y" ]]; then
    write_file "N" "/etc/multipath.conf" "}"
    # 解决 VirtualBox 的一个 bug
    if [[ $virtualbox =~ ^[yY] ]]; then
      sed -i 's/1ATA_//' /etc/multipath.conf
      sed -i 's/1ATA_//' /etc/udev/rules.d/99-oracle-asmdevices.rules
    fi
    # 启用及查看多路径服务状态
    case "$os_version" in
    "6")
      service multipathd restart >/dev/null 2>&1
      ;;
    *)
      systemctl restart multipathd >/dev/null 2>&1
      ;;
    esac
    color_printf blue "检查 Mulltipath 多路径情况：" >>"$oracleinstalllog"
    while true; do
      if multipath -ll >>"$oracleinstalllog" 2>&1; then
        break
      fi
      # 睡眠 5s，防止 multipath 服务重启慢问题
      sleep 5s
    done
  fi
  # 打印 UDEV 配置信息
  {
    echo
    color_printf blue "UDEV 配置信息："
    cat /etc/udev/rules.d/99-oracle-asmdevices.rules
    echo
  } >>"$oracleinstalllog"
  # 启动 UDEV
  while true; do
    if ((os_version == 6)); then
      # 在 CentOS 6 上启动 UDEV 服务
      start_udev >/dev/null 2>&1
    else
      # 在 CentOS 7/8/9 上启动 UDEV 服务
      # 重新加载 udev 规则
      udevadm control --reload-rules >/dev/null 2>&1
      # 触发设备变化事件
      udevadm trigger --type=devices --action=change >/dev/null 2>&1
    fi
    # 睡眠 5s，防止 udev 加载慢问题
    sleep 5s
    if [[ $(find /dev -name "asm*" 2>/dev/null) ]]; then
      {
        color_printf blue "检查 UDEV 绑定磁盘情况："
        ls -lcm /dev/asm_*
        echo
        color_printf blue "UDEV 配置完成！"
      } >>"$oracleinstalllog"
      break
    fi
  done
}
#==============================================================#
#                         配置其他节点                           #
#==============================================================#
function other_node_shell() {
  # 发送脚本和安装程序到其他节点
  for ip in "${rac_public_ips[@]:1}"; do
    log_print "配置 RAC 节点：$ip" ""
    color_printf blue "正在节点：$ip 上执行脚本："
    ssh -t -q "$ip" "cd $software_dir && sh racnode.sh"
    color_printf blue "配置 RAC 节点：$ip 结束！"
  done
}
#==============================================================#
#                         配置 SSH 互信                         #
#==============================================================#
function rac_ssh() {
  # 定义用户列表
  local users=("$grid_user" "$oracle_user")
  # 导出函数以供其他进程使用
  export -f ssh_trust
  # 对于每个用户
  for user in "${users[@]}"; do
    # 如果尚未配置 ssh 互信，则开始处理
    if [[ $(ssh_check "$user" "${hosts_array[@]}") == "false" ]]; then
      # 输出正在配置哪个用户的SSH互信
      log_print "配置 ${user^^} 用户 SSH 互信"
      case $user in
      "$grid_user")
        # 配置 Oracle Grid Infrastructure 的互信
        su $grid_user -c "ssh_trust $grid_user $grid_passwd ${hosts_array[*]}"
        ;;
      "$oracle_user")
        # 配置 Oracle Database 软件的互信
        su $oracle_user -c "ssh_trust $oracle_user $oracle_passwd ${hosts_array[*]}"
        ;;
      esac
      # 互信完成后检查互信是否成功
      if [[ $(ssh_check "$user" "${hosts_array[@]}") == "false" ]]; then
        color_printf red "$user 用户互信失败，请检查原因！"
      fi
    fi
  done
}
#==============================================================#
#                        解压 Grid 软件包                        #
#==============================================================#
function unzip_gridsoft() {
  # 执行日志输出函数
  log_print "静默解压缩 Grid 软件包"
  # 修改软件目录的所有者和所属组为GRID
  chown -R $grid_user:oinstall "$software_dir"
  color_printf blue "正在静默解压缩 Grid 软件包，请稍等："
  # 解压缩 Grid 安装包
  if ((gi_version == 11)); then
    # 如果 Grid 软件目录不存在，则解压缩 Grid 安装包到指定目录中
    if ! check_file "$software_dir"/grid; then
      cascade_del_file "$software_dir/grid"
    fi
    color_printf green "静默解压 Grid 软件安装包： $grid_soft_name"
    run_as_grid "unzip -oq \"$grid_soft_name\" -d \"$software_dir\""
  else
    echo
    color_printf green "静默解压 Grid 软件安装包： $grid_soft_name"
    run_as_grid "unzip -oq \"$grid_soft_name\" -d \"$env_grid_home\""
  fi
  # 修改 Kylin 10 安装 11GR2/12CR2 报错 unzip 问题，Grid 内置 unzip 版本太低
  if [[ "$os_type" == "kylin" ]]; then
    if ((gi_version == 11)); then
      /bin/mv -f "$software_dir"/grid/install/unzip "$software_dir"/grid/install/unzipbak
      /bin/cp -f /usr/bin/unzip "$software_dir"/grid/install/unzip
    elif ((gi_version == 12)); then
      /bin/mv -f "$env_grid_home"/bin/unzip "$env_grid_home"/bin/unzipbak
      /bin/cp -f /usr/bin/unzip "$env_grid_home"/bin/unzip
    fi
  fi
  # 解压缩 Grid 补丁包
  if [[ $grid_patch ]]; then
    # 解压缩 opatch，11G 需要在 Grid 软件被安装后解压缩
    if [[ "$gi_version" != "11" ]]; then
      if check_file "$grid_opatch_name"; then
        echo
        color_printf green "静默解压 OPatch 软件补丁包： $grid_opatch_name"
        run_as_grid "unzip -oq \"$grid_opatch_name\" -d \"$env_grid_home\""
      fi
    fi
    # 如果 Grid 补丁目录不存在，则解压缩 Grid 补丁包到指定目录中
    if ! check_file "$software_dir"/"$grid_patch"; then
      echo
      color_printf green "静默解压 Grid 软件补丁包： $grid_patch_name"
      run_as_grid "unzip -oq \"$grid_patch_name\" -d \"$software_dir\""

      # 拷贝 gi opatch/patch 到其他节点
      if [[ "$gi_version" =~ ^(11|12)$ ]]; then
        for ip in "${rac_public_ips[@]:1}"; do
          # 将 Grid 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组
          scp -q "$grid_patch_name" "$ip":"$software_dir"
          ssh -q "$ip" "chown -R $grid_user:oinstall \"$software_dir\" && su - $grid_user -c \"unzip -oq '$grid_patch_name' -d '$software_dir'\""
        done
      fi
    fi
  fi
  # 安装 cvuqdisk
  if ! type cvuqdisk >/dev/null 2>&1; then
    # 安装 cvuqdisk，并将安装文件拷贝到其他节点指定的目录下，然后在其他节点上执行安装
    if check_file "$cvuqdisk"; then
      echo
      color_printf green "静默安装 cvu 软件：$cvu_name"
      echo
      if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
        rpm2cpio "$cvuqdisk" | cpio -idmv >/dev/null 2>&1
        /bin/mv -f "$software_dir"/usr/sbin/cvuqdisk /usr/sbin/
        chown root:oinstall /usr/sbin/cvuqdisk
        chmod 4755 /usr/sbin/cvuqdisk
      else
        rpm -Uvh --quiet "$cvuqdisk" >/dev/null 2>&1
      fi
      for ip in "${rac_public_ips[@]:1}"; do
        scp -q "$cvuqdisk" "$ip":"$software_dir"
        if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
          ssh -q "$ip" "cd $software_dir && rpm2cpio $software_dir/$cvu_name | cpio -idmv" >/dev/null 2>&1
          ssh -q "$ip" "/bin/mv -f $software_dir/usr/sbin/cvuqdisk /usr/sbin/"
          ssh -q "$ip" "chown root:oinstall /usr/sbin/cvuqdisk"
          ssh -q "$ip" "chmod 4755 /usr/sbin/cvuqdisk"
        else
          ssh -q "$ip" "rpm -Uvh --quiet $software_dir/$cvu_name" >/dev/null 2>&1
        fi
        ssh -q "$ip" "/bin/rm -rf $software_dir/$cvu_name"
      done
    fi
  fi
}
#==============================================================#
#                       配置 grid 静默文件                       #
#==============================================================#
function conf_gridrsp() {
  log_print "Grid 安装静默文件"
  # rac 和 standalone 选项赋值
  case "$oracle_install_mode" in
  rac)
    local gridrsp_array=(
      "INVENTORY_LOCATION=$env_oracle_inven"
      "oracle.install.option=CRS_CONFIG"
      "ORACLE_BASE=$env_grid_base"
      "oracle.install.asm.OSDBA=asmdba"
      "oracle.install.asm.OSOPER=asmoper"
      "oracle.install.asm.OSASM=asmadmin"
      "oracle.install.crs.config.gpnp.scanName=$scan_name"
      "oracle.install.crs.config.gpnp.scanPort=1521"
      "oracle.install.crs.config.clusterName=$cluster_name"
      "oracle.install.crs.config.gpnp.configureGNS=false"
      "oracle.install.crs.config.clusterNodes=$clusternodes"
      "oracle.install.crs.config.networkInterfaceList=$networkinterfacelist"
      "oracle.install.crs.config.useIPMI=false"
      "oracle.install.asm.SYSASMPassword=$database_passwd"
      "oracle.install.asm.diskGroup.name=$ocr_asm_group"
      "oracle.install.asm.diskGroup.redundancy=$ocr_redun"
      "oracle.install.asm.diskGroup.disks=$ocrdisk"
      "oracle.install.asm.diskGroup.diskDiscoveryString=$asmdisk_string"
      "oracle.install.asm.monitorPassword=$database_passwd"
    )
    ;;
  standalone)
    gridrsp_array=(
      "INVENTORY_LOCATION=$env_oracle_inven"
      "oracle.install.option=HA_CONFIG"
      "ORACLE_BASE=$env_grid_base"
      "oracle.install.asm.OSDBA=asmdba"
      "oracle.install.asm.OSOPER=asmoper"
      "oracle.install.asm.OSASM=asmadmin"
      "oracle.install.crs.config.gpnp.configureGNS=false"
      "oracle.install.crs.config.useIPMI=false"
      "oracle.install.asm.SYSASMPassword=$database_passwd"
      "oracle.install.asm.diskGroup.name=$data_asm_group"
      "oracle.install.asm.diskGroup.redundancy=$data_redun"
      "oracle.install.asm.diskGroup.disks=$datadisk"
      "oracle.install.asm.diskGroup.diskDiscoveryString=$asmdisk_string"
      "oracle.install.asm.monitorPassword=$database_passwd"
    )
    ;;
  esac
  # 根据不同的版本向grid.rsp文件追加配置
  case "$gi_version" in
  "11")
    gridrsp_array+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v11_2_0"
      "SELECTED_LANGUAGES=en"
      "ORACLE_HOME=$env_grid_home"
      "oracle.install.crs.config.storageOption=ASM_STORAGE"
      "oracle.install.asm.diskGroup.AUSize=$ausize"
      "oracle.installer.autoupdates.option=SKIP_UPDATES"
    )
    ;;
  "12" | "19" | "21" | "23")
    gridrsp_array+=(
      "oracle.install.crs.config.ClusterConfiguration=STANDALONE"
      "oracle.install.crs.config.configureAsExtendedCluster=false"
      "oracle.install.asm.storageOption=ASM"
      "oracle.install.asm.diskGroup.AUSize=$ausize"
      "oracle.install.asm.configureAFD=$afd"
      "oracle.install.crs.config.ignoreDownNodes=false"
      "oracle.install.config.managementOption=NONE"
      "oracle.install.crs.rootconfig.executeRootScript=false"
    )
    case "$gi_version" in
    "12")
      gridrsp_array+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v12.2.0")
      # 针对 RAC，12CR2 GI 基础版默认安装 GIMR，如果 OCR 大于 50G 则 gimr 为 true 不设置参数，默认安装 GIMR；否则代表已经安装补丁，可以设置参数为 false
      if [[ $oracle_install_mode == "rac" ]]; then
        if [[ $gimr == "false" ]]; then
          gridrsp_array+=("oracle.install.crs.configureGIMR=false")
        fi
      fi
      ;;
    "19")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v19.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
        "oracle.install.crs.configureGIMR=false"
      )
      ;;
    "21")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v21.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
        "oracle.install.crs.configureGIMR=false"
      )
      ;;
    "23")
      gridrsp_array+=(
        "oracle.install.responseFileVersion=/oracle/install/rspfmt_crsinstall_response_schema_v23.0.0"
        "oracle.install.crs.config.scanType=LOCAL_SCAN"
        "oracle.install.crs.configureGIMR=false"
      )
      ;;
    esac
    ;;
  esac
  rm_file "$software_dir/grid.rsp"
  printf '%s\n' "${gridrsp_array[@]}" >>"$software_dir"/grid.rsp
  # 记录grid.rsp文件内容到日志中
  cat "$software_dir"/grid.rsp
}
#==============================================================#
#                      获取安装 grid 命令                        #
#==============================================================#
function get_gridinstall_cmd() {
  log_print "静默安装 Grid 软件命令"
  case "$gi_version" in
  "11")
    gridinstall_cmd=$(echo -e "$software_dir/grid/runInstaller \\
-silent \\
-showProgress \\
-ignoreSysPrereqs \\
-ignorePrereq \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp")
    ;;
  "12" | "19" | "21" | "23")
    if ((gi_version == 12)); then
      # [INS-42505] The installer has detected that the Oracle Grid Infrastructure home software at (/oracle/GRID/12201) is not complete. (Doc ID 2697235.1)
      if ! check_file "$env_grid_home"/install/files.lst.original; then
        /bin/mv -f "$env_grid_home"/install/files.lst "$env_grid_home"/install/files.lst.original
      fi
    fi
    if [[ -z "$grid_patch" ]]; then
      gridinstall_cmd=$(echo -e "$env_grid_home/gridSetup.sh \\
-silent \\
-skipPrereqs \\
-ignorePrereqFailure \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp")
    else
      case "$gi_version" in
      "12")
        local patch_str="-applyPSU $software_dir/$grid_patch"
        ;;
      "19" | "21" | "23")
        patch_str="-applyRU $software_dir/$grid_patch"
        ;;
      esac
      gridinstall_cmd=$(echo -e "$env_grid_home/gridSetup.sh \\
-silent \\
-skipPrereqs \\
-ignorePrereqFailure \\
-waitForCompletion \\
-responseFile $software_dir/grid.rsp \\
$patch_str")
    fi
    ;;
  esac
  color_printf blue "$gridinstall_cmd"
}
#==============================================================#
#                        检查 OPatch 版本                       #
#==============================================================#
function check_opatch_version() {
  local opatch_path=$1/OPatch/opatch
  $opatch_path version
}
#==============================================================#
#                         安装 Grid 软件                        #
#==============================================================#
function install_gridsoft() {
  # 配置 grid 静默安装文件
  conf_gridrsp
  # 获取安装 grid 命令
  get_gridinstall_cmd
  # 修改软件目录的所有者和所属组为 grid
  chown -R $grid_user:oinstall "$software_dir"
  # 打印日志
  log_print "静默安装 Grid 软件"
  if [[ "$db_version" != "11" ]]; then
    color_printf blue "检查 Grid 软件 OPacth 版本："
    check_opatch_version "$env_grid_home"
    echo
  fi
  color_printf blue "正在安装 Grid 软件："
  # 安装 Grid 软件
  run_as_grid "$gridinstall_cmd"
  # Grid 软件安装后步骤
  after_grid_install "$@"
  # 打印日志
  log_print "Grid 软件版本"
  color_printf blue "查看 Grid 软件版本：sqlplus -V"
  run_as_grid "sqlplus -V"
  log_print "Grid 补丁信息"
  color_printf blue "查看 Grid 补丁信息：opatch lspatches"
  run_as_grid "opatch lspatches"
  log_print "Grid 资源检查"
  color_printf blue "查看 Grid 集群情况：crsctl stat res -t"
  run_as_grid "crsctl stat res -t"
}
#==============================================================#
#                      执行 root.sh 脚本                        #
#==============================================================#
# 执行 root.sh 脚本
function exec_root() {
  local root_path=$1
  log_print "执行 root 脚本"
  if [[ "$oracle_install_mode" == "rac" ]]; then
    color_printf blue "节点 $local_ip ："
  fi
  # 执行 orainstRoot.sh 脚本，不论 grid/oracle 软件安装都执行
  if check_file "$env_oracle_inven"/orainstRoot.sh; then
    color_printf blue "执行命令：$env_oracle_inven/orainstRoot.sh"
    "$env_oracle_inven"/orainstRoot.sh
  fi
  if check_file "$root_path"/root.sh; then
    echo
    color_printf blue "执行命令：$root_path/root.sh"
    "$root_path"/root.sh
  fi
  # 仅 rac 模式执行
  if [[ "$oracle_install_mode" == "rac" ]]; then
    for ip in "${rac_public_ips[@]:1}"; do
      echo
      color_printf blue "节点 $ip ："
      color_printf blue "执行命令：$env_oracle_inven/orainstRoot.sh"
      ssh -q "$ip" "$env_oracle_inven"/orainstRoot.sh
      echo
      color_printf blue "执行命令：$root_path/root.sh"
      ssh -q "$ip" "$root_path"/root.sh
    done
  fi
}
#==============================================================#
#                      安装 Grid 软件后操作                      #
#==============================================================#
function after_grid_install() {
  case "$gi_version" in
  "11")
    # Grid patch 18370031 补丁安装，无需 OPatch 补丁，修复执行 root.sh 脚本报错 ohas 服务问题
    if ((os_version >= 7)); then
      log_print "静默安装 18370031 补丁"
      if [[ "$oracle_install_mode" == "rac" ]]; then
        color_printf blue "节点 $local_ip ："
      fi
      run_as_grid "unzip -oq $software_dir/p18370031_112040_Linux-x86-64.zip -d $software_dir"
      run_as_grid "$env_grid_home/OPatch/opatch napply -oh $env_grid_home -local $software_dir/18370031 -silent"
      for ip in "${rac_public_ips[@]:1}"; do
        # 将 Grid 补丁包和 OPatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组，执行安装
        echo
        color_printf blue "节点 $ip ："
        scp -q -r "$software_dir"/p18370031_112040_Linux-x86-64.zip "$ip":"$software_dir"
        ssh -q "$ip" "chown -R $grid_user:oinstall $software_dir"
        run_as_grid "ssh -q $ip unzip -oq $software_dir/p18370031_112040_Linux-x86-64.zip -d $software_dir"
        run_as_grid "ssh -q $ip $env_grid_home/OPatch/opatch napply -oh $env_grid_home -local $software_dir/18370031 -silent"
      done
    fi
    # 执行 root 脚本
    exec_root "$env_grid_home"
    # 执行 configToolAllCommands 完成 Grid 基础配置
    if ! check_file "$env_grid_home"/cfgtoollogs/configToolAllCommands; then
      run_as_grid "$env_grid_home/oui/bin/runConfig.sh ORACLE_HOME=$env_grid_home MODE=perform ACTION=configure RERUN=true $*" >/dev/null 2>&1
    fi
    # 添加 asm 账户密码信息到 cfgrsp.properties 文件中
    write_file "N" "/home/$grid_user/cfgrsp.properties" "oracle.assistants.asm|S_ASMPASSWORD=$database_passwd
oracle.assistants.asm|S_ASMMONITORPASSWORD=$database_passwd"
    run_as_grid "$env_grid_home/cfgtoollogs/configToolAllCommands RESPONSE_FILE=/home/$grid_user/cfgrsp.properties" >/dev/null 2>&1
    rm_file /home/$grid_user/cfgrsp.properties
    # 11GR2 安装 grid 补丁
    if [[ $grid_patch ]]; then
      log_print "Grid 软件安装补丁"
      if [[ "$oracle_install_mode" == "rac" ]]; then
        color_printf blue "节点 $local_ip ："
      fi
      run_as_grid "unzip -oq $grid_opatch_name -d $env_grid_home"
      color_printf blue "检查 Grid 软件 OPacth 版本："
      check_opatch_version "$env_grid_home"
      echo
      color_printf blue "正在安装 Grid 软件补丁："
      "$env_grid_home"/OPatch/opatch auto "$software_dir"/"$grid_patch" -oh "$env_grid_home"
      for ip in "${rac_public_ips[@]:1}"; do
        echo
        color_printf blue "节点 $ip ："
        run_as_grid "ssh -q $ip unzip -oq $grid_opatch_name -d $env_grid_home"
        ssh -q "$ip" "$env_grid_home"/OPatch/opatch auto "$software_dir"/"$grid_patch" -oh "$env_grid_home"
      done
    fi
    ;;
  "12" | "19" | "21" | "23")
    # 恢复 files.lst
    if ((gi_version == 12)); then
      if check_file "$env_grid_home"/install/files.lst.original; then
        /bin/mv -f "$env_grid_home"/install/files.lst.original "$env_grid_home"/install/files.lst
      fi
      if [[ "$oracle_install_mode" == "rac" ]]; then
        for ip in "${rac_public_ips[@]:1}"; do
          ssh -q "$ip" /bin/mv -f "$env_grid_home"/install/files.lst.original "$env_grid_home"/install/files.lst
        done
      fi
      make -s -f "$env_grid_home"/rdbms/lib/ins_rdbms.mk client_sharedlib libasmclntsh12.ohso libasmperl12.ohso ORACLE_HOME="$env_grid_home" >/dev/null 2>&1
      for ip in "${rac_public_ips[@]:1}"; do
        ssh -q "$ip" "make -s -f $env_grid_home/rdbms/lib/ins_rdbms.mk client_sharedlib libasmclntsh12.ohso libasmperl12.ohso ORACLE_HOME=$env_grid_home" >/dev/null 2>&1
      done
    fi
    # 执行 root 脚本
    exec_root "$env_grid_home"
    run_as_grid "$env_grid_home/gridSetup.sh -executeConfigTools -responseFile $software_dir/grid.rsp -silent" >/dev/null 2>&1
    ;;
  esac
  if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
    if check_file "$env_grid_home"/crs/init/ohasd.sles; then
      /bin/cp -f "$env_grid_home"/crs/init/ohasd.sles /etc/init.d/ohasd
      systemctl enable ohasd.service
      ssh -q "$ip" "/bin/cp -f $env_grid_home/crs/init/ohasd.sles /etc/init.d/ohasd"
      ssh -q "$ip" "systemctl enable ohasd.service"
    fi
  fi
}
#==============================================================#
#                     获取创建 ASM 磁盘组命令                     #
#==============================================================#
# 创建ASM磁盘组
function get_asmca_cmd() {
  # 打印日志
  log_print "静默创建 ASM 磁盘组命令"
  # 操作Grid用户创建数据磁盘组
  data_asmca_cmd=$(echo -e "$env_grid_home/bin/asmca -silent \\
-createDiskGroup \\
-diskGroupName $data_asm_group \\
-diskList $datadisk \\
-redundancy $data_redun \\
-au_size $ausize \\
-compatible.asm $gi_compatible \\
-compatible.rdbms $db_compatible")
  color_printf blue "$data_asmca_cmd"
  # 判断归档磁盘是否存在，并操作Grid用户创建归档磁盘组
  if [[ -n "$arch_base_disk" ]]; then
    arch_asmca_cmd=$(echo -e "$env_grid_home/bin/asmca -silent \\
-createDiskGroup \\
-diskGroupName $arch_asm_group \\
-diskList $archdisk \\\
-au_size $ausize \\
-redundancy $arch_redun \\
-compatible.asm $gi_compatible \\
-compatible.rdbms $db_compatible")
    color_printf blue "$arch_asmca_cmd"
  fi
}
#==============================================================#
#                       创建 ASM 磁盘组                          #
#==============================================================#
# 创建ASM磁盘组
function create_asmgroup() {
  # 获取创建 ASM 磁盘组命令
  get_asmca_cmd
  # 打印日志
  log_print "ASM 磁盘组创建"
  color_printf blue "正在创建 ASM 磁盘组："
  # 操作Grid用户创建数据磁盘组
  run_as_grid "$data_asmca_cmd"
  # 判断归档磁盘是否存在，并操作Grid用户创建归档磁盘组
  if [[ -n "$arch_asmca_cmd" ]]; then
    run_as_grid "$arch_asmca_cmd"
  fi
  color_printf blue "查看 ASM 磁盘组：asmcmd lsdg"
  run_as_grid "asmcmd lsdg"
}
#==============================================================#
#                        解压 Oracle 软件                       #
#==============================================================#
function unzip_dbsoft() {
  # 执行日志输出函数
  log_print "静默解压 Oracle 软件包"
  # 修改软件目录的所有者和所属组为Oracle
  chown -R $oracle_user:oinstall "$software_dir"
  color_printf blue "正在静默解压缩 Oracle 软件包，请稍等："
  # 安装Oracle数据库软件以及相关补丁
  case "$db_version" in
  "11" | "12")
    # 只有当数据库所需文件夹不存在时，才会解压文件到指定目录下
    if check_file "$software_dir"/database; then
      cascade_del_file "$software_dir/database"
    fi
    # 解压第一个文件到指定的目录下，-o选项可以覆盖原有文件，-q选项可以减少输出信息
    if [[ "$db_soft_name1" ]]; then
      color_printf green "静默解压 Oracle 软件安装包： $db_soft_name,$db_soft_name1"
      run_as_oracle "unzip -oq $db_soft_name -d $software_dir && unzip -oq $db_soft_name1 -d $software_dir"
    else
      color_printf green "静默解压 Oracle 软件安装包： $db_soft_name"
      run_as_oracle "unzip -oq $db_soft_name -d $software_dir"
    fi
    # 修改 Kylin 10 安装 11GR2 和 12CR2 报错 unzip 问题，Oralce 内置 unzip 版本太低
    if [[ "$os_type" == "kylin" ]]; then
      /bin/mv -f "$software_dir"/database/install/unzip "$software_dir"/database/install/unzipbak
      /bin/cp -f /usr/bin/unzip "$software_dir"/database/install/unzip
    fi
    ;;
  *)
    echo
    color_printf green "静默解压 Oracle 软件安装包： $db_soft_name"
    run_as_oracle "unzip -oq $db_soft_name -d $env_oracle_home"
    ;;
  esac
  # 判断补丁
  if [[ $oracle_patch ]]; then
    # 任何模式，如果指定了 -opa 参数，则优先使用 -opa 指定的补丁
    patch_number=$oracle_patch
    local patch_name=$db_patch_name
  else
    # RAC 安装时，如果没有指定 -opa 参数，但是指定了 -gpa 参数，则默认使用 -gpa 指定的补丁
    if [[ $grid_patch ]]; then
      patch_number=$grid_patch
      patch_name=$grid_patch_name
    fi
  fi
  # 如果传入了oracle_patch参数，并且补丁所需文件夹不存在
  if [[ $patch_number ]]; then
    # 如果数据库版本不是11G/12C，则解压Opatch到Oracle Home文件夹中（$env_oracle_home）
    if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
      if check_file "$db_opatch_name"; then
        echo
        color_printf green "静默解压 OPatch 软件补丁包： $db_opatch_name"
        run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      fi
    fi
    if ! check_file "$software_dir"/"$patch_number"; then
      # 解压文件到指定目录下
      echo
      color_printf green "静默解压 Oracle 软件补丁包：$patch_name"
      run_as_oracle "unzip -oq $patch_name -d $software_dir"
    fi
    # 如果是 RAC 部署模式，需要在其他节点上也应用补丁
    if [[ "$oracle_install_mode" == "rac" ]]; then
      # 拷贝 oracle opatch/patch 到其他节点
      if [[ "$db_version" =~ ^(11|12)$ ]]; then
        for ip in "${rac_public_ips[@]:1}"; do
          # 将 oracle 补丁包和 opatch 包拷贝到其他节点的指定目录下，并修改目录所有者和所属组
          scp -q "$patch_name" "$ip":"$software_dir"
          # 修改远程主机上的文件所有权以便 oracle 用户可以操作
          ssh -q "$ip" "chown -R $oracle_user:oinstall $software_dir"
          run_as_oracle "ssh -q $ip unzip -oq $patch_name -d $software_dir"
        done
      fi
    fi
  fi
  # 检查是否需要安装 OJVM 补丁
  if [[ $ojvm_patch ]]; then
    if ! check_file "$software_dir"/"$ojvm_patch"; then
      echo
      color_printf green "静默解压 OJVM 软件补丁包： $ojvm_patch_name"
      # 如果 Oracle 数据库版本不是 11 或 12，需要先安装 OPatch
      if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
        # 在 oracle 用户下解压 OPatch 工具到 ORACLE_HOME 目录
        run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      fi
      # 解压 OJVM 补丁到指定目录
      run_as_oracle "unzip -oq $ojvm_patch_name -d $software_dir"
    fi
    # 如果是 RAC 部署模式，需要在其他节点上也应用补丁
    if [[ "$oracle_install_mode" == "rac" ]]; then
      for ip in "${rac_public_ips[@]:1}"; do
        # 将 OJVM 补丁复制到远程主机的指定目录下
        scp -q "$ojvm_patch_name" "$ip":"$software_dir"
        # 修改远程主机上的文件所有权以便 oracle 用户可以操作
        ssh -q "$ip" "chown -R $oracle_user:oinstall $software_dir"
        # 在远程主机上应用 OJVM 补丁
        run_as_oracle "ssh -q $ip unzip -oq $ojvm_patch_name -d $software_dir"
      done
    fi
  fi
}
#==============================================================#
#                    创建 Oracle 静默安装文件                     #
#==============================================================#
function conf_oraclersp() {
  log_print "Oracle 安装静默文件"
  # 将Oracle软件安装相关配置写入oracle.rsp文件
  declare -a oracle_rsp_arr=(
    "oracle.install.option=INSTALL_DB_SWONLY"
    "UNIX_GROUP_NAME=oinstall"
    "INVENTORY_LOCATION=$env_oracle_inven"
    "ORACLE_BASE=$env_oracle_base"
    "oracle.install.db.InstallEdition=EE"
  )
  if [[ "$oracle_install_mode" == "rac" ]]; then
    oracle_rsp_arr+=("oracle.install.db.CLUSTER_NODES=$rac_hostname")
  fi
  # 根据不同的版本向oracle.rsp文件追加配置
  case "$db_version" in
  "11")
    oracle_rsp_arr+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v11_2_0"
      "SELECTED_LANGUAGES=en,zh_CN"
      "ORACLE_HOME=$env_oracle_home"
      "oracle.install.db.DBA_GROUP=dba"
      "oracle.install.db.OPER_GROUP=oper"
      "DECLINE_SECURITY_UPDATES=true"
      "oracle.installer.autoupdates.option=SKIP_UPDATES"
    )
    ;;
  "12")
    oracle_rsp_arr+=(
      "oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v12.2.0"
      "SELECTED_LANGUAGES=en,zh_CN"
      "ORACLE_HOME=$env_oracle_home"
      "oracle.install.db.OSDBA_GROUP=dba"
      "oracle.install.db.OSOPER_GROUP=oper"
      "oracle.install.db.OSBACKUPDBA_GROUP=backupdba"
      "oracle.install.db.OSDGDBA_GROUP=dgdba"
      "oracle.install.db.OSKMDBA_GROUP=kmdba"
      "oracle.install.db.OSRACDBA_GROUP=racdba"
    )
    ;;
  "19" | "21" | "23")
    oracle_rsp_arr+=(
      "oracle.install.db.OSDBA_GROUP=dba"
      "oracle.install.db.OSOPER_GROUP=oper"
      "oracle.install.db.OSBACKUPDBA_GROUP=backupdba"
      "oracle.install.db.OSDGDBA_GROUP=dgdba"
      "oracle.install.db.OSKMDBA_GROUP=kmdba"
      "oracle.install.db.OSRACDBA_GROUP=racdba"
      "oracle.install.db.rootconfig.executeRootScript=false"
      "oracle.install.db.rootconfig.configMethod="
    )
    case "$db_version" in
    "19")
      oracle_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v19.0.0")
      ;;
    "21")
      oracle_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v21.0.0")
      ;;
    "23")
      oracle_rsp_arr+=("oracle.install.responseFileVersion=/oracle/install/rspfmt_dbinstall_response_schema_v23.0.0")
      ;;
    esac
    ;;
  esac
  rm_file "$software_dir/oracle.rsp"
  printf '%s\n' "${oracle_rsp_arr[@]}" >"$software_dir/oracle.rsp"
  # 记录 oracle.rsp 文件内容到日志中
  cat "$software_dir/oracle.rsp"
}
#==============================================================#
#                      获取安装 Oracle 命令                      #
#==============================================================#
function get_oracleinstall_cmd() {
  log_print "静默安装 Oracle 软件命令"
  # 判断补丁
  if [[ $oracle_patch ]]; then
    # 任何模式，如果指定了 -opa 参数，则优先使用 -opa 指定的补丁
    patch_number=$oracle_patch
  else
    # RAC 安装时，如果没有指定 -opa 参数，但是指定了 -gpa 参数，则默认使用 -gpa 指定的补丁
    if [[ $grid_patch ]]; then
      patch_number=$grid_patch
    fi
  fi
  case "$db_version" in
  "11" | "12")
    # 获取安装命令
    oracleinstall_cmd=$(echo -e "$software_dir/database/runInstaller \\
-silent \\
-responseFile $software_dir/oracle.rsp \\
-showProgress \\
-ignoreSysPrereqs \\
-ignorePrereq \\
-waitForCompletion")
    ;;
  "19" | "21" | "23")
    if [[ $patch_number ]]; then
      oracleinstall_cmd=$(echo -e "$env_oracle_home/runInstaller \\
-silent \\
-ignorePrereqFailure \\
-responseFile $software_dir/oracle.rsp \\
-waitForCompletion \\
-applyRU $software_dir/$patch_number")
    else
      # 无补丁
      oracleinstall_cmd=$(echo -e "$env_oracle_home/runInstaller \\
-silent \\
-ignorePrereqFailure \\
-responseFile $software_dir/oracle.rsp \\
-waitForCompletion")
    fi
    ;;
  esac
  color_printf blue "$oracleinstall_cmd"
}
#==============================================================#
#                       安装 Oracle 软件                         #
#==============================================================#
function install_dbsoft() {
  # 配置 Oracle 静默安装文件
  conf_oraclersp
  # 获取安装 Oracle 命令
  get_oracleinstall_cmd
  # 修改软件目录的所有者和所属组为Oracle
  chown -R $oracle_user:oinstall "$software_dir"
  # 打印日志
  log_print "静默安装数据库软件"
  if ! [[ "$db_version" =~ ^(11|12)$ ]]; then
    color_printf blue "检查 Oracle 软件 OPacth 版本："
    check_opatch_version "$env_oracle_home"
    echo
  fi
  color_printf blue "正在安装 Oracle 软件："
  # 安装数据库软件
  run_as_oracle "$oracleinstall_cmd"
  # 安装 Oracle 软件后操作
  after_oracle_install
  # 打印日志
  log_print "Oracle 软件版本"
  run_as_oracle "sqlplus -V"
  log_print "Oracle 补丁信息"
  run_as_oracle "opatch lspatches"
}
#==============================================================#
#                     安装 Oracle 软件后操作                     #
#==============================================================#
function after_oracle_install() {
  case "$db_version" in
  "11" | "12")
    if ((db_version == 11 && gi_version > 11)); then
      # 如果 GI 和 DB 版本不一致，[INS-35354] The system on which you are attempting to install Oracle RAC is not part of a valid cluster
      run_as_grid "$env_grid_home/oui/bin/runInstaller -updateNodeList ORACLE_HOME=$env_grid_home CRS=true" >/dev/null 2>&1
      for ip in "${rac_public_ips[@]:1}"; do
        run_as_grid "ssh -q $ip $env_grid_home/oui/bin/runInstaller -updateNodeList ORACLE_HOME=$env_grid_home CRS=true" >/dev/null 2>&1
      done
    fi
    # 修改 Kylin 10 安装 11GR2 和 12CR2 报错 unzip 问题，Oralce 内置 unzip 版本太低
    if [[ "$os_type" == "kylin" ]]; then
      /bin/mv -f "$env_oracle_home"/bin/unzip "$env_oracle_home"/bin/unzipbak
      /bin/cp -f /usr/bin/unzip "$env_oracle_home"/bin/unzip
    fi
    # 执行 root 脚本
    exec_root "$env_oracle_home"
    # 安装数据库补丁
    # 如果 patch_number 有值，则打补丁
    if [[ $patch_number ]]; then
      log_print "Oracle 软件安装补丁"
      # 解压 opatch 工具
      run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
      color_printf blue "检查 Oracle 软件 OPacth 版本："
      check_opatch_version "$env_oracle_home"
      echo
      color_printf blue "正在安装 Oracle 软件补丁："
      # RAC 和 单机ASM 安装 Oracle PSU/RU
      if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
        # RAC 安装数据库 PSU
        for ip in "${rac_public_ips[@]:1}"; do
          # 修改远程主机上的文件所有权以便 oracle 用户可以操作
          ssh -q "$ip" "chown -R $oracle_user:oinstall $software_dir"
          run_as_oracle "ssh -q $ip unzip -oq $db_opatch_name -d $env_oracle_home"
        done
        if ((db_version == 11)); then
          # 单机 ASM 模式不显示节点提示
          if [[ "$oracle_install_mode" == "rac" ]]; then
            color_printf blue "节点 $local_ip ："
          fi
          if [[ $oracle_patch ]]; then
            su - $oracle_user <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
          else
            "$env_oracle_home"/OPatch/opatch auto "$software_dir"/"$patch_number" -oh "$env_oracle_home"
          fi
          for ip in "${rac_public_ips[@]:1}"; do
            echo
            color_printf blue "节点 $ip ："
            if [[ $oracle_patch ]]; then
              ssh -q "$ip" "su - $oracle_user <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
            else
              ssh -q "$ip" "$env_oracle_home"/OPatch/opatch auto "$software_dir"/"$patch_number" -oh "$env_oracle_home"
            fi
          done
        elif ((db_version == 12)); then
          if [[ "$oracle_install_mode" == "rac" ]]; then
            color_printf blue "节点 $local_ip ："
          fi
          if [[ $oracle_patch ]]; then
            su - $oracle_user <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
          else
            "$env_oracle_home"/OPatch/opatchauto apply "$software_dir"/"$patch_number" -oh "$env_oracle_home"
          fi
          for ip in "${rac_public_ips[@]:1}"; do
            echo
            color_printf blue "节点 $ip ："
            if [[ $oracle_patch ]]; then
              ssh -q "$ip" "su - $oracle_user <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
            else
              ssh -q "$ip" "cd $software_dir/$patch_number;$env_oracle_home/OPatch/opatchauto apply $software_dir/$patch_number -oh $env_oracle_home"
            fi
          done
        fi
      else
        su - $oracle_user <<-EOF
cd $software_dir/$patch_number
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
      fi
    fi
    # 在 Linux6 上安装 12c 需要设置 irman、ioracle
    if ((db_version == 12 && os_version == 6)); then
      run_as_oracle "make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk irman" >/dev/null 2>&1
      run_as_oracle "make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk ioracle" >/dev/null 2>&1
      if [[ "$oracle_install_mode" == "rac" ]]; then
        for ip in "${rac_public_ips[@]:1}"; do
          run_as_oracle "ssh -q $ip make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk irman" >/dev/null 2>&1
          run_as_oracle "ssh -q $ip make -s -f $env_oracle_home/rdbms/lib/ins_rdbms.mk ioracle" >/dev/null 2>&1
        done
      fi
    fi
    # 安装 11GR2 需要修改 -lnnz11
    if ((db_version == 11)); then
      if ((os_version >= 7)); then
        sed -i "s/^\(\s*\$(MK_EMAGENT_NMECTL)\)\s*$/\1 -lnnz11/g" "$env_oracle_home"/sysman/lib/ins_emagent.mk
        if [[ "$oracle_install_mode" == "rac" ]]; then
          for ip in "${rac_public_ips[@]:1}"; do
            ssh -q "$ip" "sed -i 's/^\(\s*\$(MK_EMAGENT_NMECTL)\)\s*$/\1 -lnnz11/g' $env_oracle_home/sysman/lib/ins_emagent.mk"
          done
        fi
        if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
          # debian 8 ubuntu 1404 恢复 gcc 链接
          undo_adapt
        fi
      fi
      # 在 8 版本以上需要处理
      if ((os_version >= 8)); then
        run_as_oracle "make -s -f $env_oracle_home/sysman/lib/ins_emagent.mk emdctl" >/dev/null 2>&1
        if [[ "$oracle_install_mode" == "rac" ]]; then
          for ip in "${rac_public_ips[@]:1}"; do
            run_as_oracle "ssh -q $ip make -s -f $env_oracle_home/sysman/lib/ins_emagent.mk emdctl" >/dev/null 2>&1
          done
        fi
        # 恢复 libaio 链接
        undo_adapt
      fi
    fi
    ;;
  # 在 19C、21C 上应用 RU
  "19" | "21" | "23")
    # 执行 root 脚本
    exec_root "$env_oracle_home"
    ;;
  esac
  if [[ $ojvm_patch ]]; then
    install_ojvm_patch
  fi
}
#==============================================================#
#                        安装 OJVM 补丁                         #
#==============================================================#
# 安装 ojvm 补丁
function install_ojvm_patch() {
  log_print "OJVM 补丁安装"
  color_printf blue "检查 OJVM 软件 OPacth 版本："
  check_opatch_version "$env_oracle_home"
  echo
  # 解压 db 成功后，db 版本为 11/12 的数据库需要使用 opatch 工具
  case "$db_version" in
  "11" | "12")
    run_as_oracle "unzip -oq $db_opatch_name -d $env_oracle_home"
    for ip in "${rac_public_ips[@]:1}"; do
      # 修改远程主机上的文件所有权以便 oracle 用户可以操作
      ssh -q "$ip" "chown -R $oracle_user:oinstall $software_dir"
      run_as_oracle "ssh -q $ip unzip -oq $db_opatch_name -d $env_oracle_home"
    done
    ;;
  esac
  # 所有 db 版本都安装 ojvm 补丁
  if [[ "$oracle_install_mode" == "rac" ]]; then
    color_printf blue "节点 $local_ip ："
  fi
  # 所有版本安装 OJVM 补丁
  su - $oracle_user <<-EOF
cd $software_dir/$ojvm_patch
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF
  if [[ "$oracle_install_mode" == "rac" ]]; then
    for ip in "${rac_public_ips[@]:1}"; do
      echo
      color_printf blue "节点 $ip ："
      ssh -q "$ip" "su - $oracle_user <<-EOF
cd $software_dir/$ojvm_patch
$env_oracle_home/OPatch/opatch prereq CheckConflictAgainstOHWithDetail -ph ./
$env_oracle_home/OPatch/opatch apply -silent
EOF"
    done
  fi
}
#==============================================================#
#                           配置监听                            #
#==============================================================#
# 配置监听
function conf_netca() {
  # 检查Oracle安装模式是否为单实例，以及 listener.ora 文件是否存在
  if [[ "$oracle_install_mode" == "single" ]] && ! check_file "$env_oracle_home"/network/admin/listener.ora; then
    # 如果 netca.rsp 文件存在则执行 netca 配置命令
    if check_file "$env_oracle_home"/assistants/netca/netca.rsp; then
      log_print "静默安装 Oracle 软件命令"
      local netca_cmd
      netca_cmd=$(echo -e "$env_oracle_home/bin/netca -silent \\
-responsefile $env_oracle_home/assistants/netca/netca.rsp")
      color_printf blue "$netca_cmd"
      log_print "创建监听"
      color_printf blue "正在创建监听："
      run_as_oracle "$netca_cmd"
    fi
  fi
  # 输出检查监听状态的提示信息
  echo
  log_print "检查监听状态"
  # 使用oracle用户执行lsnrctl stat命令来检查监听状态
  run_as_oracle "lsnrctl stat"
}
#==============================================================#
#                        配置建库响应文件                         #
#==============================================================#
function get_dbca_rsp() {
  local dbname=$1 nums=$2 redo_size templatename db_block_size_11g
  # 计算数据库内存总和(MB) = 物理内存的 80%
  ((db_memory_total = os_memory_total * 4 / 5 / 1024 / nums))
  if ((db_block_size == 8192)); then
    templatename=General_Purpose.dbc
  else
    templatename=New_Database.dbt
  fi
  log_print "DBCA 静默建库文件：$dbname"
  if ((db_version == 11)); then
    db_block_size_11g=$((db_block_size / 1024))
    declare -a db_rsp_arr=(
      "[GENERAL]"
      "RESPONSEFILE_VERSION=11.2.0"
      "OPERATION_TYPE=createDatabase"
      "[CREATEDATABASE]"
      "GDBNAME=$dbname"
      "SID=$dbname"
      "TEMPLATENAME=$templatename"
      "SYSPASSWORD=$database_passwd"
      "SYSTEMPASSWORD=$database_passwd"
      "CHARACTERSET=$db_characterset"
      "NATIONALCHARACTERSET=$nation_characterset"
      "INITPARAMS=db_block_size=$db_block_size_11g"
      "TOTALMEMORY=$db_memory_total"
      "AUTOMATICMEMORYMANAGEMENT=FALSE"
    )
    # 根据安装模式设置特定参数
    case "$oracle_install_mode" in
    "rac")
      db_rsp_arr+=(
        "NODELIST=$rac_hostname"
        "STORAGETYPE=ASM"
        "DISKGROUPNAME=$data_asm_group"
        "RECOVERYGROUPNAME=$data_asm_group"
      )
      ;;
    "standalone")
      db_rsp_arr+=(
        "STORAGETYPE=ASM"
        "DISKGROUPNAME=$data_asm_group"
        "RECOVERYGROUPNAME=$data_asm_group"
      )
      ;;
    *)
      db_rsp_arr+=(
        "DATAFILEDESTINATION=$oradata_dir"
        "RECOVERYAREADESTINATION=$oradata_dir"
        "storageType=FS"
      )
      ;;
    esac
    redoline="<fileSize unit=\"KB\">51200</fileSize>"
  else
    declare -a db_rsp_arr=(
      "gdbName=$dbname"
      "sid=$dbname"
      "templateName=$templatename"
      "sysPassword=$database_passwd"
      "systemPassword=$database_passwd"
      "characterSet=$db_characterset"
      "nationalCharacterSet=$nation_characterset"
      "automaticMemoryManagement=false"
      "totalMemory=$db_memory_total"
      "initParams=db_block_size=${db_block_size}BYTES"
      "createAsContainerDatabase=$iscdb"
    )
    # 根据安装模式设置特定参数
    case "$oracle_install_mode" in
    "rac")
      db_rsp_arr+=(
        "databaseConfigType=RAC"
        "nodelist=$rac_hostname"
        "storageType=ASM"
        "diskGroupName=$data_asm_group"
        "recoveryGroupName=$data_asm_group"
      )
      ;;
    "standalone")
      db_rsp_arr+=(
        "databaseConfigType=SI"
        "storageType=ASM"
        "diskGroupName=$data_asm_group"
        "recoveryGroupName=$data_asm_group"
      )
      ;;
    *)
      db_rsp_arr+=(
        "databaseConfigType=SI"
        "storageType=FS"
        "datafileDestination=$oradata_dir"
        "recoveryAreaDestination=$oradata_dir"
      )
      ;;
    esac
    case "$db_version" in
    "12")
      db_rsp_arr+=("responseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v12.2.0")
      ;;
    "19")
      db_rsp_arr+=("responseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v19.0.0")
      ;;
    "21")
      db_rsp_arr+=("responseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v21.0.0")
      ;;
    "23")
      db_rsp_arr+=("responseFileVersion=/oracle/assistants/rspfmt_dbca_response_schema_v23.0.0")
      ;;
    esac
    redoline="<fileSize unit=\"KB\">204800</fileSize>"
  fi
  # 使用归档日志模式
  if [[ $enable_arch == "true" ]]; then
    sed -i "s|<archiveLogMode>false</archiveLogMode>|<archiveLogMode>true</archiveLogMode>|g" "$env_oracle_home/assistants/dbca/templates/$templatename"
  fi
  # 修改 redo 文件大小
  redo_size=$((redosize * 1024))
  sed -i "s|$redoline|<fileSize unit=\"KB\">${redo_size}</fileSize>|g" "$env_oracle_home/assistants/dbca/templates/$templatename"
  # 处理 12.2 Oracle Restart 问题
  if ((db_version == 12)); then
    check_file "$env_oracle_home/log/$dbname" || /bin/mkdir -p "$env_oracle_home/log/$dbname"
    chown -R $oracle_user:oinstall "$env_oracle_home/log/$dbname"
  fi
  rm_file "$software_dir/db.rsp"
  printf '%s\n' "${db_rsp_arr[@]}" >"$software_dir/db.rsp"
  # 记录 db.rsp 文件内容到日志中
  cat "$software_dir/db.rsp"
}
#==============================================================#
#                       获取 DB 创建命令                         #
#==============================================================#
function get_dbca_cmd() {
  log_print "静默创建数据库命令"
  # 获取安装命令
  if ((db_version == 11)); then
    dbca_cmd="$env_oracle_home/bin/dbca -silent -responseFile $software_dir/db.rsp"
  else
    dbca_cmd="$env_oracle_home/bin/dbca -silent -createDatabase \\
-responseFile $software_dir/db.rsp \\
-ignorePreReqs \\
-ignorePrereqFailure"
    if [[ "$db_version" =~ ^(19|21|23)$ ]]; then
      dbca_cmd="$dbca_cmd \\
-J-Doracle.assistants.dbca.validate.ConfigurationParams=false"
      if ((db_version == 23)); then
        dbca_cmd="$dbca_cmd \\
-initParams _exadata_feature_on=true"
      fi
    fi
  fi
  color_printf blue "$dbca_cmd"
}
#==============================================================#
#                           创建数据库                           #
#==============================================================#
# 创建数据库
function create_db() {
  # 获取建库命令并打印
  for name in "${db_names[@]}"; do
    get_dbca_rsp "$name" ${#db_names[@]}
    get_dbca_cmd
    # 修改软件目录的所有者和所属组为 grid
    chown -R $oracle_user:oinstall "$software_dir"
    # 打印日志到终端和文件
    log_print "创建数据库实例：$name"
    color_printf blue "正在创建数据库：$name"
    run_as_oracle "$dbca_cmd"
    # 配置 Oracle Managed Files（OMF）
    conf_omf "$name"
    # 创建 PDB
    if [[ $iscdb == "true" ]]; then
      create_pdb "$name"
    fi
  done
  # 配置 sqlnet.ora 文件
  if ((db_version >= 12)); then
    conf_sqlnet
  fi
}
#==============================================================#
#                       创建 PDB数据库                           #
#==============================================================#
# 创建 PDB 数据库
function create_pdb() {
  local dbname=$1
  # 打印日志到终端和文件
  log_print "创建 PDB 数据库"
  # 如果启用了多租户架构，则创建可插入数据库 (PDB)
  for pdbs in ${pdbname//,/ }; do
    color_printf blue "正在创建 PDB：$pdbs"
    execute_sqlplus "$dbname" "" "create pluggable database $pdbs admin user admin identified by $database_passwd default tablespace users;
alter pluggable database all open;
alter pluggable database all save state;
alter session set container=$pdbs;
alter profile default limit password_life_time unlimited;"
  done
  # 查看 pdb
  execute_sqlplus "$dbname" "" "show pdbs"
}
#==============================================================#
#                         配置 SQLNET                              #
#==============================================================#
# 配置 SQLNET.ORA
function conf_sqlnet() {
  # 配置 sqlnet.ora 文件
  if check_file "$env_oracle_home/network/admin/sqlnet.ora"; then
    backup_restore_file "$env_oracle_home/network/admin/sqlnet.ora"
  fi
  run_as_oracle "cat <<-EOF >>$env_oracle_home/network/admin/sqlnet.ora
# OracleBegin
SQLNET.ALLOWED_LOGON_VERSION_CLIENT=8
SQLNET.ALLOWED_LOGON_VERSION_SERVER=8
EOF"
  if [[ "$oracle_install_mode" == "rac" ]]; then
    # 将 sqlnet.ora 文件复制到其他节点
    for ip in "${rac_public_ips[@]:1}"; do
      scp -q "$env_oracle_home/network/admin/sqlnet.ora" "$ip:$env_oracle_home/network/admin/"
    done
  fi
}
#==============================================================#
#                         配置 OMF                              #
#==============================================================#
# 配置 OMF 以及优化 RMAN
function conf_omf() {
  # 定义 omf 变量，判断版本在11以后是否需要在路径前添加 + 符号
  local omf dbname=$1 arch
  # 如果安装模式为 rac，则获取数据组存储的路径；否则使用 oradata_dir 变量定义的路径。
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    omf=+$data_asm_group
    # 判断是否存在归档日志组磁盘路径，如果存在，则获取 arch_asm_group 存储路径；否则使用 omf 变量定义的路径。
    if [[ $arch_base_disk ]]; then
      arch=+$arch_asm_group
    else
      arch=$omf
    fi
    # 使用 su 命令以 oracle 用户身份执行 rman 命令，配置控制文件备份地址\
    su - $oracle_user <<-SO
source /home/$oracle_user/.$dbname
rman target / <<-EOF
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '$omf/snapcf_$dbname.f';
SHOW SNAPSHOT CONTROLFILE NAME;
EOF
SO
  else
    # 获取 oradata 目录的存储路径
    omf=$oradata_dir
    # 获取归档日志组存储路径
    arch=$archive_dir
  fi
  # 使用 su 命令以 oracle 用户身份执行 sqlplus 命令，配置数据库链接、redo log 和归档日志的存储路径
  execute_sqlplus "$dbname" "" "alter system set db_create_file_dest='$omf';
alter system set log_archive_dest_1='location=$arch';
alter system reset db_recovery_file_dest;
alter system reset db_recovery_file_dest_size;"
}
#==============================================================#
#                          配置控制文件                          #
#==============================================================#
function conf_controlfile() {
  log_print "配置 Oracle 数据库控制文件复用"
  local dbname=$1 ctl_count ctl_name ctl_name_new ctl_path
  ctl_count=$(execute_sqlplus "$dbname" "set pagesize 0" "select count(*) from v\$controlfile;" | tr -d '[:space:]')
  # 如果控制文件数量只有1个，则增加一个控制文件
  if ((ctl_count == 1)); then
    ctl_name=$(execute_sqlplus "$dbname" "set pagesize 0" "select name from v\$controlfile;" | tr -d '[:space:]')
    ctl_path=$(execute_sqlplus "$dbname" "set pagesize0" "select substr(name, 1, instr(name, '/', 1, 3)) from v\$controlfile;" | tr -d '[:space:]')
    if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
      ctl_name_new=$(execute_sqlplus "$dbname" "set pagesize 0" "select substr(replace(name,substr(name,1,instr(name,'/',1)-1),'+$data_asm_group'),1,instr(name,'/',-1)-1) || '/control02.ctl' from v\$controlfile where name = '$ctl_name';" | tr -d '[:space:]')
      # 重启数据库至 nomount 状态
      run_as_oracle "srvctl stop database -d $dbname"
      run_as_oracle "srvctl start database -d $dbname -o nomount"
    else
      ctl_name_new="${ctl_path}control02.ctl"
      # 重启数据库至 nomount 状态
      execute_sqlplus "$dbname" "" "shu immediate;
startup nomount;" >/dev/null 2>&1
    fi
    # 从原来的控制文件恢复一个新的控制文件
    su - $oracle_user <<-SO
source /home/$oracle_user/.$dbname
rman target / <<-EOF
restore controlfile to '$ctl_name_new' from '$ctl_name';
EOF
SO
    # 修改数据库控制文件参数
    execute_sqlplus "$dbname" "" "alter system set control_files='$ctl_name','$ctl_name_new' scope=spfile;"
    # 重启数据库生效参数
    if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
      run_as_oracle "srvctl stop database -d $dbname"
      run_as_oracle "srvctl start database -d $dbname"
    else
      execute_sqlplus "$dbname" "" "shu immediate;
startup;" >/dev/null 2>&1
    fi
  fi
  # 查询当前数据库控制文件
  echo
  color_printf blue "数据库控制文件："
  execute_sqlplus "$dbname" "col name for a100" "select name from v\$controlfile;"
}
#==============================================================#
#                    Configure redolog                         #
#==============================================================#
function conf_redolog() {
  log_print "配置在线重做日志"
  local i thread dbname=$1 redolog_path max_group new_group
  max_group=$(execute_sqlplus "$dbname" "set pagesize0" "select max(group#) from v\$logfile;" | tr -d '[:space:]')
  if [[ "$oracle_install_mode" == "rac" ]]; then
    for ((i = 0; i < ${#rac_public_ips[@]}; i++)); do
      max_group=$((max_group + 5 * i))
      ((thread = i + 1))
      for ((a = 1; a < 6; a++)); do
        new_group=$((max_group + a))
        execute_sqlplus "$dbname" "" "alter database add logfile thread $thread group $new_group size ${redosize}M;" >/dev/null 2>&1
      done
    done
  else
    redolog_path=$(execute_sqlplus "$dbname" "set pagesize0" "select substr(member, 1, instr(member, '/', -1, 1)) from v\$logfile where rownum = 1;" | tr -d '[:space:]')
    for ((a = 1; a < 6; a++)); do
      new_group=$((a + max_group))
      if ((new_group < 10)); then
        printf -v new_group "%02d" "$new_group"
      fi
      if [[ "$oracle_install_mode" == "single" ]]; then
        execute_sqlplus "$dbname" "" "alter database add logfile group $new_group '${redolog_path}redo${new_group}.log' size ${redosize}M;" >/dev/null 2>&1
      else
        execute_sqlplus "$dbname" "" "alter database add logfile group $new_group size ${redosize}M;" >/dev/null 2>&1
      fi
    done
  fi
  execute_sqlplus "$dbname" "col member for a80" "select a.thread#,a.group#,b.member member,a.bytes/1024/1024 \"size(M)\" from v\$log a,v\$logfile b where a.group#=b.group# order by 1,2;"
}
#==============================================================#
#                       配置数据库开机自启                        #
#==============================================================#
function db_autostart() {
  log_print "配置 Oracle 数据库开机自启"
  local dbname=$1
  # 查询当前数据库在线重做日志
  # 修改 oratab 文件，将数据库自动启动状态改为 Y
  sed -i 's/db:N/db:Y/' /etc/oratab
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    if ((gi_version == 11)); then
      # 修改资源配置，设置数据库自动启动
      "$env_grid_home"/bin/crsctl modify resource "ora.$dbname.db" -attr "AUTO_START=always"
    else
      # 该版本修改数据库自动启动方式不受支持，需要在命令中添加 -unsupported 参数
      "$env_grid_home"/bin/crsctl modify resource "ora.$dbname.db" -attr "AUTO_START=always" -unsupported
    fi
    color_printf blue "数据库开机自启配置："
    "$env_grid_home"/bin/crsctl stat res "ora.$dbname.db" -p | grep AUTO_START
  else
    color_printf blue "数据库开机自启配置："
    # 修改 dbstart 脚本，将变量 ORACLE_HOME_LISTNER 的值改为 $ORACLE_HOME
    sed -i "s/ORACLE_HOME_LISTNER=\$1/ORACLE_HOME_LISTNER=$ORACLE_HOME/" "$env_oracle_home/bin/dbstart"
    # sles 没有 rc.local 文件，需要使用 boot.local
    if [[ "$os_type" == "sles" ]]; then
      rc_file="/etc/init.d/boot.local"
    elif [[ "$os_type" =~ ^(ubuntu|debian|Deepin)$ ]]; then
      rc_file="/etc/rc.local"
    else
      rc_file="/etc/rc.d/rc.local"
    fi
    # 备份 rc 文件
    backup_restore_file $rc_file
    # 在 rc 文件中添加启动监听器和数据库的命令，并配置权限为可执行
    if ! grep '#!/bin/bash' $rc_file >/dev/null 2>&1; then
      write_file "N" $rc_file "#!/bin/bash"
    fi
    write_file "N" $rc_file "# OracleBegin
su $oracle_user -lc \"$env_oracle_home/bin/lsnrctl start\"
su $oracle_user -lc \"$env_oracle_home/bin/dbstart\""
    chmod +x $rc_file
    grep -v "^\s*\(#\|$\)" $rc_file
  fi
}
#==============================================================#
#                      配置 RMAN 备份脚本                        #
#==============================================================#
function db_backup() {
  log_print "配置 RMAN 备份任务"
  install_package "cron"
  local dbname=$1 scripts_dir=/home/$oracle_user/scripts rman_log_dir="/backup" rman_config
  mkdir -p $scripts_dir
  # 共用的 RMAN 配置参数
  rman_config=$(
    cat <<-RMAN
allocate channel c1 device type disk;
allocate channel c2 device type disk;
crosscheck backup;
crosscheck archivelog all;
sql"alter system archive log current";
delete noprompt expired backup;
delete noprompt obsolete device type disk;
backup not backed up 1 times as compressed backupset archivelog all format '/backup/arch_%d_%T_%t_%s_%p';
RMAN
  )
  # 删除过期归档日志脚本
  local del_arch_script="$scripts_dir/del_arch_$dbname.sh"
  cat >"$del_arch_script" <<DELARCH
#!/bin/bash
source ~/.$dbname
deltime=\$(date +"20%y%m%d%H%M%S")
rman target / nocatalog msglog $scripts_dir/del_arch_${dbname}_\$deltime.log <<-EOF
crosscheck archivelog all;
delete noprompt archivelog until time 'sysdate-7';
delete noprompt force archivelog until time 'SYSDATE-10';
EOF
DELARCH
  chmod +x "$del_arch_script"
  # Level 0 备份脚本
  local lv0_backup_script="$scripts_dir/dbbackup_lv0_$dbname.sh"
  cat >"$lv0_backup_script" <<LV0BACKUP
#!/bin/bash
source ~/.$dbname
backtime=\$(date +"20%y%m%d%H%M%S")
rman target / log=$rman_log_dir/level0_backup_${dbname}_\$backtime.log<<-EOF
run {
$rman_config
backup incremental level 0 database include current controlfile format '/backup/backlv0_%d_%T_%t_%s_%p';
}
EOF
LV0BACKUP
  chmod +x "$lv0_backup_script"
  # Level 1 备份脚本
  local lv1_backup_script="$scripts_dir/dbbackup_lv1_$dbname.sh"
  cat >"$lv1_backup_script" <<LV1BACKUP
#!/bin/bash
source ~/.$dbname
backtime=\$(date +"20%y%m%d%H%M%S")
rman target / log=$rman_log_dir/level1_backup_${dbname}_\$backtime.log<<-EOF
run {
$rman_config
backup incremental level 1 database include current controlfile format '/backup/backlv1_%d_%T_%t_%s_%p';
}
EOF
LV1BACKUP
  chmod +x "$lv1_backup_script"
  # 添加 crontab 计划任务
  local crontab_file="/var/spool/cron/$oracle_user"
  if check_file "$crontab_file"; then
    backup_restore_file "$crontab_file"
  else
    # 不存在文件时，生成一个原始空文件
    touch /var/spool/cron/$oracle_user.original
  fi
  write_file "N" "$crontab_file" "# OracleBegin
00 02 * * * $del_arch_script
#00 00 * * 0 $lv0_backup_script
#00 00 * * 1,2,3,4,5,6 $lv1_backup_script"
  if check_file /etc/cron.allow; then
    write_file "N" "/etc/cron.allow" "$oracle_user"
  fi
  chown -R $oracle_user:oinstall "$scripts_dir" "$rman_log_dir"
  cat /var/spool/cron/$oracle_user
}
#==============================================================#
#                        优化数据库参数                          #
#==============================================================#
function conf_para() {
  log_print "优化数据库参数"
  local dbname=$1 nums=$2 sga_target pga_target
  # memory for db sga_size(MB) = os_memory_total * 0.8 * 0.8 / 1024
  ((sga_target = (os_memory_total * 8 * 8 / 100 / 1024 / nums)))
  sga_target="${sga_target}M"
  # memory for db pga_size(MB) = os_memory_total * 0.8 * 0.2 / 1024
  ((pga_target = (os_memory_total * 8 * 2 / 100 / 1024 / nums)))
  pga_target="${pga_target}M"
  # just rac
  if [[ "$oracle_install_mode" == "rac" ]]; then
    execute_sqlplus "$dbname" "" "alter system set parallel_force_local=true sid='*' scope=spfile;
alter system set \"_gc_policy_time\"=0 scope=spfile;
alter system set \"_gc_undo_affinity\"=false scope=spfile;
alter system set \"_clusterwide_global_transactions\"=FALSE scope=spfile;"
  fi
  # 23ai 已经取消了这两个 job
  if ((db_version != 23)); then
    execute_sqlplus "$dbname" "" "exec dbms_scheduler.disable('ORACLE_OCM.MGMT_CONFIG_JOB');
exec dbms_scheduler.disable('ORACLE_OCM.MGMT_STATS_CONFIG_JOB');"
  fi
  execute_sqlplus "$dbname" "" "BEGIN
DBMS_AUTO_TASK_ADMIN.DISABLE(
client_name => 'auto space advisor',
operation => NULL,
window_name => NULL);
END;
/
BEGIN
DBMS_AUTO_TASK_ADMIN.DISABLE(
client_name => 'sql tuning advisor',
operation => NULL,
window_name => NULL);
END;
/
alter profile default limit password_grace_time unlimited;
alter profile default limit password_life_time unlimited;
alter profile default limit password_lock_time unlimited;
alter profile default limit failed_login_attempts unlimited;
alter system set audit_trail=none sid='*' scope=spfile;
alter system set sga_max_size=$sga_target sid='*' scope=spfile;
alter system set sga_target=$sga_target sid='*' scope=spfile;
alter system set pga_aggregate_target=$pga_target sid='*' scope=spfile;
alter system set processes=2000 scope=spfile;
alter system set open_cursors=1000 scope=spfile;
alter system set session_cached_cursors=300 scope=spfile;
alter system set db_files=5000 scope=spfile;
alter system set \"_undo_autotune\"=false sid='*' scope=spfile;
alter system set undo_retention=10800 scope=spfile;
alter system set control_file_record_keep_time=31;
alter system set event='28401 trace name context forever,level 1','10949 trace name context forever,level 1' sid='*' scope=spfile;
alter system set \"_b_tree_bitmap_plans\"=false sid='*';
alter system set deferred_segment_creation=false sid='*';
alter system set \"_optimizer_adaptive_cursor_sharing\"=false sid='*' scope=spfile;
alter system set \"_optimizer_extended_cursor_sharing\"=none sid='*' scope=spfile;
alter system set \"_optimizer_extended_cursor_sharing_rel\"=none sid='*' scope=spfile;
alter system set \"_optimizer_use_feedback\"=false sid ='*' scope=spfile;
alter system set \"_cleanup_rollback_entries\"=2000 sid='*' scope=spfile;
alter system set \"_datafile_write_errors_crash_instance\"=false sid='*';
alter system set parallel_max_servers=64 sid='*';"
  # for 11g implied parameters
  if ((db_version == 11)); then
    execute_sqlplus "$dbname" "" "alter system set resource_limit=true sid='*' scope=spfile;
alter system set resource_manager_plan='force:' sid='*' scope=spfile;
alter system set \"_optimizer_null_aware_antijoin\"=false sid ='*' scope=spfile;
alter system set \"_px_use_large_pool\"=true sid ='*' scope=spfile;
alter system set \"_partition_large_extents\"=false sid='*' scope=spfile;
alter system set \"_index_partition_large_extents\"=false sid='*' scope=spfile;
alter system set \"_use_adaptive_log_file_sync\"=false sid='*' scope=spfile;
alter system set \"_memory_imm_mode_without_autosga\"=false sid='*' scope=spfile;
alter system set enable_ddl_logging=true sid='*' scope=spfile;
alter system set sec_case_sensitive_logon=false sid='*' scope=spfile;"
  fi
  color_printf blue "数据库参数："
  # 查看数据库参数
  execute_sqlplus "$dbname" "col name for a50
col sid for a10
col spvalue for a80
col VALUE for a80" "SELECT DISTINCT s.name,
                s.sid,
                s.value spvalue,
                p.value VALUE
  FROM v\$spparameter s,
       gv\$parameter  p
 WHERE s.name = p.name
   AND (s.value IS NOT NULL OR (p.name IN ('statistics_level',
                                           'processes',
                                           'sessions',
                                           'db_files',
                                           'spfile',
                                           'optimizer_adaptive_features',
                                           'optimizer_adaptive_plans',
                                           'optimizer_adaptive_statistics',
                                           'max_string_size',
                                           'control_file_record_keep_time',
                                           '_use_adaptive_log_file_sync',
                                           'fast_start_parallel_rollback',
                                           '_datafile_write_errors_crash_instance',
                                           'max_dump_file_size',
                                           'parallel_max_servers',
                                           'deferred_segment_creation',
                                           '_optimizer_use_feedback',
                                           'open_cursors',
                                           'session_cached_cursors',
                                           'OPTIMIZER_INDEX_COST_ADJ',
                                           'optimizer_index_caching',
                                           'audit_trail',
                                           'SEC_CASE_SENSITIVE_LOGON',
                                           'parallel_force_local',
                                           'db_file_multiblock_read_count',
                                           'event',
                                           'dispatchers',
                                           'db_writer_processes',
                                           'optimizer_mode')))
   AND p.name NOT IN ('thread',
                      'instance_name',
                      'instance_number',
                      'undo_tablespace',
                      'local_listener',
                      'remote_listener',
                      'lisneter_network',
                      'control_files')
 ORDER BY s.name;"
}
#==============================================================#
#                         配置大页内存                           #
#==============================================================#
function conf_hugepage() {
  log_print "配置大页内存"
  # 获取当前系统的内核版本
  local KERN HPG_SZ NUM_PG=0 MIN_PG RES_BYTES HUGETLB_POOL
  KERN=$(uname -r | awk -F. '{ printf("%d.%d\n",$1,$2); }')
  HPG_SZ=$(grep Hugepagesize /proc/meminfo | awk '{print $2}')
  if [ -z "$HPG_SZ" ]; then
    color_printf yellow "在当前系统中不支持 HugePages！"
    echo
    return 1
  fi
  # 初始化计数器，累加所需的 HugePages 数量
  for SEG_BYTES in $(ipcs -m | cut -c44-300 | awk '{print $1}' | grep "[0-9][0-9]*"); do
    MIN_PG=$(echo "$SEG_BYTES/($HPG_SZ*1024)" | bc -q)
    if ((MIN_PG > 0)); then
      NUM_PG=$(echo "$NUM_PG+$MIN_PG+1" | bc -q)
    fi
  done
  # 计算所需的 HugePages 总大小（以字节为单位）
  RES_BYTES=$(echo "$NUM_PG * $HPG_SZ * 1024" | bc -q)
  # 如果需要使用 HugePages 的共享内存段总大小小于 100MB，则无法配置成功
  if ((RES_BYTES < 100000000)); then
    color_printf yellow "无法为 HugePages 配置分配足够的共享内存段。HugePages 只能用于大小与 Oracle 数据库 SGA 匹配的共享内存段。请确保：
* Oracle 数据库实例正在运行；
* Oracle 数据库 11g 自动内存管理（AMM）未配置！"
    echo
    return 1
  fi
  # 根据不同的内核版本，采用不同的 HugePages 配置方式
  case $KERN in
  "2.4")
    # 对于 2.4 版本的内核，使用 hugetlbfs 模式，并设置 vm.hugetlb_pool 参数
    HUGETLB_POOL=$(echo "$NUM_PG*$HPG_SZ/1024" | bc -q)
    echo "建议的参数设置：vm.hugetlb_pool = $HUGETLB_POOL"
    sysctl -w vm.hugetlb_pool="$HUGETLB_POOL"
    write_file "N" "/etc/sysctl.conf" "vm.hugetlb_pool=$HUGETLB_POOL"
    if [[ "$oracle_install_mode" == "rac" ]]; then
      for ip in "${rac_public_ips[@]:1}"; do
        ssh -q "$ip" sysctl -w vm.hugetlb_pool="$HUGETLB_POOL"
        ssh -q "$ip" "cat <<-EOF >>/etc/sysctl.conf
vm.hugetlb_pool=$HUGETLB_POOL
EOF"
      done
    fi
    ;;
  *)
    # 对于其他版本的内核，直接设置 vm.nr_hugepages 参数即可
    echo "建议的参数设置：vm.nr_hugepages = $NUM_PG"
    sysctl -w vm.nr_hugepages="$NUM_PG"
    write_file "N" "/etc/sysctl.conf" "vm.nr_hugepages=$NUM_PG"
    if [[ "$oracle_install_mode" == "rac" ]]; then
      for ip in "${rac_public_ips[@]:1}"; do
        ssh -q "$ip" sysctl -w vm.nr_hugepages="$NUM_PG"
        ssh -q "$ip" "cat <<-EOF >>/etc/sysctl.conf
vm.nr_hugepages=$NUM_PG
EOF"
      done
    fi
    ;;
  esac
  grep HugePages_Total /proc/meminfo
}
#==============================================================#
#                       配置 glogin.sql                         #
#==============================================================#
function conf_glogin() {
  # 定义函数，用于写入 glogin.sql 配置
  write_glogin_sql_config() {
    local target_file="$1"
    write_file "Y" "$target_file" "define _editor=vi
set serveroutput on size 1000000
set trimspool on
set long 5000
set linesize 100
set pagesize 9999
column plan_plus_exp format a80
set sqlprompt '&_user.@&_connect_identifier. SQL> '"
  }
  # 配置 glogin.sql
  log_print "配置 glogin.sql"
  backup_restore_file "$env_oracle_home/sqlplus/admin/glogin.sql"
  write_glogin_sql_config "$env_oracle_home/sqlplus/admin/glogin.sql"
  if [[ "$oracle_install_mode" == "rac" ]]; then
    backup_restore_file "$env_grid_home/sqlplus/admin/glogin.sql"
    write_glogin_sql_config "$env_grid_home/sqlplus/admin/glogin.sql"
    # 分发配置文件到其他节点
    for ip in "${rac_public_ips[@]:1}"; do
      run_as_oracle "scp -q $env_oracle_home/sqlplus/admin/glogin.sql $ip:$env_oracle_home/sqlplus/admin/"
      run_as_grid "scp -q $env_grid_home/sqlplus/admin/glogin.sql $ip:$env_grid_home/sqlplus/admin/"
    done
  fi
  # 移除 glogin.sql 中的注释行和空行
  grep -v "^\s*\(#\|$\|--\)" "$env_oracle_home/sqlplus/admin/glogin.sql"
}
#==============================================================#
#                          优化数据库                            #
#==============================================================#
function db_optimize() {
  for name in "${db_names[@]}"; do
    conf_controlfile "$name"
    conf_redolog "$name"
    db_autostart "$name"
    db_backup "$name"
    conf_para "$name" ${#db_names[@]}
  done
  conf_glogin
}
function end_del_file() {
  rm_file "$software_dir/libaio.so.1"
  rm_file "$software_dir/libaio.tar.xz"
  rm_file "$software_dir/db.rsp"
  rm_file "$software_dir/oracle.rsp"
  rm_file "$software_dir/grid.rsp"
  rm_file "$software_dir/database"
  rm_file "$software_dir/grid"
  rm_file "$software_dir/stat.tar.xz"
  rm_file "$software_dir/stat-stubs.o"
  rm_file "$software_dir/README.txt"
  rm_file "$software_dir/README.html"
  rm_file "$software_dir/bundle.xml"
  rm_file "$software_dir/18370031"
  if [[ $cpu_type == "aarch64" ]]; then
    rm_file "$software_dir/fstat64.oS"
    rm_file "$software_dir/lstat64.oS"
    rm_file "$software_dir/lstat.oS"
    rm_file "$software_dir/stat64.oS"
    rm_file "$software_dir/fstatat64.oS"
    rm_file "$software_dir/mknod.oS"
  fi
  if [[ $grid_patch ]]; then
    rm_file "$software_dir/$grid_patch"
  fi
  if [[ $oracle_patch ]]; then
    rm_file "$software_dir/$oracle_patch"
  fi
}
#==============================================================#
#                          主机是否重启                          #
#==============================================================#
function ask_for_reboot() {
  declare -u isreboot
  read -rep "$(echo -e "\033[1;34m$1 \E[0m")" isreboot
  echo
  # 安装完成删除脚本相关文件
  end_del_file
  if [[ $isreboot == "Y" ]]; then
    if [[ "$oracle_install_mode" == "rac" ]]; then
      for ip in "${rac_public_ips[@]:1}"; do
        color_printf blue "正在重启节点 $ip 主机......"
        ssh -q "$ip" "$(typeset -f check_file); $(typeset -f rm_file); $(typeset -f end_del_file); end_del_file"
        ssh -q "$ip" shutdown -r now
      done
    fi
    color_printf blue "正在重启当前节点主机......"
    shutdown -r now
  else
    exit 1
  fi
}
#==============================================================#
#                          Logo 打印                            #
#==============================================================#
function logo_print() {
  cat <<-EOF

   ███████                             ██          ████████ ██               ██  ██ ██                    ██              ██  ██
  ██░░░░░██                           ░██         ██░░░░░░ ░██              ░██ ░██░██                   ░██             ░██ ░██
 ██     ░░██ ██████  ██████    █████  ░██  █████ ░██       ░██       █████  ░██ ░██░██ ███████   ██████ ██████  ██████   ░██ ░██
░██      ░██░░██░░█ ░░░░░░██  ██░░░██ ░██ ██░░░██░█████████░██████  ██░░░██ ░██ ░██░██░░██░░░██ ██░░░░ ░░░██░  ░░░░░░██  ░██ ░██
░██      ░██ ░██ ░   ███████ ░██  ░░  ░██░███████░░░░░░░░██░██░░░██░███████ ░██ ░██░██ ░██  ░██░░█████   ░██    ███████  ░██ ░██
░░██     ██  ░██    ██░░░░██ ░██   ██ ░██░██░░░░        ░██░██  ░██░██░░░░  ░██ ░██░██ ░██  ░██ ░░░░░██  ░██   ██░░░░██  ░██ ░██
 ░░███████  ░███   ░░████████░░█████  ███░░██████ ████████ ░██  ░██░░██████ ███ ███░██ ███  ░██ ██████   ░░██ ░░████████ ███ ███
  ░░░░░░░   ░░░     ░░░░░░░░  ░░░░░  ░░░  ░░░░░░ ░░░░░░░░  ░░   ░░  ░░░░░░ ░░░ ░░░ ░░ ░░░   ░░ ░░░░░░     ░░   ░░░░░░░░ ░░░ ░░░ 

EOF
  echo
  color_printf yellow "注意：本脚本仅用于新服务器上实施部署数据库使用，严禁在已运行数据库的主机上执行，以免发生数据丢失或者损坏，造成不可挽回的损失！！！"
}
#==============================================================#
#                          传参前校验函数                         #
#==============================================================#
function pre_para_check() {
  # 检查脚本路径
  if [[ "$(dirname "$(readlink -f "$0")")" != "/soft" ]]; then
    color_printf yellow "注意：建议将 Oracle 软件安装包以及脚本放到 /soft 目录下并在 /soft 目录下执行脚本，否则可能会失败！"
  fi
  # 检查脚本名称是否为 OracleShellInstall
  if [[ "$(basename "$0")" != "OracleShellInstall" ]]; then
    color_printf red "本脚本不允许修改脚本名称，请修改回：OracleShellInstall，已退出！"
    exit 1
  fi
  # 判断当前执行脚本用户是否为 root 用户
  if [ "$(id -u)" != 0 ]; then
    color_printf red "本脚本需要使用 root 用户执行，已退出！"
    exit 1
  fi
  # 检查是否有 ping 命令
  if ! type ping >/dev/null 2>&1; then
    color_printf red "本脚本需要使用 ping 命令，请提前安装！"
  fi
}
#==============================================================#
#                           校验传参                            #
#==============================================================#
function accept_para() {
  while [[ $1 ]]; do
    case $1 in
    # 当前节点号，脚本内部参数，仅用于脚本识别当前执行的节点
    -node | --node_num)
      node_num=$2
      shift 2
      ;;
    -lrp | --local_repo)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      local_repo=$2
      shift 2
      ;;
    -nrp | --net_repo)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      net_repo=$2
      shift 2
      ;;
    -o | --db_name)
      checkpara_NULL "$1" "$2"
      db_name=$2
      shift 2
      ;;
    -n | --hostname)
      checkpara_NULL "$1" "$2"
      hostname=$2
      shift 2
      ;;
    -hn | --rac_hostname)
      checkpara_NULL "$1" "$2"
      rac_hostname=$2
      shift 2
      ;;
    -sn | --scan_name)
      checkpara_NULL "$1" "$2"
      check_RACNAME "$1" "$2"
      scan_name=$2
      shift 2
      ;;
    -cn | --cluster_name)
      checkpara_NULL "$1" "$2"
      check_RACNAME "$1" "$2"
      cluster_name=$2
      shift 2
      ;;
    -d | --env_base_dir)
      checkpara_NULL "$1" "$2"
      env_base_dir=${2%/}
      shift 2
      ;;
    -ord | --oradata_dir)
      checkpara_NULL "$1" "$2"
      oradata_dir=${2%/}
      shift 2
      ;;
    -ard | --archive_dir)
      checkpara_NULL "$1" "$2"
      archive_dir=${2%/}
      shift 2
      ;;
    -rp | --root_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      root_passwd=$2
      shift 2
      ;;
    -gu | --grid_user)
      checkpara_NULL "$1" "$2"
      grid_user=$2
      shift 2
      ;;
    -gp | --grid_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      grid_passwd=$2
      shift 2
      ;;
    -ou | --oracle_user)
      checkpara_NULL "$1" "$2"
      oracle_user=$2
      shift 2
      ;;
    -op | --oracle_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      oracle_passwd=$2
      shift 2
      ;;
    -dp | --database_passwd)
      checkpara_NULL "$1" "$2"
      check_password "$1" "$2"
      database_passwd=$2
      shift 2
      ;;
    -lf | --local_ifname)
      checkpara_NULL "$1" "$2"
      local_ifname=$2
      shift 2
      ;;
    -pf | --rac_priv_ifname)
      checkpara_NULL "$1" "$2"
      rac_priv_ifname=$2
      shift 2
      ;;
    -ri | --rac_public_ip)
      checkpara_NULL "$1" "$2"
      rac_public_ip=$2
      shift 2
      ;;
    -vi | --rac_virtual_ip)
      checkpara_NULL "$1" "$2"
      rac_virtual_ip=$2
      shift 2
      ;;
    -si | --rac_scan_ip)
      checkpara_NULL "$1" "$2"
      rac_scan_ip=$2
      shift 2
      ;;
    -ds | --db_characterset)
      checkpara_NULL "$1" "$2"
      checkpara_DBCHARSET "$1" "$2"
      db_characterset=$2
      shift 2
      ;;
    -ns | --nation_characterset)
      checkpara_NULL "$1" "$2"
      checkpara_NCHARSET "$1" "$2"
      nation_characterset=$2
      shift 2
      ;;
    -dbs | --db_block_size)
      checkpara_NUMERIC "$1" "$2"
      checkpara_DBS "$1" "$2"
      db_block_size=$2
      shift 2
      ;;
    -redo | --redosize)
      checkpara_NULL "$1" "$2"
      redosize=$2
      shift 2
      ;;
    -er | --enable_arch)
      checkpara_NULL "$1" "$2"
      checkpara_tf "$1" "$2"
      enable_arch=$2
      shift 2
      ;;
    -pdb | --pdbname)
      checkpara_NULL "$1" "$2"
      pdbname=$2
      iscdb=true
      shift 2
      ;;
    -dnsn | --dns_name)
      checkpara_NULL "$1" "$2"
      dns_name=$2
      shift 2
      ;;
    -dnsi | --dns_ip)
      checkpara_NULL "$1" "$2"
      dns_ip=$2
      shift 2
      ;;
    -dns | --dns)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      dns=$2
      shift 2
      ;;
    -on | --ocr_asm_group)
      checkpara_NULL "$1" "$2"
      ocr_asm_group=$2
      shift 2
      ;;
    -dn | --data_asm_group)
      checkpara_NULL "$1" "$2"
      data_asm_group=$2
      shift 2
      ;;
    -an | --arch_asm_group)
      checkpara_NULL "$1" "$2"
      arch_asm_group=$2
      shift 2
      ;;
    -mp | --multipath)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      multipath=$2
      shift 2
      ;;
    -adc | --asm_disk_conf)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      asm_disk_conf=$2
      shift 2
      ;;
    -od | --ocr_base_disk)
      checkpara_NULL "$1" "$2"
      ocr_base_disk=$2
      shift 2
      ;;
    -dd | --data_base_disk)
      checkpara_NULL "$1" "$2"
      data_base_disk=$2
      shift 2
      ;;
    -ad | --arch_base_disk)
      checkpara_NULL "$1" "$2"
      arch_base_disk=$2
      shift 2
      ;;
    -or | --ocr_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      ocr_redun=$2
      shift 2
      ;;
    -dr | --data_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      data_redun=$2
      shift 2
      ;;
    -ar | --arch_redun)
      checkpara_NULL "$1" "$2"
      checkpara_REDUN "$1" "$2"
      arch_redun=$2
      shift 2
      ;;
    -tsi | --timeserver_ip)
      checkpara_NULL "$1" "$2"
      timeserver_ip=$2
      shift 2
      ;;
    -gui | --isgui)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      isgui=$2
      shift 2
      ;;
    -vbox | --virtualbox)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      virtualbox=$2
      shift 2
      ;;
    -gpa | --grid_patch)
      checkpara_NULL "$1" "$2"
      grid_patch=$2
      shift 2
      ;;
    -opa | --oracle_patch)
      checkpara_NULL "$1" "$2"
      oracle_patch=$2
      shift 2
      ;;
    -jpa | --ojvm_patch)
      checkpara_NULL "$1" "$2"
      ojvm_patch=$2
      shift 2
      ;;
    -m | --only_conf_os)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      only_conf_os=$2
      shift 2
      ;;
    -ug | --install_until_grid)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      install_until_grid=$2
      shift 2
      ;;
    -ud | --install_until_db)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      install_until_db=$2
      shift 2
      ;;
    -opd | --optimize_db)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      optimize_db=$2
      shift 2
      ;;
    -install_mode | --oracle_install_mode)
      checkpara_NULL "$1" "$2"
      oracle_install_mode=$2
      shift 2
      ;;
    -giv | --gi_version)
      checkpara_NULL "$1" "$2"
      gi_version=$2
      shift 2
      ;;
    -dbv | --db_version)
      checkpara_NULL "$1" "$2"
      db_version=$2
      shift 2
      ;;
    -hf | --huge_flag)
      checkpara_NULL "$1" "$2"
      checkpara_YN "$1" "$2"
      huge_flag=$2
      shift 2
      ;;
    -debug | --debug)
      debug_flag="Y"
      shift 1
      ;;
    -fd | --filter_disk)
      checkpara_NULL "$1" "$2"
      filter_disk "$2"
      exit 0
      ;;
    -h | --help)
      help
      exit 0
      ;;
    *)
      color_printf red "脚本执行命令中的参数 [ $1 ] 传参不正确，请使用 'sh OracleShellInstall --help' 以获取更多帮助信息！"
      ;;
    esac
  done
}
function conf_master_node() {
  local paras paran parav
  paras=(
    "-lf local_ifname"
  )
  if [[ $oracle_install_mode == "standalone" ]]; then
    paras+=(
      "-dd data_base_disk"
    )
  elif [[ $oracle_install_mode == "rac" ]]; then
    paras+=(
      "-pf rac_priv_ifname"
      "-n hostname"
      "-hn rac_hostname"
      "-rp root_passwd"
      "-ri rac_public_ip"
      "-vi rac_virtual_ip"
      "-si rac_scan_ip"
      "-od ocr_base_disk"
      "-dd data_base_disk"
    )
  fi
  for para in "${paras[@]}"; do
    paran=${para%% *}
    parav=${para##* }
    if [[ -z ${!parav} ]]; then
      color_printf red "Oracle $oracle_install_mode 模式安装必须设置参数：[ $paran ]，请运行命令 'sh OracleShellInstall --help' 以获取更多帮助信息！"
    fi
  done
  for name in "${db_names[@]}"; do
    local length=${#name}
    check_DBNAME "$name"
    if ((length > 8 && length <= 12)); then
      color_printf purple "数据库名称 $name 长度超过 8 位，受 Oracle 限制，建库时会自动截取前 8 位作为数据库名称：${name:0:8}，请确认是否继续 (Y/N): [Y] "
      echo
    elif ((length > 12)); then
      color_printf red "数据库实例名称 $name 长度不能超过 12 位，受 Oracle 限制，建库会报错失败，请检查参数 [ -o ] 的值！"
      echo
    fi
  done
  if [[ $local_ip ]]; then
    if check_ip "$local_ip"; then
      check_ip_connectivity "$local_ip"
    else
      color_printf red "参数 [ -lf ] 网卡名称：$local_ifname 对应的 IP：$local_ip 不合规，请检查！"
    fi
  else
    color_printf red "参数 [ -lf ] 网卡名称：$local_ifname 不存在或者未配置 IP 信息，请检查！"
  fi
  if [[ $oracle_patch ]]; then
    db_patch_name=$(find "$software_dir" -type f -name "*$oracle_patch*zip")
    if ! check_file "$db_patch_name"; then
      color_printf red "参数 [ -opa ] 对应的补丁包：$db_patch_name 是否已上传至目录：$software_dir，请检查并上传！"
      exit 1
    fi
  fi
  if [[ $ojvm_patch ]]; then
    ojvm_patch_name=$(find "$software_dir" -type f -name "*$ojvm_patch*zip")
    if ! check_file "$ojvm_patch_name"; then
      color_printf red "参数 [ -jpa ] 对应的补丁包：$ojvm_patch_name 是否已上传至目录：$software_dir，请检查并上传！"
    fi
  fi
  # 单机 ASM 或者 RAC 检查
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    if [[ $grid_patch ]]; then
      grid_patch_name=$(find "$software_dir" -type f -name "*$grid_patch*zip")
      if ! check_file "$grid_patch_name"; then
        color_printf red "参数 [ -gpa ] 对应的补丁包：$grid_patch_name 是否已上传至目录：$software_dir，请检查并上传！"
      fi
    fi
    if [[ "$os_version" =~ ^(7|8|9|10)$ ]]; then
      if ((gi_version == 11)); then
        # 7/8/9 版本操作系统安装 11GR2 Grid 存在 bug 18370031，必须上传 p18370031_112040_Linux-x86-64.zip 补丁包
        if check_file "$software_dir"/p18370031_112040_Linux-x86-64.zip; then
          check_md5sum "$software_dir/p18370031_112040_Linux-x86-64.zip" "2a081e6145d4e4d2bf5350709dd3affa"
        else
          color_printf red "在 Linux 7 安装 11GR2 RAC 时，必须应用补丁 18370031，请上传补丁包 p18370031_112040_Linux-x86-64.zip 到 $software_dir 目录下！"
        fi
      fi
    fi
  fi
  # RAC 检查
  if [[ "$oracle_install_mode" == "rac" ]]; then
    # if ((${#rac_hostnames[@]} < 2)); then
    #   color_printf red "RAC 主机名参数 [ -hn ] 至少需要包含 2 个节点的主机名，以逗号隔开！"
    # fi
    if ((${#rac_priv_ifnames[@]} > 2)); then
      color_printf red "参数 [ -pf ] 心跳网卡不建议超过 2 组！"
    fi
    # if ((${#rac_public_ips[@]} < 2)); then
    #   color_printf red "参数 [ -ri ] 至少需要包含 2 个节点的公网 IP 地址，以逗号隔开！"
    # fi
    for public_ip in "${rac_public_ips[@]}"; do
      if check_ip "$public_ip"; then
        allips+=("$public_ip")
        ssh_ips+=("$public_ip")
        check_ip_connectivity "$public_ip"
      else
        color_printf red "参数 [ -ri ] 中的 IP：$public_ip 不合规，请检查！"
      fi
    done
    # if ((${#rac_virtual_ips[@]} < 2)); then
    #   color_printf red "参数 [ -vi ] 至少包含 2 个节点的虚拟 IP，以逗号隔开！"
    # fi
    for virtual_ip in "${rac_virtual_ips[@]}"; do
      if check_ip "$virtual_ip"; then
        allips+=("$virtual_ip")
        check_ip_unreachability "Virtual IP" "$virtual_ip"
      else
        color_printf red "参数 [ -vi ] 中的 IP：$virtual_ip 不合规，请检查！"
      fi
    done
    for ((i = 0; i < ${#rac_scan_ips[@]}; i++)); do
      if check_ip "${rac_scan_ips[i]}"; then
        allips+=("${rac_scan_ips[i]}")
        check_ip_unreachability "SCAN IP" "${rac_scan_ips[i]}"
      else
        color_printf red "参数 [ -si ] 中的 IP 地址：${rac_scan_ips[i]} 不合规，请检查！"
      fi
    done
    if [[ "$dns_ip" ]]; then
      if check_ip "$dns_ip"; then
        allips+=("$dns_ip")
        check_ip_connectivity "$dns_ip"
      else
        color_printf red "参数 [ -dsi ] IP 地址：$dns_ip 不合规，请检查！"
      fi
    fi
    if [[ "$timeserver_ip" ]]; then
      if check_ip "$timeserver_ip"; then
        allips+=("$timeserver_ip")
        check_ip_connectivity "$timeserver_ip"
      else
        color_printf red "参数 [ -tsi ] IP 地址：$timeserver_ip 不合规，请检查！"
      fi
    fi
    # 检查所有 IP 是否存在重复项
    isunique_ip
    if [[ "$local_ip" != "${rac_public_ips[0]}" ]]; then
      color_printf red "参数 [ -ri ] 的值：${rac_public_ips[0]} 第一个 IP 不是主节点的 IP，请检查参数！"
    fi
    # 检查集群名称
    if [[ -z $cluster_name ]]; then
      if ((${#hostname} > 7)); then
        color_printf red "参数 [ -cn ] 未配置，但是参数 [ -n ] 的值：$hostname 已超过 7 位，组成的集群名称将超过 15 位，不符合官方要求，请检查！"
      fi
    else
      if ((${#cluster_name} > 15)); then
        color_printf red "参数 [ -cn ] 集群名称：$cluster_name 已超过 15 位，不符合官方要求，请检查！"
      fi
    fi
    # 检查 SCAN 名称
    if [[ -z $scan_name ]]; then
      if [[ "$hostname" =~ ^[0-9] ]]; then
        color_printf red "参数 [ -sn ] 未配置，默认 SCAN 名称取自参数 [ -n ] 值拼接而成，SCAN 名称不能以数字开头，请检查参数 [ -n ] 值: $hostname！"
      fi
    fi
    # 检查 DNS
    if [[ $dns == "Y" ]]; then
      if [[ -z $dns_name || -z $dns_ip ]]; then
        color_printf red "参数 [ -dns ] 已传参，但是级联参数 [ -dnsn ] 和 [ -dnsi ] 没有传参，请检查！"
      fi
    else
      if ((scan_count > 1)); then
        color_printf red "参数 [ -si ] SCAN IP 数量超过 1 个，需要配置 DNS，但是配置 DNS 参数 [ -dns ] 没有传参，请检查！"
      fi
    fi
    # 检查主机名
    for host in "${rac_hostnames[@]}"; do
      # 对于 Oracle 11GR2，主机名不能包含大写字母
      if ((db_version == 11)); then
        if [[ "$host" == *[[:upper:]]* ]]; then
          color_printf red "Oracle 11GR2 RAC 安装主机名不能包含大写字母，请检查主机名: $host！"
        fi
      fi
    done
    execute_and_log "配置 root 用户互信" root_ssh_trust
    # 检查主机时间是否一致，相差超过10s则更新其他主机节点为本节点时间
    execute_and_log "正在检查并更新 RAC 主机时间" check_and_update_date
    # 针对主节点，生成其他节点参数并且分发 shell 脚本
    send_to_other_nodes
    # 安装 12CR2 RAC 存在 bug，必须上传 GRID RU 补丁包
    if ((gi_version == 12)); then
      if [[ $grid_patch ]]; then
        # 如果传了 -gpa 参数，则提示 -gpa 参数对应的PSU补丁包必须大于 28828733
        if ((grid_patch < 28828733)); then
          color_printf red "本脚本安装 12CR2 RAC 时，必须安装 Grid PSU 补丁号为 12.2.0.1.190115(28828733) 或者之后的 PSU 版本，请使用参数 [ -gpa ] 安装补丁！"
        fi
      else
        local ocr_avg_storage reduns ocr_total_storage=0 ocr_disks
        # 将磁盘路径字符串分割成数组
        IFS=',' read -ra ocr_disks <<<"$ocr_base_disk"
        for disk in "${ocr_disks[@]}"; do
          if [[ -n "$disk" ]]; then
            # 获取当前磁盘的容量（单位为GB）
            ocr_storage=$(lsblk -b -o SIZE,TYPE "$disk" | awk '$2 == "disk" {print $1/1024/1024/1024}')
            # 将当前磁盘的容量累加到总容量
            ocr_total_storage=$((ocr_total_storage + ocr_storage))
          fi
        done
        if [[ $ocr_redun == "EXTERNAL" ]]; then
          reduns=1
        elif [[ $ocr_redun == "NORMAL" ]]; then
          reduns=3
        elif [[ $ocr_redun == "HIGH" ]]; then
          reduns=5
        fi
        ocr_avg_storage=$((ocr_total_storage / reduns))
        # 检查 OCR 磁盘组大小，安装 GIMR 至少需要 50G
        if ((ocr_avg_storage < 50)); then
          color_printf red "Oracle 12CR2 基础版官方默认必须安装 GIMR 组件（OCR 磁盘组至少需要 50 G 空间），当前 OCR 冗余计算后为 [ $ocr_avg_storage G ] ，建议增加 OCR 磁盘空间或者安装 Grid PSU 补丁号为 12.2.0.1.190115(28828733) 之后的版本！"
        else
          gimr=true
        fi
      fi
    fi
  fi
}
function handle_para() {
  # 全局变量赋值
  if [[ $software_dir == "$env_base_dir" ]]; then
    color_printf red "Oracle 软件安装包以及脚本不能放在 $env_base_dir，建议创建 /soft 目录存放！"
  fi
  env_oracle_base=$env_base_dir/app/oracle
  env_oracle_inven=$env_base_dir/app/oraInventory
  env_grid_base=$env_base_dir/app/grid
  if [[ -z "$archive_dir" ]]; then
    archive_dir=$oradata_dir/archivelog
  fi
  IFS=',' read -ra db_names <<<"$db_name"
  local_ip=$(ip addr show dev "$local_ifname" 2>/dev/null | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
  if [[ "$oracle_install_mode" == "rac" ]]; then
    IFS=',' read -ra rac_hostnames <<<"$rac_hostname"
    IFS=',' read -ra rac_priv_ifnames <<<"$rac_priv_ifname"
    IFS=',' read -ra rac_public_ips <<<"$rac_public_ip"
    IFS=',' read -ra rac_virtual_ips <<<"$rac_virtual_ip"
    IFS=',' read -ra rac_scan_ips <<<"$rac_scan_ip"
    scan_count=${#rac_scan_ips[@]}
    # 配置 SCAN 名称
    if [[ -z $scan_name ]]; then
      scan_name=$hostname-scan
    fi
  fi
  # 配置安装包信息
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    get_grid_soft
  fi
  get_db_soft
  # 配置软件源
  conf_repo
  # 主节点校验必传参数
  if ((node_num == 1)); then
    conf_master_node
  else
    # 其他节点获取 ASM 磁盘 WWID
    if [[ $asm_disk_conf == "Y" ]]; then
      # 通过主节点传过来的 ocr_base_disk,data_base_disk.arch_base_disk 参数实际为 WWID
      ocr_disk_wwid=$ocr_base_disk
      data_disk_wwid=$data_base_disk
      [[ $arch_base_disk ]] && arch_disk_wwid=$arch_base_disk
    fi
  fi
  # 所有节点均执行
  case "$oracle_install_mode" in
  "single" | "standalone")
    HOSTNAME=$hostname
    ;;
  "rac")
    # 所有节点的 local_ip 都是主节点 ip
    local_ip=${rac_public_ips[0]}
    # 配置主机名称
    HOSTNAME=${rac_hostnames[$((node_num - 1))]}
    # 配置集群名称
    if [[ -z $cluster_name ]]; then
      cluster_name=$hostname-cluster
    fi
    declare -a clusternodes_array
    # 遍历 RAC 所有节点主机名
    for host in "${rac_hostnames[@]}"; do
      if ((db_version == 12)); then
        clusternodes_array+=("$host:${host}-vip:HUB")
      else
        clusternodes_array+=("$host:${host}-vip")
      fi
    done
    # 将 clusternodes_array 数组的内容格式化为逗号分隔的字符串
    clusternodes=$(printf "%s," "${clusternodes_array[@]}")
    clusternodes=${clusternodes%?}
    # 获取当前节点的心跳网卡信息
    local local_ipmask priv_ip rac_priv_ipmask
    local_ipmask=$(ip route show dev "$local_ifname" 2>/dev/null | awk '/kernel/ && /proto/ {print $1}' | cut -d'/' -f1 | head -n 1)
    networkinterfacelist_array=("$local_ifname:$local_ipmask:1")
    # 循环遍历所有节点的公共 IP
    for public_ip in "${rac_public_ips[@]}"; do
      # 循环遍历所有节点的私有网卡名称
      for priv_ifname in "${rac_priv_ifnames[@]}"; do
        # 使用 SSH 连接获取当前节点和网卡对应的心跳 IP 地址
        priv_ip=$(ssh -q "$public_ip" ip addr show dev "$priv_ifname" 2>/dev/null | awk '/inet / {print $2}' | cut -d/ -f1 | head -n 1)
        # 校验心跳 ip 地址是否合规
        if check_ip "$priv_ip"; then
          check_ip_connectivity "$priv_ip"
        else
          color_printf red "RAC 节点 $public_ip 参数 [ -pf ] 的网卡名称：$priv_ifname 对应的 IP：$priv_ip 不合规，请检查！"
        fi
        # 只需要主节点网卡信息即可
        if [[ $public_ip == "$local_ip" ]]; then
          # 获取子网地址
          rac_priv_ipmask=$(ip route show dev "$priv_ifname" 2>/dev/null | awk '/kernel/ && /proto/ {print $1}' | cut -d'/' -f1 | head -n 1)
          # rac 主机名和 vip 名写入 clusternodes 数组
          if ((gi_version == 11)); then
            ausize=1
            networkinterfacelist_array+=("$priv_ifname:$rac_priv_ipmask:2")
          else
            ausize=4
            networkinterfacelist_array+=("$priv_ifname:$rac_priv_ipmask:5")
          fi
        fi
        # 将心跳 ip 存放到对应的节点数组中
        node_name="${public_ip}_${priv_ifname}"
        rac_priv_ips["$node_name"]=$priv_ip
        # 将 node_name 添加到 rac_priv_ifnames_sorted 数组中
        rac_priv_ifnames_sorted+=("$node_name")
      done
    done
    networkinterfacelist=$(printf "%s," "${networkinterfacelist_array[@]}")
    # 去掉最后一个逗号
    networkinterfacelist=${networkinterfacelist%?}
    ;;
  esac
}
#==============================================================#
#                         获取操作系统信息                        #
#==============================================================#
function get_os_info() {
  local os_file
  libc_version=$(ldd --version | head -n 1 | awk '{print $NF}' | cut -d '.' -f 2)
  # 获取 cpu 类型
  cpu_type=$(uname -m)
  # 获取 os 类型
  if [[ -e /etc/os-release ]]; then
    os_type=$(grep -oP '^ID="?(\K[^"]+|[^"]+$)' /etc/os-release)
    pretty_name=$(grep '^PRETTY_NAME=' /etc/os-release | cut -d'"' -f2)
  else
    os_file=$(if [[ -f "/etc/system-release" ]]; then echo /etc/system-release; else echo /etc/redhat-release; fi)
    os_type=$(grep -oP '^[A-Za-z]+' "$os_file")
    pretty_name=$(cat /etc/system-release)
  fi
  # 获取 os 版本
  if ((libc_version >= 12 && libc_version <= 16)); then
    os_version=6
  elif ((libc_version >= 17 && libc_version <= 27)); then
    os_version=7
  elif ((libc_version >= 28 && libc_version <= 33)); then
    os_version=8
  elif ((libc_version >= 34 && libc_version <= 38)); then
    os_version=9
  elif ((libc_version >= 39)); then
    os_version=10
  else
    color_printf red "当前操作系统版本 [ $pretty_name ] 不在脚本支持列表中，如有需要请联系开发者适配！"
  fi
  # 校验 CPU 类型是否适配 19C ARM，需要特性：atomics
  if [[ "$cpu_type" == "aarch64" ]]; then
    if ! grep -qm 1 -oP 'Features\s+:\s+\K.*\batomics\b' /proc/cpuinfo; then
      color_printf red "当前主机 CPU 芯片不适配 Oracle 19C ARM 安装！"
    fi
  fi
  # 部分系统只能配置网络软件源
  if is_in_list "$os_type" "${net_os_list[@]}"; then
    net_repo=Y
    local_repo=N
  fi
  # 适配 UOS 各版本，为了防止 d 系列判断必须走网络软件源，所以必须放在网络源判断之后执行
  if [[ "$os_type" =~ ^(uos|UOS)$ ]]; then
    uos_edition=$(grep -oP '^EditionName="?(\K[^"]+|[^"]+$)' /etc/os-version)
    if [[ "$uos_edition" =~ ^(a|c)$ ]]; then
      os_type=uos
    elif [[ "$uos_edition" == "e" ]]; then
      os_type=openEuler
    elif [[ "$uos_edition" == "d" ]]; then
      os_type=debian
    fi
  fi
  # deb 系赋值 so_path
  adapt_so_path
  # 处理系统默认配置
  conf_os
}
# 系统库搜索路径赋值函数
function adapt_so_path() {
  case "$os_type" in
  "debian" | "ubuntu" | "Deepin")
    a_path=/usr/lib/${cpu_type}-linux-gnu
    so_path=/lib/${cpu_type}-linux-gnu
    ;;
  *)
    # 默认静态库搜索路径
    a_path=/usr/lib64
    # 默认动态库搜索路径
    so_path=/usr/lib64
    ;;
  esac
}
#==============================================================#
#                    选择数据库安装模式和版本                      #
#==============================================================#
function select_db_options() {
  local dbversion
  while :; do
    read -rep "$(echo -e "\033[1;34m请选择安装模式 [单机(si)/单机ASM(sa)/集群(rac)] : \E[0m")" oracle_install_mode
    echo
    case "$oracle_install_mode" in
    si) oracle_install_mode=single ;;
    sa) oracle_install_mode=standalone ;;
    esac
    if [[ "$oracle_install_mode" =~ ^(single|standalone|rac)$ ]]; then
      color_printf green "数据库安装模式:" "$oracle_install_mode"
      break
    else
      color_printf yellow "数据库安装模式输入错误，请重新选择！"
    fi
  done
  # arm 目前只支持 19c 版本
  if [[ $cpu_type == "aarch64" ]]; then
    dbversion=19
  else
    dbversion='11|12|19|21|23'
  fi
  while :; do
    echo
    read -rep "$(echo -e "\033[1;34m请选择数据库版本 [$dbversion] : \E[0m")" db_version
    echo
    if [[ "$db_version" =~ ^($dbversion)$ ]]; then
      color_printf green "数据库版本:" "$db_version"
      break
    else
      color_printf yellow "数据库版本输入错误，请重新选择！"
    fi
  done
  echo
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    # gi_version 未传参，则代表 GI 和 DB 版本相同
    if [[ -z "$gi_version" ]]; then
      gi_version=$db_version
    else
      # 判断 gi 版本需要大于 db 版本
      if ((gi_version < db_version)); then
        color_printf red "参数 [ -giv ] 的值：GI 版本 $gi_version 必须必须大于等于 DB 版本 $db_version，请检查！"
      fi
    fi
  fi
}
function install_time_record() {
  local signal=$1
  if [[ "$signal" == "start" ]]; then
    install_start_time=$(date +%s)
    # 安装日志提示
    date >>"$oracleinstalllog"
    color_printf green "OracleShellInstall 开始安装，详细安装过程可查看日志： tail -2000f $oracleinstalllog"
    echo
  elif [[ "$signal" == "end" ]]; then
    local install_end_time install_execution_time
    install_end_time=$(date +%s)
    install_execution_time=$((install_end_time - install_start_time))
    echo
    ask_for_reboot "恭喜！Oracle 一键安装执行完成 (耗时: $install_execution_time 秒)，现在是否重启主机：[Y/N]"
  fi
}
function conf_os() {
  # 避免Linux主机提示注册
  [[ -e /etc/yum/pluginconf.d/subscription-manager.conf ]] && sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/subscription-manager.conf
  # 避免Kyli/openEuler主机提示注册
  [[ -e /etc/yum/pluginconf.d/debuginfo-install.conf ]] && sed -i 's/enabled=1/enabled=0/' /etc/yum/pluginconf.d/debuginfo-install.conf
  # 切换用户时不显示 Last Login 信息
  sed -i 's/^session\+[[:space:]]\+include[[:space:]]\+postlogin/#&/g' /etc/pam.d/su
  # 去除密码复杂度设置（防止简单密码不符合复杂度配置导致互信失败）
  case "$os_type" in
  "sles" | "opensuse-leap" | "opensuse-tumbleweed")
    sed -i 's/^password\+[[:space:]]\+requisite[[:space:]]\+pam_cracklib.so/#&/g' /etc/pam.d/common-password
    sed -i '/^password.*pam_unix\.so/s/use_authtok //' /etc/pam.d/common-password
    ;;
  "uos")
    sed -i 's/^password    requisite     pam_deepin_pw_check.so try_first_pass local_users_only retry=1 enforce_for_root authtok_type=/#&/' /etc/pam.d/system-auth
    sed -i 's/use_authtok$//' /etc/pam.d/system-auth
    ;;
  "kylin" | "openEuler" | "neokylin")
    sed -i 's/^password\+[[:space:]]\+requisite[[:space:]]\+pam_pwquality.so/#&/g' /etc/pam.d/system-auth
    sed -i 's/use_authtok$//' /etc/pam.d/system-auth
    ;;
  esac
  # 处理 egrep 告警问题
  local target_line="echo \"\$cmd: warning: \$cmd is obsolescent; using grep -E\" >&2"
  if check_file /usr/bin/egrep; then
    if grep -q -F "$target_line" /usr/bin/egrep; then
      sed -i "/$target_line/s/^/#/" /usr/bin/egrep
    fi
  fi
  # debian,ubuntu 路径 /bin/egrep
  if check_file /bin/egrep; then
    if grep -q -F "$target_line" /bin/egrep; then
      sed -i "/$target_line/s/^/#/" /bin/egrep
    fi
  fi
  # 获取 profile 名称
  if [[ "$os_type" =~ ^(sles|opensuse-leap|opensuse-tumbleweed|ubuntu|debian|Deepin)$ ]]; then
    profile_name=.profile
  else
    profile_name=.bash_profile
  fi
  # 适配 deb 系统缺少 rpm 问题
  if [[ "$os_type" =~ ^(ubuntu|debian|Deepin|arch)$ ]]; then
    write_file "Y" "/usr/bin/rpm" "#!/bin/bash
case \"\$2\" in
\"sles-release\")
  echo \"Not installed\"
  exit 1
  ;;
\"/sbin/init\")
  echo \"systemd-219-78.el7.x86_64\"
  exit 0
  ;;
*)
  echo \"test\"
  exit 0
  ;;
esac"
    chmod +x /usr/bin/rpm
  fi
}

function conf_repo() {
  # 必须联网的操作系统，检查外网联通性
  echo
  if [[ $net_repo == "Y" ]]; then
    # local_repo 默认为 N，当传值为 Y 时，本地软件源标志设置为 N
    local_repo=N
    if is_in_list "$os_type" "${local_os_list[@]}"; then
      color_printf red "本脚本暂不支持 [ $pretty_name ] 配置网络镜像源，正在适配中，请配置本地软件源或者自行配置软件源！"
    fi
    if [[ $os_type != "hce" ]]; then
      check_internet_connectivity
    fi
    execute_and_log "正在配置网络软件源" conf_network_repository
  fi
  # 检查本地 ISO 是否挂载
  if [[ $local_repo == "Y" ]]; then
    check_iso
    execute_and_log "正在配置本地软件源" conf_local_repository
  else
    if [[ $net_repo == "N" ]]; then
      # 不需要脚本配置软件源时，检查软件源是否正常
      if [[ "$os_type" =~ ^(opensuse-leap|opensuse-tumbleweed)$ ]]; then
        if ! zypper ref >/dev/null 2>&1; then
          color_printf red "当前软件源配置错误，请自行检查软件源配置！"
        fi
      else
        yum clean all >/dev/null 2>&1
        if ! yum makecache >/dev/null 2>&1; then
          color_printf red "当前软件源配置错误，请自行检查软件源配置！"
        fi
      fi
    fi
  fi
  # 适配 openSUSE
  if [[ "$os_type" =~ ^(opensuse-leap|opensuse-tumbleweed)$ ]]; then
    os_type=sles
  fi
}
function clean_old_envir() {
  color_printf purple "当前主机已存在数据库用户 $oracle_user 且 $env_base_dir 目录已存在，请检查是否连错主机，若没有则需要清理旧环境后再执行脚本，是否打印清理命令 (Y/N): [Y] "
  echo
  color_printf blue "请使用 root 用户手工执行清理旧环境命令（RAC 模式所有节点均需执行，建议清理完成后重启主机）："
  echo "RAC 模式下清理过程中可能主机会自动重启，重启后再次执行以下命令即可"
  echo
  # 删除用户和组
  local users=("$oracle_user") groups=("oinstall" "dba" "oper" "dgdba" "backupdba" "kmdba" "racdba") oracle_processes=("oracle" "$oracle_user" "ora_" "tnslsnr")
  local dirs_to_clean=("/etc/oracle" "$env_base_dir" "$oradata_dir" "$archive_dir") files_to_clean=("/etc" "/opt" "/tmp")
  # 针对单机 ASM/RAC 模式
  if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
    dirs_to_clean+=("/etc/init.d/init.tfa" "/etc/init.d/init.ohasd")
    # 添加 RAC 相关进程到 oracle_processes 数组
    oracle_processes+=("grid" "$grid_user" "crsd.bin" "ohasd.bin" "ohasd" "evmd.bin" "evmlogger.bin" "ocssd.bin" "agent.bin" "asm_" "ASM" "tfa" "tfa.TFAMain" "OSWatcher")
    # 删除 grid 用户
    users+=("$grid_user")
    # 添加 ASM 相关组
    groups+=("asmdba" "asmoper" "asmadmin")
  fi
  for user in "${users[@]}"; do
    # 查找并强制终止用户的所有进程
    if getent passwd "$user" >/dev/null 2>&1; then
      echo "pkill -KILL -u $user"
      echo "pkill -u $user -9 -f"
      echo "userdel -rf $user"
      if [[ "$os_type" == "kylin" ]]; then
        # 检查用户名是否在 /etc/uid_list 文件中
        if grep -q "^$user:" /etc/uid_list; then
          # 如果存在，使用 sed 命令删除该行
          echo "sed -i \"/^$user:/d\" /etc/uid_list"
        fi
      fi
    fi
  done
  for group in "${groups[@]}"; do
    if getent group "$group" >/dev/null 2>&1; then
      echo "groupdel $group"
    fi
  done
  # 清理旧文件和目录内容
  for dir in "${dirs_to_clean[@]}"; do
    if [[ "$dir" ]]; then
      echo "/bin/rm -rf $dir"
    fi
  done
  for path in "${files_to_clean[@]}"; do
    echo "find $path -maxdepth 1 \( -name \"Ora*\" -o -name \"ora*\" -o -name \"CVU*\" -o -name \"osw*\" -o -name \"hsperfdata*\" \) ! -name \"oracle-release\" -exec /bin/rm -rf {} +"
  done
  # 关闭数据库和监听进程
  for process in "${oracle_processes[@]}"; do
    if pgrep -f "$process" >/dev/null 2>&1; then
      echo "pkill -9 -f $process"
    fi
  done
  # 重启主机
  echo "shutdown -r now"
}
#==============================================================#
#                            主函数                             #
#==============================================================#
function main() {
  # 打印脚本 Logo
  logo_print
  # 脚本处理传参
  accept_para "$@"
  # 获取操作系统信息
  get_os_info
  if ((node_num == 1)); then
    pre_para_check
    select_db_options
    # 清理 oracle 安装旧环境
    # 判断当前安装用户是否存在，并且对应的 env_base_dir 目录下有数据，则清理
    if getent passwd "$oracle_user" >/dev/null 2>&1 && check_file "$env_base_dir"; then
      clean_old_envir
      echo
      exit 1
    fi
    # 检查 Oracle 官方兼容性
    check_oracle_compatibility
    # 获取共享磁盘 WWID
    if [[ "$oracle_install_mode" =~ ^(rac|standalone)$ ]]; then
      conf_disk_wwid
    fi
    # 检查操作系统是否符合安装条件
    check_os_version
    # 安装开始记录时间以及日志
    install_time_record "start"
    color_printf blue "正在进行安装前检查，请稍等......"
  fi
  # 脚本校验传参
  handle_para
  ## 打印系统信息
  execute_and_log "正在获取操作系统信息" print_sysinfo
  # 安装软件包
  execute_and_log "正在安装依赖包" pkg_install
  # 适配操作系统
  adapt_os_version
  # 如果需要额外交换空间，则创建并启用 swap，避免报错 mkswap: error: swap area needs to be at least 40 KiB
  if ((swap_count > 40)); then
    execute_and_log "正在配置 Swap" conf_swap
  fi
  if { type firewalld || type ufw || type iptables; } >/dev/null 2>&1; then
    execute_and_log "正在禁用防火墙" disable_firewall
  fi
  if type getenforce >/dev/null 2>&1 && check_file /etc/selinux/config; then
    execute_and_log "正在禁用 selinux" disable_selinux
  fi
  if [[ $os_type != "sles" ]]; then
    if check_file /etc/sysconfig/network; then
      execute_and_log "正在配置 nsyctl" conf_nsysctl
    fi
  fi
  execute_and_log "正在配置主机名和 hosts 文件" conf_hostname
  conf_hosts
  execute_and_log "正在创建用户和组" create_users_groups
  execute_and_log "正在创建安装目录" create_dir
  if type avahi-daemon >/dev/null 2>&1; then
    execute_and_log "正在配置 Avahi-daemon 服务" conf_avahi
  fi
  execute_and_log "正在配置透明大页 && NUMA && 磁盘 IO 调度器" conf_grub
  execute_and_log "正在配置操作系统参数 sysctl" conf_sysctl
  if ((os_version >= 7)); then
    if [[ $os_type == "sles" ]] && ((os_version >= 9)); then
      logind_file="/usr/lib/systemd/logind.conf"
    else
      if ((os_version >= 10)); then
        logind_file="/usr/lib/systemd/logind.conf"
      else
        logind_file="/etc/systemd/logind.conf"
      fi
    fi
    if grep -q "RemoveIPC=" $logind_file; then
      execute_and_log "正在配置 RemoveIPC" conf_ipc
    fi
  fi
  execute_and_log "正在配置用户限制 limit" conf_limits
  execute_and_log "正在配置 shm 目录" conf_shm
  # 检查 rlwrap 压缩包是否存在
  if ls "$software_dir"/rlwrap-*.gz >/dev/null 2>&1; then
    if ! type rlwrap >/dev/null 2>&1; then
      execute_and_log "正在安装 rlwrap 插件" install_rlwrap
    fi
  fi
  execute_and_log "正在配置用户环境变量" conf_profile
  # 单机模式安装
  install_single_mode() {
    execute_and_log "正在解压 Oracle 安装包以及补丁" unzip_dbsoft
    if [[ $only_conf_os == "N" ]]; then
      execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
      execute_and_log "正在创建监听" conf_netca
      if [[ $install_until_db == "N" ]]; then
        execute_and_log "正在创建数据库" create_db
      fi
    fi
  }
  # 单机 ASM 模式安装
  install_standalone_mode() {
    if [[ $asm_disk_conf == "Y" ]]; then
      conf_asm
    fi
    execute_and_log "正在解压 Grid 安装包以及补丁" unzip_gridsoft
    execute_and_log "正在解压 Oracle 安装包以及补丁" unzip_dbsoft
    if [[ $only_conf_os == "N" ]]; then
      execute_and_log "正在安装 Grid 软件以及补丁" install_gridsoft
      if [[ $install_until_grid == "N" ]]; then
        execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
        if [[ $install_until_db == "N" ]]; then
          execute_and_log "正在创建数据库" create_db
        fi
      fi
    fi
  }
  # RAC 模式安装
  install_rac_mode() {
    if [[ $timeserver_ip ]]; then
      execute_and_log "正在配置时间同步" conf_timesync
    fi
    if [[ $dns == "Y" ]]; then
      execute_and_log "正在配置 DNS 解析" conf_dns
    fi
    if [[ $asm_disk_conf == "Y" ]]; then
      conf_asm
    fi
    if ((node_num == 1)); then
      execute_and_log "正在配置 RAC 其他节点信息" other_node_shell
      execute_and_log "正在配置 RAC 所有节点互信" rac_ssh
      execute_and_log "正在解压 Grid 安装包以及补丁" unzip_gridsoft
      execute_and_log "正在解压 Oracle 软件以及补丁" unzip_dbsoft
      if [[ $only_conf_os == "N" ]]; then
        execute_and_log "正在安装 Grid 软件以及补丁" install_gridsoft
        execute_and_log "正在创建 ASM 磁盘组" create_asmgroup
        if [[ $install_until_grid == "N" ]]; then
          execute_and_log "正在安装 Oracle 软件以及补丁" install_dbsoft
          if [[ $install_until_db == "N" ]]; then
            execute_and_log "正在创建数据库" create_db
          fi
        fi
      fi
    fi
  }
  # 判断 Oracle 安装模式
  case "$oracle_install_mode" in
  "single")
    install_single_mode
    ;;
  "standalone")
    install_standalone_mode
    ;;
  "rac")
    install_rac_mode
    ;;
  esac
  # 优化数据库
  if [[ $optimize_db == "Y" ]]; then
    execute_and_log "正在优化数据库" db_optimize
  fi
  if ((node_num == 1)); then
    if [[ $huge_flag == "Y" ]]; then
      execute_and_log "正在配置内存大页" conf_hugepage
    fi
  fi
  install_time_record "end"
}
# 执行主函数
main "$@" | tee -a "$oracleprintlog"
